/*
* Generated by util/mkerr.pl DO NOT EDIT
* Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.
*
* Licensed under the OpenSSL license (the "License").  You may not use
* this file except in compliance with the License.  You can obtain a copy
* in the file LICENSE in the source distribution or at
* https://www.openssl.org/source/license.html
*/
using System;

namespace Beef_Net.OpenSSL
{
	[AlwaysInclude]
	sealed abstract class EVP
	{
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public extern static int ERR_load_EVP_strings();

		/*
		 * EVP function codes.
		 */
		public const int F_AESNI_INIT_KEY                                  = 165;
		public const int F_AESNI_XTS_INIT_KEY                              = 207;
		public const int F_AES_GCM_CTRL                                    = 196;
		public const int F_AES_INIT_KEY                                    = 133;
		public const int F_AES_OCB_CIPHER                                  = 169;
		public const int F_AES_T4_INIT_KEY                                 = 178;
		public const int F_AES_T4_XTS_INIT_KEY                             = 208;
		public const int F_AES_WRAP_CIPHER                                 = 170;
		public const int F_AES_XTS_INIT_KEY                                = 209;
		public const int F_ALG_MODULE_INIT                                 = 177;
		public const int F_ARIA_CCM_INIT_KEY                               = 175;
		public const int F_ARIA_GCM_CTRL                                   = 197;
		public const int F_ARIA_GCM_INIT_KEY                               = 176;
		public const int F_ARIA_INIT_KEY                                   = 185;
		public const int F_B64_NEW                                         = 198;
		public const int F_CAMELLIA_INIT_KEY                               = 159;
		public const int F_CHACHA20_POLY1305_CTRL                          = 182;
		public const int F_CMLL_T4_INIT_KEY                                = 179;
		public const int F_DES_EDE3_WRAP_CIPHER                            = 171;
		public const int F_DO_SIGVER_INIT                                  = 161;
		public const int F_ENC_NEW                                         = 199;
		public const int F_EVP_CIPHERINIT_EX                               = 123;
		public const int F_EVP_CIPHER_ASN1_TO_PARAM                        = 204;
		public const int F_EVP_CIPHER_CTX_COPY                             = 163;
		public const int F_EVP_CIPHER_CTX_CTRL                             = 124;
		public const int F_EVP_CIPHER_CTX_SET_KEY_LENGTH                   = 122;
		public const int F_EVP_CIPHER_PARAM_TO_ASN1                        = 205;
		public const int F_EVP_DECRYPTFINAL_EX                             = 101;
		public const int F_EVP_DECRYPTUPDATE                               = 166;
		public const int F_EVP_DIGESTFINALXOF                              = 174;
		public const int F_EVP_DIGESTINIT_EX                               = 128;
		public const int F_EVP_ENCRYPTDECRYPTUPDATE                        = 219;
		public const int F_EVP_ENCRYPTFINAL_EX                             = 127;
		public const int F_EVP_ENCRYPTUPDATE                               = 167;
		public const int F_EVP_MD_CTX_COPY_EX                              = 110;
		public const int F_EVP_MD_SIZE                                     = 162;
		public const int F_EVP_OPENINIT                                    = 102;
		public const int F_EVP_PBE_ALG_ADD                                 = 115;
		public const int F_EVP_PBE_ALG_ADD_TYPE                            = 160;
		public const int F_EVP_PBE_CIPHERINIT                              = 116;
		public const int F_EVP_PBE_SCRYPT                                  = 181;
		public const int F_EVP_PKCS82PKEY                                  = 111;
		public const int F_EVP_PKEY2PKCS8                                  = 113;
		public const int F_EVP_PKEY_ASN1_ADD0                              = 188;
		public const int F_EVP_PKEY_CHECK                                  = 186;
		public const int F_EVP_PKEY_COPY_PARAMETERS                        = 103;
		public const int F_EVP_PKEY_CTX_CTRL                               = 137;
		public const int F_EVP_PKEY_CTX_CTRL_STR                           = 150;
		public const int F_EVP_PKEY_CTX_DUP                                = 156;
		public const int F_EVP_PKEY_CTX_MD                                 = 168;
		public const int F_EVP_PKEY_DECRYPT                                = 104;
		public const int F_EVP_PKEY_DECRYPT_INIT                           = 138;
		public const int F_EVP_PKEY_DECRYPT_OLD                            = 151;
		public const int F_EVP_PKEY_DERIVE                                 = 153;
		public const int F_EVP_PKEY_DERIVE_INIT                            = 154;
		public const int F_EVP_PKEY_DERIVE_SET_PEER                        = 155;
		public const int F_EVP_PKEY_ENCRYPT                                = 105;
		public const int F_EVP_PKEY_ENCRYPT_INIT                           = 139;
		public const int F_EVP_PKEY_ENCRYPT_OLD                            = 152;
		public const int F_EVP_PKEY_GET0_DH                                = 119;
		public const int F_EVP_PKEY_GET0_DSA                               = 120;
		public const int F_EVP_PKEY_GET0_EC_KEY                            = 131;
		public const int F_EVP_PKEY_GET0_HMAC                              = 183;
		public const int F_EVP_PKEY_GET0_POLY1305                          = 184;
		public const int F_EVP_PKEY_GET0_RSA                               = 121;
		public const int F_EVP_PKEY_GET0_SIPHASH                           = 172;
		public const int F_EVP_PKEY_GET_RAW_PRIVATE_KEY                    = 202;
		public const int F_EVP_PKEY_GET_RAW_PUBLIC_KEY                     = 203;
		public const int F_EVP_PKEY_KEYGEN                                 = 146;
		public const int F_EVP_PKEY_KEYGEN_INIT                            = 147;
		public const int F_EVP_PKEY_METH_ADD0                              = 194;
		public const int F_EVP_PKEY_METH_NEW                               = 195;
		public const int F_EVP_PKEY_NEW                                    = 106;
		public const int F_EVP_PKEY_NEW_CMAC_KEY                           = 193;
		public const int F_EVP_PKEY_NEW_RAW_PRIVATE_KEY                    = 191;
		public const int F_EVP_PKEY_NEW_RAW_PUBLIC_KEY                     = 192;
		public const int F_EVP_PKEY_PARAMGEN                               = 148;
		public const int F_EVP_PKEY_PARAMGEN_INIT                          = 149;
		public const int F_EVP_PKEY_PARAM_CHECK                            = 189;
		public const int F_EVP_PKEY_PUBLIC_CHECK                           = 190;
		public const int F_EVP_PKEY_SET1_ENGINE                            = 187;
		public const int F_EVP_PKEY_SET_ALIAS_TYPE                         = 206;
		public const int F_EVP_PKEY_SIGN                                   = 140;
		public const int F_EVP_PKEY_SIGN_INIT                              = 141;
		public const int F_EVP_PKEY_VERIFY                                 = 142;
		public const int F_EVP_PKEY_VERIFY_INIT                            = 143;
		public const int F_EVP_PKEY_VERIFY_RECOVER                         = 144;
		public const int F_EVP_PKEY_VERIFY_RECOVER_INIT                    = 145;
		public const int F_EVP_SIGNFINAL                                   = 107;
		public const int F_EVP_VERIFYFINAL                                 = 108;
		public const int F_INT_CTX_NEW                                     = 157;
		public const int F_OK_NEW                                          = 200;
		public const int F_PKCS5_PBE_KEYIVGEN                              = 117;
		public const int F_PKCS5_V2_PBE_KEYIVGEN                           = 118;
		public const int F_PKCS5_V2_PBKDF2_KEYIVGEN                        = 164;
		public const int F_PKCS5_V2_SCRYPT_KEYIVGEN                        = 180;
		public const int F_PKEY_SET_TYPE                                   = 158;
		public const int F_RC2_MAGIC_TO_METH                               = 109;
		public const int F_RC5_CTRL                                        = 125;
		public const int F_R_32_12_16_INIT_KEY                             = 242;
		public const int F_S390X_AES_GCM_CTRL                              = 201;
		public const int F_UPDATE                                          = 173;

		/*
		 * EVP reason codes.
		 */
		public const int R_AES_KEY_SETUP_FAILED                            = 143;
		public const int R_ARIA_KEY_SETUP_FAILED                           = 176;
		public const int R_BAD_DECRYPT                                     = 100;
		public const int R_BAD_KEY_LENGTH                                  = 195;
		public const int R_BUFFER_TOO_SMALL                                = 155;
		public const int R_CAMELLIA_KEY_SETUP_FAILED                       = 157;
		public const int R_CIPHER_PARAMETER_ERROR                          = 122;
		public const int R_COMMAND_NOT_SUPPORTED                           = 147;
		public const int R_COPY_ERROR                                      = 173;
		public const int R_CTRL_NOT_IMPLEMENTED                            = 132;
		public const int R_CTRL_OPERATION_NOT_IMPLEMENTED                  = 133;
		public const int R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH               = 138;
		public const int R_DECODE_ERROR                                    = 114;
		public const int R_DIFFERENT_KEY_TYPES                             = 101;
		public const int R_DIFFERENT_PARAMETERS                            = 153;
		public const int R_ERROR_LOADING_SECTION                           = 165;
		public const int R_ERROR_SETTING_FIPS_MODE                         = 166;
		public const int R_EXPECTING_AN_HMAC_KEY                           = 174;
		public const int R_EXPECTING_AN_RSA_KEY                            = 127;
		public const int R_EXPECTING_A_DH_KEY                              = 128;
		public const int R_EXPECTING_A_DSA_KEY                             = 129;
		public const int R_EXPECTING_A_EC_KEY                              = 142;
		public const int R_EXPECTING_A_POLY1305_KEY                        = 164;
		public const int R_EXPECTING_A_SIPHASH_KEY                         = 175;
		public const int R_FIPS_MODE_NOT_SUPPORTED                         = 167;
		public const int R_GET_RAW_KEY_FAILED                              = 182;
		public const int R_ILLEGAL_SCRYPT_PARAMETERS                       = 171;
		public const int R_INITIALIZATION_ERROR                            = 134;
		public const int R_INPUT_NOT_INITIALIZED                           = 111;
		public const int R_INVALID_DIGEST                                  = 152;
		public const int R_INVALID_FIPS_MODE                               = 168;
		public const int R_INVALID_IV_LENGTH                               = 194;
		public const int R_INVALID_KEY                                     = 163;
		public const int R_INVALID_KEY_LENGTH                              = 130;
		public const int R_INVALID_OPERATION                               = 148;
		public const int R_KEYGEN_FAILURE                                  = 120;
		public const int R_KEY_SETUP_FAILED                                = 180;
		public const int R_MEMORY_LIMIT_EXCEEDED                           = 172;
		public const int R_MESSAGE_DIGEST_IS_NULL                          = 159;
		public const int R_METHOD_NOT_SUPPORTED                            = 144;
		public const int R_MISSING_PARAMETERS                              = 103;
		public const int R_NOT_XOF_OR_INVALID_LENGTH                       = 178;
		public const int R_NO_CIPHER_SET                                   = 131;
		public const int R_NO_DEFAULT_DIGEST                               = 158;
		public const int R_NO_DIGEST_SET                                   = 139;
		public const int R_NO_KEY_SET                                      = 154;
		public const int R_NO_OPERATION_SET                                = 149;
		public const int R_ONLY_ONESHOT_SUPPORTED                          = 177;
		public const int R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE        = 150;
		public const int R_OPERATON_NOT_INITIALIZED                        = 151;
		public const int R_PARTIALLY_OVERLAPPING                           = 162;
		public const int R_PBKDF2_ERROR                                    = 181;
		public const int R_PKEY_APPLICATION_ASN1_METHOD_ALREADY_REGISTERED = 179;
		public const int R_PRIVATE_KEY_DECODE_ERROR                        = 145;
		public const int R_PRIVATE_KEY_ENCODE_ERROR                        = 146;
		public const int R_PUBLIC_KEY_NOT_RSA                              = 106;
		public const int R_UNKNOWN_CIPHER                                  = 160;
		public const int R_UNKNOWN_DIGEST                                  = 161;
		public const int R_UNKNOWN_OPTION                                  = 169;
		public const int R_UNKNOWN_PBE_ALGORITHM                           = 121;
		public const int R_UNSUPPORTED_ALGORITHM                           = 156;
		public const int R_UNSUPPORTED_CIPHER                              = 107;
		public const int R_UNSUPPORTED_KEYLENGTH                           = 123;
		public const int R_UNSUPPORTED_KEY_DERIVATION_FUNCTION             = 124;
		public const int R_UNSUPPORTED_KEY_SIZE                            = 108;
		public const int R_UNSUPPORTED_NUMBER_OF_ROUNDS                    = 135;
		public const int R_UNSUPPORTED_PRF                                 = 125;
		public const int R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM               = 118;
		public const int R_UNSUPPORTED_SALT_TYPE                           = 126;
		public const int R_WRAP_MODE_NOT_ALLOWED                           = 170;
		public const int R_WRONG_FINAL_BLOCK_LENGTH                        = 109;
		public const int R_XTS_DUPLICATED_KEYS                             = 183;

		[CRepr]
		public struct cipher_st
		{
		    public int nid;
		    public int block_size;
		    /* Default value for variable length ciphers */
		    public int key_len;
		    public int iv_len;
		    /* Various flags */
		    public uint flags;
		    /* init key */
		    public function int(CIPHER_CTX* ctx, uint8* key, uint8* iv, int enc) init;
		    /* encrypt/decrypt data */
		    public function int(CIPHER_CTX* ctx, uint8* outVal, uint8* inVal, uint inl) do_cipher;
		    /* cleanup ctx */
		    public function int(CIPHER_CTX* ctx) cleanup;
		    /* how big ctx->cipher_data needs to be */
		    public int ctx_size;
		    /* Populate a ASN1_TYPE with parameters */
		    public function int(CIPHER_CTX* ctx, ASN1.TYPE* type) set_asn1_parameters;
		    /* Get parameters from a ASN1.TYPE */
		    public function int(CIPHER_CTX* ctx, ASN1.TYPE* type) get_asn1_parameters;
		    /* Miscellaneous operations */
		    public function int(CIPHER_CTX* ctx, int type, int arg, void* ptr) ctrl;
		    /* Application data */
		    public void* app_data;
		}
		public typealias CIPHER = cipher_st;
		
		[CRepr]
		public struct cipher_ctx_st
		{
		    public CIPHER* cipher;
		    public Engine.ENGINE* engine;         /* functional reference if 'cipher' is ENGINE-provided */
		    public int encrypt;                   /* encrypt or decrypt */
		    public int buf_len;                   /* number we have left */
		    public uint8[MAX_IV_LENGTH] oiv;      /* original iv */
		    public uint8[MAX_IV_LENGTH] iv;       /* working iv */
		    public uint8[MAX_BLOCK_LENGTH] buf;   /* saved partial block */
		    public int num;                       /* used by cfb/ofb/ctr mode */
		    /* FIXME: Should this even exist? It appears unused */
		    public void* app_data;                /* application stuff */
		    public int key_len;                   /* May change for variable length cipher */
		    public uint flags;                    /* Various flags */
		    public void* cipher_data;             /* per EVP data */
		    public int final_used;
		    public int block_mask;
		    public uint8[MAX_BLOCK_LENGTH] final; /* possible final block */
		}
		public typealias CIPHER_CTX = cipher_ctx_st;
		
		[CRepr]
		public struct md_st
		{
		    public int type;
		    public int pkey_type;
		    public int md_size;
		    public uint flags;
		    public function int(MD_CTX* ctx) init;
		    public function int(MD_CTX* ctx, void* data, uint  count) update;
		    public function int(MD_CTX* ctx, uint8* md) final;
		    public function int(MD_CTX* to, MD_CTX* from) copy;
		    public function int(MD_CTX* ctx) cleanup;
		    public int block_size;
		    public int ctx_size;               /* how big does the ctx->md_data need to be */
		    /* control function */
		    public function int(MD_CTX* ctx, int cmd, int p1, void* p2) md_ctrl;
		}
		public typealias MD = md_st;
		public struct stack_st_EVP_MD {}
		
		[CRepr]
		public struct md_ctx_st
		{
		    public MD* digest;
		    public Engine.ENGINE* engine; /* functional reference if 'digest' is ENGINE-provided */
		    public uint flags;
		    public void* md_data;
		    /* Public key context for sign/verify */
		    public PKEY_CTX* pctx;
		    /* Update function: usually copied from MD */
		    public function int(MD_CTX* ctx, void* data, uint count) update;
		}
		public typealias MD_CTX = md_ctx_st;
		
		[CRepr]
		public struct pkey_st
		{
		    public int type;
		    public int save_type;
		    public Crypto.REF_COUNT references;
		    public PKEY_ASN1_METHOD* ameth;
		    public Engine.ENGINE* engine;
		    public Engine.ENGINE* pmeth_engine; /* If not NULL public key ENGINE to use */
			public pkey_struct pkey;
		    public int save_parameters;
		    public X509.ATTRIBUTE* attributes; /* [ 0 ] */
		    public Crypto.RWLOCK* lock;

			[CRepr, Union]
			public struct pkey_struct
			{
        		public void* ptr;
#if !OPENSSL_NO_RSA
        		public RSA.rsa_st* rsa; /* RSA */
#endif
#if !OPENSSL_NO_DSA
        		public DSA.dsa_st* dsa; /* DSA */
#endif
#if !OPENSSL_NO_DH
				public DH.dh_st* dh;    /* DH */
#endif
#if !OPENSSL_NO_EC
		        public EC.key_st* ec;   /* ECC */
		        public ECX.KEY* ecx;    /* X25519, X448, Ed25519, Ed448 */
#endif
			}
		}
		public typealias PKEY = pkey_st;
		
		[CRepr]
		public struct pkey_asn1_method_st
		{
		    public int pkey_id;
		    public int pkey_base_id;
		    public uint pkey_flags;
		    public char8* pem_str;
		    public char8* info;
		    public function int(PKEY* pk, X509.PUBKEY* pub) pub_decode;
		    public function int(X509.PUBKEY* pub, PKEY* pk) pub_encode;
		    public function int(PKEY* a, PKEY* b) pub_cmp;
		    public function int(BIO.bio_st* outVal, PKEY* pkey, int indent, ASN1.PCTX* pctx) pub_print;
		    public function int(PKEY* pk, PKCS8.PRIV_KEY_INFO* p8inf) priv_decode;
		    public function int(PKCS8.PRIV_KEY_INFO* p8, PKEY* pk) priv_encode;
		    public function int(BIO.bio_st* outVal, PKEY* pkey, int indent, ASN1.PCTX* pctx) priv_print;
		    public function int(PKEY* pk) pkey_size;
		    public function int(PKEY* pk) pkey_bits;
		    public function int(PKEY* pk) pkey_security_bits;
		    public function int(PKEY* pkey, uint8** pder, int derlen) param_decode;
		    public function int(PKEY* pkey, uint8** pder) param_encode;
		    public function int(PKEY* pk) param_missing;
		    public function int(PKEY* to, PKEY* from) param_copy;
		    public function int(PKEY* a, PKEY* b) param_cmp;
		    public function int(BIO.bio_st* outVal, PKEY* pkey, int indent, ASN1.PCTX* pctx) param_print;
		    public function int(BIO.bio_st* outVal, X509.ALGOR* sigalg, ASN1.STRING* sig, int indent, ASN1.PCTX* pctx) sig_print;
		    public function void(PKEY* pkey) pkey_free;
		    public function int(PKEY* pkey, int op, int arg1, void* arg2) pkey_ctrl;
		    /* Legacy functions for old PEM */
		    public function int(PKEY* pkey, uint8** pder, int derlen) old_priv_decode;
		    public function int(PKEY* pkey, uint8** pder) old_priv_encode;
		    /* Custom ASN1 signature verification */
		    public function int(MD_CTX* ctx, ASN1.ITEM* it, void* asn, X509.ALGOR* a, ASN1.BIT_STRING* sig, PKEY* pkey) item_verify;
		    public function int(MD_CTX* ctx, ASN1.ITEM* it, void* asn, X509.ALGOR* alg1, X509.ALGOR* alg2, ASN1.BIT_STRING* sig) item_sign;
		    public function int(X509.SIG_INFO* siginf, X509.ALGOR* alg, ASN1.STRING* sig) siginf_set;
		    /* Check */
		    public function int(PKEY* pk) pkey_check;
		    public function int(PKEY* pk) pkey_public_check;
		    public function int(PKEY* pk) pkey_param_check;
		    /* Get/set raw private/public key data */
		    public function int(PKEY* pk, uint8* priv, uint len) set_priv_key;
		    public function int(PKEY* pk, uint8* pub, uint len) set_pub_key;
		    public function int(PKEY* pk, uint8* priv, uint* len) get_priv_key;
		    public function int(PKEY* pk, uint8* pub, uint* len) get_pub_key;
		}
		public typealias PKEY_ASN1_METHOD = pkey_asn1_method_st;

		[CRepr]
		public struct pkey_method_st
		{
		    public int pkey_id;
		    public int flags;
		    public function int(PKEY_CTX* ctx) init;
		    public function int(PKEY_CTX* dst, PKEY_CTX* src) copy;
		    public function void(PKEY_CTX* ctx) cleanup;
		    public function int(PKEY_CTX* ctx) paramgen_init;
		    public function int(PKEY_CTX* ctx, PKEY* pkey) paramgen;
		    public function int(PKEY_CTX* ctx) keygen_init;
		    public function int(PKEY_CTX* ctx, PKEY* pkey) keygen;
		    public function int(PKEY_CTX* ctx) sign_init;
		    public function int(PKEY_CTX* ctx, uint8* sig, uint* siglen, uint8* tbs, uint tbslen) sign;
		    public function int(PKEY_CTX* ctx) verify_init;
		    public function int(PKEY_CTX* ctx, uint8* sig, uint siglen, uint8* tbs, uint tbslen) verify;
		    public function int(PKEY_CTX* ctx) verify_recover_init;
		    public function int(PKEY_CTX* ctx, uint8* rout, uint* routlen, uint8* sig, uint siglen) verify_recover;
		    public function int(PKEY_CTX* ctx, MD_CTX* mctx) signctx_init;
		    public function int(PKEY_CTX* ctx, uint8* sig, uint* siglen, MD_CTX* mctx) signctx;
		    public function int(PKEY_CTX* ctx, MD_CTX* mctx) verifyctx_init;
		    public function int(PKEY_CTX* ctx, uint8* sig, int siglen, MD_CTX* mctx) verifyctx;
		    public function int(PKEY_CTX* ctx) encrypt_init;
		    public function int(PKEY_CTX* ctx, uint8* outVal, uint* outlen, uint8* inVal, uint inlen) encrypt;
		    public function int(PKEY_CTX* ctx) decrypt_init;
		    public function int(PKEY_CTX* ctx, uint8* outVal, uint* outlen, uint8* inVal, uint inlen) decrypt;
		    public function int(PKEY_CTX* ctx) derive_init;
		    public function int(PKEY_CTX* ctx, uint8* key, uint* keylen) derive;
		    public function int(PKEY_CTX* ctx, int type, int p1, void* p2) ctrl;
		    public function int(PKEY_CTX* ctx, char8* type, char8* value) ctrl_str;
		    public function int(MD_CTX* ctx, uint8* sig, uint* siglen, uint8* tbs, uint tbslen) digestsign;
		    public function int(MD_CTX* ctx, uint8* sig, uint siglen, uint8* tbs, uint tbslen) digestverify;
		    public function int(PKEY* pkey) check;
		    public function int(PKEY* pkey) public_check;
		    public function int(PKEY* pkey) param_check;
		    public function int(PKEY_CTX* ctx, MD_CTX* mctx) digest_custom;
		}
		public typealias PKEY_METHOD = pkey_method_st;
		
		[CRepr]
		public struct pkey_ctx_st
		{
		    /* Method associated with this operation */
		    public PKEY_METHOD* pmeth;
		    /* Engine that implements this method or NULL if builtin */
		    public Engine.ENGINE* engine;
		    /* Key: may be NULL */
		    public PKEY* pkey;
		    /* Peer key for key agreement, may be NULL */
		    public PKEY* peerkey;
		    /* Actual operation */
		    public int operation;
		    /* Algorithm specific data */
		    public void* data;
		    /* Application specific data */
		    public void* app_data;
		    /* Keygen callback */
		    public PKEY_gen_cb pkey_gencb;
		    /* implementation specific keygen data */
		    public int* keygen_info;
		    public int keygen_info_count;
		}
		public typealias PKEY_CTX = pkey_ctx_st;
		
		[CRepr]
		public struct Encode_Ctx_st
		{
		    /* number saved in a partial encode/decode */
		    public int num;
		    /* The length is either the output line length (in input bytes) or the shortest input line length that is ok.  Once decoding begins, the length is adjusted up each time a longer line is decoded */
		    public int length;
		    /* data to encode */
		    public uint8[80] enc_data;
		    /* number read on current line */
		    public int line_num;
		    public uint flags;
		}
		public typealias ENCODE_CTX = Encode_Ctx_st;

		public function int PKEY_gen_cb(PKEY_CTX* ctx);

		public const int MAX_MD_SIZE      = 64;/* longest known is SHA512 */
		public const int MAX_KEY_LENGTH   = 64;
		public const int MAX_IV_LENGTH    = 16;
		public const int MAX_BLOCK_LENGTH = 32;

		public const int PK_RSA   = 0x0001;
		public const int PK_DSA   = 0x0002;
		public const int PK_DH    = 0x0004;
		public const int PK_EC    = 0x0008;
		public const int PKT_SIGN = 0x0010;
		public const int PKT_ENC  = 0x0020;
		public const int PKT_EXCH = 0x0040;
		public const int PKS_RSA  = 0x0100;
		public const int PKS_DSA  = 0x0200;
		public const int PKS_EC   = 0x0400;
		
		public const int PKEY_NONE     = NID.undef;
		public const int PKEY_RSA      = NID.rsaEncryption;
		public const int PKEY_RSA2     = NID.rsa;
		public const int PKEY_RSA_PSS  = NID.rsassaPss;
		public const int PKEY_DSA      = NID.dsa;
		public const int PKEY_DSA1     = NID.dsa_2;
		public const int PKEY_DSA2     = NID.dsaWithSHA;
		public const int PKEY_DSA3     = NID.dsaWithSHA1;
		public const int PKEY_DSA4     = NID.dsaWithSHA1_2;
		public const int PKEY_DH       = NID.dhKeyAgreement;
		public const int PKEY_DHX      = NID.dhpublicnumber;
		public const int PKEY_EC       = NID.X9_62_id_ecPublicKey;
		public const int PKEY_SM2      = NID.sm2;
		public const int PKEY_HMAC     = NID.hmac;
		public const int PKEY_CMAC     = NID.cmac;
		public const int PKEY_SCRYPT   = NID.id_scrypt;
		public const int PKEY_TLS1_PRF = NID.tls1_prf;
		public const int PKEY_HKDF     = NID.hkdf;
		public const int PKEY_POLY1305 = NID.poly1305;
		public const int PKEY_SIPHASH  = NID.siphash;
		public const int PKEY_X25519   = NID.X25519;
		public const int PKEY_ED25519  = NID.ED25519;
		public const int PKEY_X448     = NID.X448;
		public const int PKEY_ED448    = NID.ED448;

		public const int PKEY_MO_SIGN    = 0x0001;
		public const int PKEY_MO_VERIFY  = 0x0002;
		public const int PKEY_MO_ENCRYPT = 0x0004;
		public const int PKEY_MO_DECRYPT = 0x0008;
		
#if !EVP_MD
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_new")
		]
		public extern static MD* MD_meth_new(int md_type, int pkey_type);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_dup")
		]
		public extern static MD* MD_meth_dup(MD* md);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_free")
		]
		public extern static void MD_meth_free(MD* md);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_set_input_blocksize")
		]
		public extern static int MD_meth_set_input_blocksize(MD* md, int blocksize);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_set_result_size")
		]
		public extern static int MD_meth_set_result_size(MD* md, int resultsize);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_set_app_datasize")
		]
		public extern static int MD_meth_set_app_datasize(MD* md, int datasize);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_set_flags")
		]
		public extern static int MD_meth_set_flags(MD* md, uint flags);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_set_init")
		]
		public extern static int MD_meth_set_init(MD* md, function int(MD_CTX* ctx) init);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_set_update")
		]
		public extern static int MD_meth_set_update(MD* md, function int(MD_CTX* ctx, void* data, uint count) update);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_set_final")
		]
		public extern static int MD_meth_set_final(MD* md, function int(MD_CTX* ctx, uint8* md) final);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_set_copy")
		]
		public extern static int MD_meth_set_copy(MD* md, function int(MD_CTX* to, MD_CTX* from) copy);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_set_cleanup")
		]
		public extern static int MD_meth_set_cleanup(MD* md, function int(MD_CTX* ctx) cleanup);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_set_ctrl")
		]
		public extern static int MD_meth_set_ctrl(MD* md, function int(MD_CTX* ctx, int cmd, int p1, void* p2) ctrl);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_get_input_blocksize")
		]
		public extern static int MD_meth_get_input_blocksize(MD* md);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_get_result_size")
		]
		public extern static int MD_meth_get_result_size(MD* md);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_get_app_datasize")
		]
		public extern static int MD_meth_get_app_datasize(MD* md);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_get_flags")
		]
		public extern static uint MD_meth_get_flags(MD* md);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_get_init")
		]
		public extern static function int(MD_CTX* ctx) MD_meth_get_init(MD* md);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_get_update")
		]
		public extern static function int(MD_CTX* ctx, void* data, uint count) MD_meth_get_update(MD* md);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_get_final")
		]
		public extern static function int(MD_CTX* ctx, uint8* md) MD_meth_get_final(MD* md);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_get_copy")
		]
		public extern static function int(MD_CTX* to, MD_CTX* from) MD_meth_get_copy(MD* md);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_get_cleanup")
		]
		public extern static function int(MD_CTX* ctx) MD_meth_get_cleanup(MD* md);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_meth_get_ctrl")
		]
		public extern static function int(MD_CTX* ctx, int cmd, int p1, void* p2) MD_meth_get_ctrl(MD* md);
		
		/* NULL or absent parameter accepted. Use NULL */
		public const int MD_FLAG_DIGALGID_NULL   = 0x0000;
		/* digest can only handle a single block */
		public const int MD_FLAG_ONESHOT         = 0x0001;
		/* digest is extensible-output function, XOF */
		public const int MD_FLAG_XOF             = 0x0002;
		/* NULL or absent parameter accepted. Use NULL for PKCS#1 otherwise absent */
		public const int MD_FLAG_DIGALGID_ABSENT = 0x0008;
		/* DigestAlgorithmIdentifier flags... */
		public const int MD_FLAG_DIGALGID_MASK   = 0x0018;
		/* Custom handling via ctrl */
		public const int MD_FLAG_DIGALGID_CUSTOM = 0x0018;
		/* Note if suitable for use in FIPS mode */
		public const int MD_FLAG_FIPS            = 0x0400;
		
		/* Digest ctrls */
		public const int _MD_CTRL_DIGALGID = 0x1;
		public const int MD_CTRL_MICALG    = 0x2;
		public const int MD_CTRL_XOF_LEN   = 0x3;
		
		/* Minimum Algorithm specific ctrl value */
		public const int MD_CTRL_ALG_CTRL  = 0x1000;
#endif

		/* values for MD_CTX flags */
		public const int MD_CTX_FLAG_ONESHOT        = 0x0001; /* digest update will be called once only */
		public const int MD_CTX_FLAG_CLEANED        = 0x0002; /* context has already been cleaned */
		public const int MD_CTX_FLAG_REUSE          = 0x0004; /* Don't free up ctx->md_data in MD_CTX_reset */
		/* FIPS and pad options are ignored in 1.0.0, definitions are here so we don't accidentally reuse the values for other purposes. */
		public const int MD_CTX_FLAG_NON_FIPS_ALLOW = 0x0008; /* Allow use of non FIPS digest in FIPS mode */

		/* The following PAD options are also currently ignored in 1.0.0, digest parameters are handled through DigestSign*() and DigestVerify*() instead. */
		public const int MD_CTX_FLAG_PAD_MASK       = 0xF0; /* RSA mode to use */
		public const int MD_CTX_FLAG_PAD_PKCS1      = 0x00; /* PKCS#1 v1.5 mode */
		public const int MD_CTX_FLAG_PAD_X931       = 0x10; /* X9.31 mode */
		public const int MD_CTX_FLAG_PAD_PSS        = 0x20; /* PSS mode */

		public const int MD_CTX_FLAG_NO_INIT        = 0x0100; /* Don't initialize md_data */
		/*
		 * Some functions such as DigestSign only finalise copies of internal contexts so additional data can be included after the finalisation call.
		 * This is inefficient if this functionality is not required: it is disabled if the following flag is set.
		 */
		public const int MD_CTX_FLAG_FINALISE       = 0x0200;
		/* NOTE: 0x0400 is reserved for internal usage */
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_new")
		]
		public extern static CIPHER* CIPHER_meth_new(int cipher_type, int block_size, int key_len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_dup")
		]
		public extern static CIPHER* CIPHER_meth_dup(CIPHER* cipher);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_free")
		]
		public extern static void CIPHER_meth_free(CIPHER* cipher);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_set_iv_length")
		]
		public extern static int CIPHER_meth_set_iv_length(CIPHER* cipher, int iv_len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_set_flags")
		]
		public extern static int CIPHER_meth_set_flags(CIPHER* cipher, uint flags);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_set_impl_ctx_size")
		]
		public extern static int CIPHER_meth_set_impl_ctx_size(CIPHER* cipher, int ctx_size);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_set_init")
		]
		public extern static int CIPHER_meth_set_init(CIPHER* cipher, function int(CIPHER_CTX* ctx, uint8* key, uint8* iv, int enc) init);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_set_do_cipher")
		]
		public extern static int CIPHER_meth_set_do_cipher(CIPHER* cipher, function int(CIPHER_CTX* ctx, uint8* outVal, uint8* inVal, uint inl) do_cipher);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_set_cleanup")
		]
		public extern static int CIPHER_meth_set_cleanup(CIPHER* cipher, function int(CIPHER_CTX* ctx) cleanup);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_set_set_asn1_params")
		]
		public extern static int CIPHER_meth_set_set_asn1_params(CIPHER* cipher, function int(CIPHER_CTX* ctx, ASN1.TYPE* type) set_asn1_parameters);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_set_get_asn1_params")
		]
		public extern static int CIPHER_meth_set_get_asn1_params(CIPHER* cipher, function int(CIPHER_CTX* ctx, ASN1.TYPE* type) get_asn1_parameters);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_set_ctrl")
		]
		public extern static int CIPHER_meth_set_ctrl(CIPHER* cipher, function int(CIPHER_CTX* ctx, int type, int arg, void* ptr) ctrl);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_get_init")
		]
		public extern static function int(CIPHER_CTX* ctx, uint8* key, uint8* iv, int enc) CIPHER_meth_get_init(CIPHER* cipher);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_get_do_cipher")
		]
		public extern static function int(CIPHER_CTX* ctx, uint8* outVal, uint8* inVal, uint inl) CIPHER_meth_get_do_cipher(CIPHER* cipher);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_get_cleanup")
		]
		public extern static function int(CIPHER_CTX* ctx) CIPHER_meth_get_cleanup(CIPHER* cipher);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_get_set_asn1_params")
		]
		public extern static function int(CIPHER_CTX* ctx, ASN1.TYPE* type) CIPHER_meth_get_set_asn1_params(CIPHER* cipher);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_get_get_asn1_params")
		]
		public extern static function int(CIPHER_CTX* ctx, ASN1.TYPE* type) CIPHER_meth_get_get_asn1_params(CIPHER* cipher);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_meth_get_ctrl")
		]
		public extern static function int(CIPHER_CTX* ctx, int type, int arg, void* ptr) CIPHER_meth_get_ctrl(CIPHER* cipher);

		/* Values for cipher flags */
		/* Modes for ciphers */
		public const int CIPH_STREAM_CIPHER          = 0x0;
		public const int CIPH_ECB_MODE               = 0x1;
		public const int CIPH_CBC_MODE               = 0x2;
		public const int CIPH_CFB_MODE               = 0x3;
		public const int CIPH_OFB_MODE               = 0x4;
		public const int CIPH_CTR_MODE               = 0x5;
		public const int CIPH_GCM_MODE               = 0x6;
		public const int CIPH_CCM_MODE               = 0x7;
		public const int CIPH_XTS_MODE               = 0x10001;
		public const int CIPH_WRAP_MODE              = 0x10002;
		public const int CIPH_OCB_MODE               = 0x10003;
		public const int CIPH_MODE                   = 0xF0007;
		/* Set if variable length cipher */
		public const int CIPH_VARIABLE_LENGTH        = 0x8;
		/* Set if the iv handling should be done by the cipher itself */
		public const int CIPH_CUSTOM_IV              = 0x10;
		/* Set if the cipher's init() function should be called if key is NULL */
		public const int CIPH_ALWAYS_CALL_INIT       = 0x20;
		/* Call ctrl() to init cipher parameters */
		public const int CIPH_CTRL_INIT              = 0x40;
		/* Don't use standard key length function */
		public const int CIPH_CUSTOM_KEY_LENGTH      = 0x80;
		/* Don't use standard block padding */
		public const int CIPH_NO_PADDING             = 0x100;
		/* cipher handles random key generation */
		public const int CIPH_RAND_KEY               = 0x200;
		/* cipher has its own additional copying logic */
		public const int CIPH_CUSTOM_COPY            = 0x400;
		/* Don't use standard iv length function */
		public const int CIPH_CUSTOM_IV_LENGTH       = 0x800;
		/* Allow use default ASN1 get/set iv */
		public const int CIPH_FLAG_DEFAULT_ASN1      = 0x1000;
		/* Buffer length in bits not bytes: CFB1 mode only */
		public const int CIPH_FLAG_LENGTH_BITS       = 0x2000;
		/* Note if suitable for use in FIPS mode */
		public const int CIPH_FLAG_FIPS              = 0x4000;
		/* Allow non FIPS cipher in FIPS mode */
		public const int CIPH_FLAG_NON_FIPS_ALLOW    = 0x8000;
		/* Cipher handles any and all padding logic as well as finalisation. */
		public const int CIPH_FLAG_CUSTOM_CIPHER     = 0x100000;
		public const int CIPH_FLAG_AEAD_CIPHER       = 0x200000;
		public const int CIPH_FLAG_TLS1_1_MULTIBLOCK = 0x400000;
		/* Cipher can handle pipeline operations */
		public const int CIPH_FLAG_PIPELINE          = 0X800000;

		/* Cipher context flag to indicate we can handle wrap mode: if allowed in older applications it could overflow buffers. */
		public const int CIPHER_CTX_FLAG_WRAP_ALLOW         = 0x1;

		/* ctrl() values */
		public const int CTRL_INIT                          = 0x0;
		public const int CTRL_SET_KEY_LENGTH                = 0x1;
		public const int CTRL_GET_RC2_KEY_BITS              = 0x2;
		public const int CTRL_SET_RC2_KEY_BITS              = 0x3;
		public const int CTRL_GET_RC5_ROUNDS                = 0x4;
		public const int CTRL_SET_RC5_ROUNDS                = 0x5;
		public const int CTRL_RAND_KEY                      = 0x6;
		public const int CTRL_PBE_PRF_NID                   = 0x7;
		public const int CTRL_COPY                          = 0x8;
		public const int CTRL_AEAD_SET_IVLEN                = 0x9;
		public const int CTRL_AEAD_GET_TAG                  = 0x10;
		public const int CTRL_AEAD_SET_TAG                  = 0x11;
		public const int CTRL_AEAD_SET_IV_FIXED             = 0x12;
		public const int CTRL_GCM_SET_IVLEN                 = CTRL_AEAD_SET_IVLEN;
		public const int CTRL_GCM_GET_TAG                   = CTRL_AEAD_GET_TAG;
		public const int CTRL_GCM_SET_TAG                   = CTRL_AEAD_SET_TAG;
		public const int CTRL_GCM_SET_IV_FIXED              = CTRL_AEAD_SET_IV_FIXED;
		public const int CTRL_GCM_IV_GEN                    = 0x13;
		public const int CTRL_CCM_SET_IVLEN                 = CTRL_AEAD_SET_IVLEN;
		public const int CTRL_CCM_GET_TAG                   = CTRL_AEAD_GET_TAG;
		public const int CTRL_CCM_SET_TAG                   = CTRL_AEAD_SET_TAG;
		public const int CTRL_CCM_SET_IV_FIXED              = CTRL_AEAD_SET_IV_FIXED;
		public const int CTRL_CCM_SET_L                     = 0x14;
		public const int CTRL_CCM_SET_MSGLEN                = 0x15;
		/* AEAD cipher deduces payload length and returns number of bytes required to store MAC and eventual padding. Subsequent call to Cipher even appends/verifies MAC. */
		public const int CTRL_AEAD_TLS1_AAD                 = 0x16;
		/* Used by composite AEAD ciphers, no-op in GCM, CCM... */
		public const int CTRL_AEAD_SET_MAC_KEY              = 0x17;
		/* Set the GCM invocation field, decrypt only */
		public const int CTRL_GCM_SET_IV_INV                = 0x18;
		public const int CTRL_TLS1_1_MULTIBLOCK_AAD         = 0x19;
		public const int CTRL_TLS1_1_MULTIBLOCK_ENCRYPT     = 0x1a;
		public const int CTRL_TLS1_1_MULTIBLOCK_DECRYPT     = 0x1b;
		public const int CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE = 0x1c;
		public const int CTRL_SSL3_MASTER_SECRET            = 0x1d;
		/* CTRL_SET_SBOX takes the char8*  specifying S-boxes */
		public const int CTRL_SET_SBOX                      = 0x1e;
		/* CTRL_SBOX_USED takes a 'uint' and 'char8* ', pointing at a pre-allocated buffer with specified size */
		public const int CTRL_SBOX_USED                     = 0x1f;
		/* CTRL_KEY_MESH takes 'uint' number of bytes to mesh the key after, 0 switches meshing off */
		public const int CTRL_KEY_MESH                      = 0x20;
		/* CTRL_BLOCK_PADDING_MODE takes the padding mode */
		public const int CTRL_BLOCK_PADDING_MODE            = 0x21;
		/* Set the output buffers to use for a pipelined operation */
		public const int CTRL_SET_PIPELINE_OUTPUT_BUFS      = 0x22;
		/* Set the input buffers to use for a pipelined operation */
		public const int CTRL_SET_PIPELINE_INPUT_BUFS       = 0x23;
		/* Set the input buffer lengths to use for a pipelined operation */
		public const int CTRL_SET_PIPELINE_INPUT_LENS       = 0x24;
		public const int CTRL_GET_IVLEN                     = 0x25;

		/* Padding modes */
		public const int PADDING_PKCS7     = 1;
		public const int PADDING_ISO7816_4 = 2;
		public const int PADDING_ANSI923   = 3;
		public const int PADDING_ISO10126  = 4;
		public const int PADDING_ZERO      = 5;

		/* RFC 5246 defines additional data to be 13 bytes in length */
		public const int AEAD_TLS1_AAD_LEN = 13;

		[CRepr]
		public struct CTRL_TLS1_1_MULTIBLOCK_PARAM
		{
		    public uint8* outp;
		    public uint8* inp;
		    public uint len;
		    public uint interleave;
		}

		/* GCM TLS constants */
		/* Length of fixed part of IV derived from PRF */
		public const int GCM_TLS_FIXED_IV_LEN    = 4;
		/* Length of explicit part of IV part of TLS records */
		public const int GCM_TLS_EXPLICIT_IV_LEN = 8;
		/* Length of tag for TLS */
		public const int GCM_TLS_TAG_LEN         = 16;

		/* CCM TLS constants */
		/* Length of fixed part of IV derived from PRF */
		public const int CCM_TLS_FIXED_IV_LEN    = 4;
		/* Length of explicit part of IV part of TLS records */
		public const int CCM_TLS_EXPLICIT_IV_LEN = 8;
		/* Total length of CCM IV length for TLS */
		public const int CCM_TLS_IV_LEN          = 12;
		/* Length of tag for TLS */
		public const int CCM_TLS_TAG_LEN         = 16;
		/* Length of CCM8 tag for TLS */
		public const int CCM8_TLS_TAG_LEN        = 8;

		/* Length of tag for TLS */
		public const int CHACHAPOLY_TLS_TAG_LEN  = 16;

		[CRepr]
		public struct cipher_info_st
		{
		    public CIPHER* cipher;
		    public uint8[MAX_IV_LENGTH] iv;
		}
		public typealias CIPHER_INFO = cipher_info_st;

		/* Password based encryption function */
		public function int PBE_KEYGEN(CIPHER_CTX* ctx, char8* pass, int passlen, ASN1.TYPE* param, CIPHER* cipher, MD* md, int en_de);

#if !OPENSSL_NO_RSA
		[Inline]
		public static int PKEY_assign_RSA(PKEY* pkey, char8* rsa) => PKEY_assign(pkey, PKEY_RSA, rsa);
#endif
#if !OPENSSL_NO_DSA
		[Inline]
		public static int PKEY_assign_DSA(PKEY* pkey, char8* dsa) => PKEY_assign(pkey, PKEY_DSA, dsa);
#endif
#if !OPENSSL_NO_DH
		[Inline]
		public static int PKEY_assign_DH(PKEY* pkey, char8* dh) => PKEY_assign(pkey, PKEY_DH, dh);
#endif
#if !OPENSSL_NO_EC
		[Inline]
		public static int PKEY_assign_EC_KEY(PKEY* pkey, char8* eckey) => PKEY_assign(pkey, PKEY_EC, eckey);
#endif
#if !OPENSSL_NO_SIPHASH
		[Inline]
		public static int PKEY_assign_SIPHASH(PKEY* pkey, char8* shkey) => PKEY_assign(pkey, PKEY_SIPHASH, shkey);
#endif
#if !OPENSSL_NO_POLY1305
		[Inline]
		public static int PKEY_assign_POLY1305(PKEY* pkey, char8* polykey) => PKEY_assign(pkey, PKEY_POLY1305, polykey);
#endif

		/* Add some extra combinations */
		[Inline]
		public static MD* get_digestbynid(int a) => get_digestbyname(Objects.nid2sn(a));
		[Inline]
		public static MD* get_digestbyobj(ASN1.OBJECT* a) => get_digestbynid(Objects.obj2nid(a));
		[Inline]
		public static CIPHER* get_cipherbynid(int a) => get_cipherbyname(Objects.nid2sn(a));
		[Inline]
		public static CIPHER* get_cipherbyobj(ASN1.OBJECT* a) => get_cipherbynid(Objects.obj2nid(a));
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_type")
		]
		public extern static int MD_type(MD* md);
		[Inline]
		public static int MD_nid(MD* md) => MD_type(md);
		[Inline]
		public static char8* MD_name(MD* md) => Objects.nid2sn(MD_nid(md));
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_pkey_type")
		]
		public extern static int MD_pkey_type(MD* md);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_size")
		]
		public extern static int MD_size(MD* md);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_block_size")
		]
		public extern static int MD_block_size(MD* md);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_flags")
		]
		public extern static uint MD_flags(MD* md);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_CTX_md")
		]
		public extern static MD* MD_CTX_md(MD_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_CTX_update_fn")
		]
		public extern static function int(MD_CTX* ctx, void* data, uint count) MD_CTX_update_fn(MD_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_CTX_set_update_fn")
		]
		public extern static void MD_CTX_set_update_fn(MD_CTX* ctx, function int(MD_CTX* ctx, void* data, uint count) update);
		[Inline]
		public static int MD_CTX_size(MD_CTX* ctx) => MD_size(MD_CTX_md(ctx));
		[Inline]
		public static int MD_CTX_block_size(MD_CTX* ctx) => MD_block_size(MD_CTX_md(ctx));
		[Inline]
		public static int MD_CTX_type(MD_CTX* ctx) => MD_type(MD_CTX_md(ctx));
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_CTX_pkey_ctx")
		]
		public extern static PKEY_CTX* MD_CTX_pkey_ctx(MD_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_CTX_set_pkey_ctx")
		]
		public extern static void MD_CTX_set_pkey_ctx(MD_CTX* ctx, PKEY_CTX* pctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_CTX_md_data")
		]
		public extern static void* MD_CTX_md_data(MD_CTX* ctx);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_nid")
		]
		public extern static int CIPHER_nid(CIPHER* cipher);
		[Inline]
		public static char8* CIPHER_name(CIPHER* cipher) => Objects.nid2sn(CIPHER_nid(cipher));
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_block_size")
		]
		public extern static int CIPHER_block_size(CIPHER* cipher);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_impl_ctx_size")
		]
		public extern static int CIPHER_impl_ctx_size(CIPHER* cipher);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_key_length")
		]
		public extern static int CIPHER_key_length(CIPHER* cipher);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_iv_length")
		]
		public extern static int CIPHER_iv_length(CIPHER* cipher);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_flags")
		]
		public extern static uint CIPHER_flags(CIPHER* cipher);
		[Inline]
		public static uint CIPHER_mode(CIPHER* cipher) => (CIPHER_flags(cipher) & CIPH_MODE);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_cipher")
		]
		public extern static CIPHER* CIPHER_CTX_cipher(CIPHER_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_encrypting")
		]
		public extern static int CIPHER_CTX_encrypting(CIPHER_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_nid")
		]
		public extern static int CIPHER_CTX_nid(CIPHER_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_block_size")
		]
		public extern static int CIPHER_CTX_block_size(CIPHER_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_key_length")
		]
		public extern static int CIPHER_CTX_key_length(CIPHER_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_iv_length")
		]
		public extern static int CIPHER_CTX_iv_length(CIPHER_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_iv")
		]
		public extern static uint8* CIPHER_CTX_iv(CIPHER_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_original_iv")
		]
		public extern static uint8* CIPHER_CTX_original_iv(CIPHER_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_iv_noconst")
		]
		public extern static uint8* CIPHER_CTX_iv_noconst(CIPHER_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_buf_noconst")
		]
		public extern static uint8* CIPHER_CTX_buf_noconst(CIPHER_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_num")
		]
		public extern static int CIPHER_CTX_num(CIPHER_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_set_num")
		]
		public extern static void CIPHER_CTX_set_num(CIPHER_CTX* ctx, int num);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_copy")
		]
		public extern static int CIPHER_CTX_copy(CIPHER_CTX* outVal, CIPHER_CTX* inVal);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_get_app_data")
		]
		public extern static void* CIPHER_CTX_get_app_data(CIPHER_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_set_app_data")
		]
		public extern static void CIPHER_CTX_set_app_data(CIPHER_CTX* ctx, void* data);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_get_cipher_data")
		]
		public extern static void* CIPHER_CTX_get_cipher_data(CIPHER_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_set_cipher_data")
		]
		public extern static void* CIPHER_CTX_set_cipher_data(CIPHER_CTX* ctx, void* cipher_data);
		[Inline]
		public static int CIPHER_CTX_type(CIPHER_CTX* c) => CIPHER_type(CIPHER_CTX_cipher(c));
		[Inline]
		public static uint CIPHER_CTX_flags(CIPHER_CTX* c) => CIPHER_flags(CIPHER_CTX_cipher(c));
		[Inline]
		public static uint CIPHER_CTX_mode(CIPHER_CTX* c) => CIPHER_mode(CIPHER_CTX_cipher(c));
		
		[Inline]
		public static uint ENCODE_LENGTH(uint l) => ((l + 2) / 3 * 4) + (l / 48 + 1) * 2 + 80;
		[Inline]
		public static uint DECODE_LENGTH(uint l) => (l + 3) / 4 * 3 + 80;
		
		[Inline]
		public static int SignInit_ex(MD_CTX* ctx, MD* type, Engine.ENGINE* impl) => DigestInit_ex(ctx, type, impl);
		[Inline]
		public static int SignInit(MD_CTX* ctx, MD* type) => DigestInit(ctx, type);
		[Inline]
		public static int SignUpdate(MD_CTX* ctx, void* d, uint cnt) => DigestUpdate(ctx, d, cnt);
		[Inline]
		public static int VerifyInit_ex(MD_CTX* ctx, MD* type, Engine.ENGINE* impl) => DigestInit_ex(ctx, type, impl);
		[Inline]
		public static int VerifyInit(MD_CTX* ctx, MD* type) => DigestInit(ctx, type);
		[Inline]
		public static int VerifyUpdate(MD_CTX* ctx, void* d, uint cnt) => DigestUpdate(ctx, d, cnt);
		[Inline]
		public static int OpenUpdate(CIPHER_CTX* ctx, uint8* outVal, int* outl, uint8* inVal, int inl) => DecryptUpdate(ctx, outVal, outl, inVal, inl);
		[Inline]
		public static int SealUpdate(CIPHER_CTX* ctx, uint8* outVal, int* outl, uint8* inVal, int inl) => EncryptUpdate(ctx, outVal, outl, inVal, inl);
		[Inline]
		public static int DigestSignUpdate(MD_CTX* ctx, void* d, uint cnt) => DigestUpdate(ctx, d, cnt);
		[Inline]
		public static int DigestVerifyUpdate(MD_CTX* ctx, void* d, uint cnt) => DigestUpdate(ctx, d, cnt);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_Cipher")
		]
		public extern static int Cipher(CIPHER_CTX* c, uint8* outVal, uint8* inVal, uint inl);

		[Inline]
		public static int add_cipher_alias(char8* n, char8* alias) => Objects.NAME_add(alias, Objects.NAME_TYPE_CIPHER_METH | Objects.NAME_ALIAS, n);
		[Inline]
		public static int add_digest_alias(char8* n, char8* alias) => Objects.NAME_add(alias, Objects.NAME_TYPE_MD_METH | Objects.NAME_ALIAS, n);
		[Inline]
		public static int delete_cipher_alias(char8* alias) => Objects.NAME_remove(alias, Objects.NAME_TYPE_CIPHER_METH | Objects.NAME_ALIAS);
		[Inline]
		public static int delete_digest_alias(char8* alias) => Objects.NAME_remove(alias, Objects.NAME_TYPE_MD_METH | Objects.NAME_ALIAS);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_CTX_ctrl")
		]
		public extern static int MD_CTX_ctrl(MD_CTX* ctx, int cmd, int p1, void* p2);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_CTX_new")
		]
		public extern static MD_CTX* MD_CTX_new();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_CTX_reset")
		]
		public extern static int MD_CTX_reset(MD_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_CTX_free")
		]
		public extern static void MD_CTX_free(MD_CTX* ctx);
		[Inline]
		public static MD_CTX* MD_CTX_create() => MD_CTX_new();
		[Inline]
		public static int MD_CTX_init(MD_CTX* ctx) => MD_CTX_reset(ctx);
		[Inline]
		public static void MD_CTX_destroy(MD_CTX* ctx) => MD_CTX_free(ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_CTX_copy_ex")
		]
		public extern static int MD_CTX_copy_ex(MD_CTX* outVal, MD_CTX* inVal);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_CTX_set_flags")
		]
		public extern static void MD_CTX_set_flags(MD_CTX* ctx, int flags);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_CTX_clear_flags")
		]
		public extern static void MD_CTX_clear_flags(MD_CTX* ctx, int flags);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_CTX_test_flags")
		]
		public extern static int MD_CTX_test_flags(MD_CTX* ctx, int flags);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DigestInit_ex")
		]
		public extern static int DigestInit_ex(MD_CTX* ctx, MD* type, Engine.ENGINE* impl);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DigestUpdate")
		]
		public extern static int DigestUpdate(MD_CTX* ctx, void* d, uint cnt);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DigestFinal_ex")
		]
		public extern static int DigestFinal_ex(MD_CTX* ctx, uint8* md, uint* s);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_Digest")
		]
		public extern static int Digest(void* data, uint count, uint8* md, uint* size, MD* type, Engine.ENGINE* impl);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_CTX_copy")
		]
		public extern static int MD_CTX_copy(MD_CTX* outVal, MD_CTX* inVal);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DigestInit")
		]
		public extern static int DigestInit(MD_CTX* ctx, MD* type);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DigestFinal")
		]
		public extern static int DigestFinal(MD_CTX* ctx, uint8* md, uint* s);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DigestFinalXOF")
		]
		public extern static int DigestFinalXOF(MD_CTX* ctx, uint8* md, uint len);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_read_pw_string")
		]
		public extern static int read_pw_string(char8* buf, int length, char8* prompt, int verify);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_read_pw_string_min")
		]
		public extern static int read_pw_string_min(char8* buf, int minlen, int maxlen, char8* prompt, int verify);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_set_pw_prompt")
		]
		public extern static void set_pw_prompt(char8* prompt);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_get_pw_prompt")
		]
		public extern static char8* get_pw_prompt();
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_BytesToKey")
		]
		public extern static int BytesToKey(CIPHER* type, MD* md, uint8* salt, uint8* data, int datal, int count, uint8* key, uint8* iv);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_set_flags")
		]
		public extern static void CIPHER_CTX_set_flags(CIPHER_CTX* ctx, int flags);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_clear_flags")
		]
		public extern static void CIPHER_CTX_clear_flags(CIPHER_CTX* ctx, int flags);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_test_flags")
		]
		public extern static int CIPHER_CTX_test_flags(CIPHER_CTX* ctx, int flags);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_EncryptInit")
		]
		public extern static int EncryptInit(CIPHER_CTX* ctx, CIPHER* cipher, uint8* key, uint8* iv);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_EncryptInit_ex")
		]
		public extern static int EncryptInit_ex(CIPHER_CTX* ctx, CIPHER* cipher, Engine.ENGINE* impl, uint8* key, uint8* iv);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_EncryptUpdate")
		]
		public extern static int EncryptUpdate(CIPHER_CTX* ctx, uint8* outVal, int* outl, uint8* inVal, int inl);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_EncryptFinal_ex")
		]
		public extern static int EncryptFinal_ex(CIPHER_CTX* ctx, uint8* outVal, int* outl);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_EncryptFinal")
		]
		public extern static int EncryptFinal(CIPHER_CTX* ctx, uint8* outVal, int* outl);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DecryptInit")
		]
		public extern static int DecryptInit(CIPHER_CTX* ctx, CIPHER* cipher, uint8* key, uint8* iv);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DecryptInit_ex")
		]
		public extern static int DecryptInit_ex(CIPHER_CTX* ctx, CIPHER* cipher, Engine.ENGINE* impl, uint8* key, uint8* iv);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DecryptUpdate")
		]
		public extern static int DecryptUpdate(CIPHER_CTX* ctx, uint8* outVal, int* outl, uint8* inVal, int inl);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DecryptFinal")
		]
		public extern static int DecryptFinal(CIPHER_CTX* ctx, uint8* outm, int* outl);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DecryptFinal_ex")
		]
		public extern static int DecryptFinal_ex(CIPHER_CTX* ctx, uint8* outm, int* outl);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CipherInit")
		]
		public extern static int CipherInit(CIPHER_CTX* ctx, CIPHER* cipher, uint8* key, uint8* iv, int enc);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CipherInit_ex")
		]
		public extern static int CipherInit_ex(CIPHER_CTX* ctx, CIPHER* cipher, Engine.ENGINE* impl, uint8* key, uint8* iv, int enc);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CipherUpdate")
		]
		public extern static int CipherUpdate(CIPHER_CTX* ctx, uint8* outVal, int* outl, uint8* inVal, int inl);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CipherFinal")
		]
		public extern static int CipherFinal(CIPHER_CTX* ctx, uint8* outm, int* outl);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CipherFinal_ex")
		]
		public extern static int CipherFinal_ex(CIPHER_CTX* ctx, uint8* outm, int* outl);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_SignFinal")
		]
		public extern static int SignFinal(MD_CTX* ctx, uint8* md, uint* s, PKEY* pkey);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DigestSign")
		]
		public extern static int DigestSign(MD_CTX* ctx, uint8* sigret, uint* siglen, uint8* tbs, uint tbslen);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_VerifyFinal")
		]
		public extern static int VerifyFinal(MD_CTX* ctx, uint8* sigbuf, uint siglen, PKEY* pkey);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DigestVerify")
		]
		public extern static int DigestVerify(MD_CTX* ctx, uint8* sigret, uint siglen, uint8* tbs, uint tbslen);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DigestSignInit")
		]
		public extern static int DigestSignInit(MD_CTX* ctx, PKEY_CTX** pctx, MD* type, Engine.ENGINE* e, PKEY* pkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DigestSignFinal")
		]
		public extern static int DigestSignFinal(MD_CTX* ctx, uint8* sigret, uint* siglen);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DigestVerifyInit")
		]
		public extern static int DigestVerifyInit(MD_CTX* ctx, PKEY_CTX** pctx, MD* type, Engine.ENGINE* e, PKEY* pkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DigestVerifyFinal")
		]
		public extern static int DigestVerifyFinal(MD_CTX* ctx, uint8* sig, uint siglen);

#if !OPENSSL_NO_RSA
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_OpenInit")
		]
		public extern static int OpenInit(CIPHER_CTX* ctx, CIPHER* type, uint8* ek, int ekl, uint8* iv, PKEY* priv);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_OpenFinal")
		]
		public extern static int OpenFinal(CIPHER_CTX* ctx, uint8* outVal, int* outl);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_SealInit")
		]
		public extern static int SealInit(CIPHER_CTX* ctx, CIPHER* type, uint8** ek, int* ekl, uint8* iv, PKEY** pubk, int npubk);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_SealFinal")
		]
		public extern static int SealFinal(CIPHER_CTX* ctx, uint8* outVal, int* outl);
#endif

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_ENCODE_CTX_new")
		]
		public extern static ENCODE_CTX* ENCODE_CTX_new();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_ENCODE_CTX_free")
		]
		public extern static void ENCODE_CTX_free(ENCODE_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_ENCODE_CTX_copy")
		]
		public extern static int ENCODE_CTX_copy(ENCODE_CTX* dctx, ENCODE_CTX* sctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_ENCODE_CTX_num")
		]
		public extern static int ENCODE_CTX_num(ENCODE_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_EncodeInit")
		]
		public extern static void EncodeInit(ENCODE_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_EncodeUpdate")
		]
		public extern static int EncodeUpdate(ENCODE_CTX* ctx, uint8* outVal, int* outl, uint8* inVal, int inl);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_EncodeFinal")
		]
		public extern static void EncodeFinal(ENCODE_CTX* ctx, uint8* outVal, int* outl);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_EncodeBlock")
		]
		public extern static int EncodeBlock(uint8* t, uint8* f, int n);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DecodeInit")
		]
		public extern static void DecodeInit(ENCODE_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DecodeUpdate")
		]
		public extern static int DecodeUpdate(ENCODE_CTX* ctx, uint8* outVal, int* outl, uint8* inVal, int inl);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DecodeFinal")
		]
		public extern static int DecodeFinal(ENCODE_CTX* ctx, uint8* outVal, int* outl);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_DecodeBlock")
		]
		public extern static int DecodeBlock(uint8* t, uint8* f, int n);

		[Inline]
		public static int CIPHER_CTX_init(CIPHER_CTX* c) => CIPHER_CTX_reset(c);
		[Inline]
		public static int CIPHER_CTX_cleanup(CIPHER_CTX* c) => CIPHER_CTX_reset(c);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_new")
		]
		public extern static CIPHER_CTX* CIPHER_CTX_new();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_reset")
		]
		public extern static int CIPHER_CTX_reset(CIPHER_CTX* c);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_free")
		]
		public extern static void CIPHER_CTX_free(CIPHER_CTX* c);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_set_key_length")
		]
		public extern static int CIPHER_CTX_set_key_length(CIPHER_CTX* x, int keylen);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_set_padding")
		]
		public extern static int CIPHER_CTX_set_padding(CIPHER_CTX* c, int pad);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_ctrl")
		]
		public extern static int CIPHER_CTX_ctrl(CIPHER_CTX* ctx, int type, int arg, void* ptr);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_CTX_rand_key")
		]
		public extern static int CIPHER_CTX_rand_key(CIPHER_CTX* ctx, uint8* key);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_md_null")
		]
		public extern static MD* md_null();
#if !OPENSSL_NO_MD2
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_md2")
		]
		public extern static MD* md2();
#endif
#if !OPENSSL_NO_MD4
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_md4")
		]
		public extern static MD* md4();
#endif
#if !OPENSSL_NO_MD5
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_md5")
		]
		public extern static MD* md5();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_md5_sha1")
		]
		public extern static MD* md5_sha1();
#endif
#if !OPENSSL_NO_BLAKE2
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_blake2b512")
		]
		public extern static MD* blake2b512();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_blake2s256")
		]
		public extern static MD* blake2s256();
#endif
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sha1")
		]
		public extern static MD* sha1();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sha224")
		]
		public extern static MD* sha224();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sha256")
		]
		public extern static MD* sha256();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sha384")
		]
		public extern static MD* sha384();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sha512")
		]
		public extern static MD* sha512();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sha512_224")
		]
		public extern static MD* sha512_224();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sha512_256")
		]
		public extern static MD* sha512_256();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sha3_224")
		]
		public extern static MD* sha3_224();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sha3_256")
		]
		public extern static MD* sha3_256();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sha3_384")
		]
		public extern static MD* sha3_384();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sha3_512")
		]
		public extern static MD* sha3_512();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_shake128")
		]
		public extern static MD* shake128();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_shake256")
		]
		public extern static MD* shake256();
#if !OPENSSL_NO_MDC2
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_mdc2")
		]
		public extern static MD* mdc2();
#endif
#if !OPENSSL_NO_RMD160
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_ripemd160")
		]
		public extern static MD* ripemd160();
#endif
#if !OPENSSL_NO_WHIRLPOOL
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_whirlpool")
		]
		public extern static MD* whirlpool();
#endif
#if !OPENSSL_NO_SM3
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sm3")
		]
		public extern static MD* sm3();
#endif
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_enc_null")
		]
		public extern static CIPHER* enc_null(); /* does nothing :-) */
#if !OPENSSL_NO_DES
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_ecb")
		]
		public extern static CIPHER* des_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_ede")
		]
		public extern static CIPHER* des_ede();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_ede3")
		]
		public extern static CIPHER* des_ede3();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_ede_ecb")
		]
		public extern static CIPHER* des_ede_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_ede3_ecb")
		]
		public extern static CIPHER* des_ede3_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_cfb64")
		]
		public extern static CIPHER* des_cfb64();
		[Inline]
		public static CIPHER* des_cfb() => des_cfb64();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_cfb1")
		]
		public extern static CIPHER* des_cfb1();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_cfb8")
		]
		public extern static CIPHER* des_cfb8();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_ede_cfb64")
		]
		public extern static CIPHER* des_ede_cfb64();
		[Inline]
		public static CIPHER* des_ede_cfb() => des_ede_cfb64();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_ede3_cfb64")
		]
		public extern static CIPHER* des_ede3_cfb64();
		[Inline]
		public static CIPHER* des_ede3_cfb() => des_ede3_cfb64();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_ede3_cfb1")
		]
		public extern static CIPHER* des_ede3_cfb1();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_ede3_cfb8")
		]
		public extern static CIPHER* des_ede3_cfb8();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_ofb")
		]
		public extern static CIPHER* des_ofb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_ede_ofb")
		]
		public extern static CIPHER* des_ede_ofb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_ede3_ofb")
		]
		public extern static CIPHER* des_ede3_ofb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_cbc")
		]
		public extern static CIPHER* des_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_ede_cbc")
		]
		public extern static CIPHER* des_ede_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_ede3_cbc")
		]
		public extern static CIPHER* des_ede3_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_desx_cbc")
		]
		public extern static CIPHER* desx_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_des_ede3_wrap")
		]
		public extern static CIPHER* des_ede3_wrap();
		/* This should now be supported through the dev_crypto ENGINE. But also, why are rc4 and md5 declarations made here inside a "NO_DES" precompiler branch? */
#endif
#if !OPENSSL_NO_RC4
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_rc4")
		]
		public extern static CIPHER* rc4();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_rc4_40")
		]
		public extern static CIPHER* rc4_40();
	#if !OPENSSL_NO_MD5
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_rc4_hmac_md5")
		]
		public extern static CIPHER* rc4_hmac_md5();
	#endif
#endif
#if !OPENSSL_NO_IDEA
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_idea_ecb")
		]
		public extern static CIPHER* idea_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_idea_cfb64")
		]
		public extern static CIPHER* idea_cfb64();
		[Inline]
		public static CIPHER* idea_cfb() => idea_cfb64();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_idea_ofb")
		]
		public extern static CIPHER* idea_ofb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_idea_cbc")
		]
		public extern static CIPHER* idea_cbc();
#endif
#if !OPENSSL_NO_RC2
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_rc2_ecb")
		]
		public extern static CIPHER* rc2_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_rc2_cbc")
		]
		public extern static CIPHER* rc2_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_rc2_40_cbc")
		]
		public extern static CIPHER* rc2_40_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_rc2_64_cbc")
		]
		public extern static CIPHER* rc2_64_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_rc2_cfb64")
		]
		public extern static CIPHER* rc2_cfb64();
		[Inline]
		public static CIPHER* rc2_cfb() => rc2_cfb64();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_rc2_ofb")
		]
		public extern static CIPHER* rc2_ofb();
#endif
#if !OPENSSL_NO_BF
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_bf_ecb")
		]
		public extern static CIPHER* bf_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_bf_cbc")
		]
		public extern static CIPHER* bf_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_bf_cfb64")
		]
		public extern static CIPHER* bf_cfb64();
		[Inline]
		public static CIPHER* bf_cfb() => bf_cfb64();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_bf_ofb")
		]
		public extern static CIPHER* bf_ofb();
#endif
#if !OPENSSL_NO_CAST
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_cast5_ecb")
		]
		public extern static CIPHER* cast5_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_cast5_cbc")
		]
		public extern static CIPHER* cast5_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_cast5_cfb64")
		]
		public extern static CIPHER* cast5_cfb64();
		[Inline]
		public static CIPHER* cast5_cfb() => cast5_cfb64();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_cast5_ofb")
		]
		public extern static CIPHER* cast5_ofb();
#endif
#if !OPENSSL_NO_RC5
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_rc5_32_12_16_cbc")
		]
		public extern static CIPHER* rc5_32_12_16_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_rc5_32_12_16_ecb")
		]
		public extern static CIPHER* rc5_32_12_16_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_rc5_32_12_16_cfb64")
		]
		public extern static CIPHER* rc5_32_12_16_cfb64();
		[Inline]
		public static CIPHER* rc5_32_12_16_cfb() => rc5_32_12_16_cfb64();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_rc5_32_12_16_ofb")
		]
		public extern static CIPHER* rc5_32_12_16_ofb();
#endif
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_128_ecb")
		]
		public extern static CIPHER* aes_128_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_128_cbc")
		]
		public extern static CIPHER* aes_128_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_128_cfb1")
		]
		public extern static CIPHER* aes_128_cfb1();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_128_cfb8")
		]
		public extern static CIPHER* aes_128_cfb8();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_128_cfb128")
		]
		public extern static CIPHER* aes_128_cfb128();
		[Inline]
		public static CIPHER* aes_128_cfb() => aes_128_cfb128();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_128_ofb")
		]
		public extern static CIPHER* aes_128_ofb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_128_ctr")
		]
		public extern static CIPHER* aes_128_ctr();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_128_ccm")
		]
		public extern static CIPHER* aes_128_ccm();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_128_gcm")
		]
		public extern static CIPHER* aes_128_gcm();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_128_xts")
		]
		public extern static CIPHER* aes_128_xts();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_128_wrap")
		]
		public extern static CIPHER* aes_128_wrap();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_128_wrap_pad")
		]
		public extern static CIPHER* aes_128_wrap_pad();
#if !OPENSSL_NO_OCB
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_128_ocb")
		]
		public extern static CIPHER* aes_128_ocb();
#endif
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_192_ecb")
		]
		public extern static CIPHER* aes_192_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_192_cbc")
		]
		public extern static CIPHER* aes_192_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_192_cfb1")
		]
		public extern static CIPHER* aes_192_cfb1();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_192_cfb8")
		]
		public extern static CIPHER* aes_192_cfb8();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_192_cfb128")
		]
		public extern static CIPHER* aes_192_cfb128();
		[Inline]
		public static CIPHER* aes_192_cfb() => aes_192_cfb128();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_192_ofb")
		]
		public extern static CIPHER* aes_192_ofb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_192_ctr")
		]
		public extern static CIPHER* aes_192_ctr();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_192_ccm")
		]
		public extern static CIPHER* aes_192_ccm();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_192_gcm")
		]
		public extern static CIPHER* aes_192_gcm();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_192_wrap")
		]
		public extern static CIPHER* aes_192_wrap();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_192_wrap_pad")
		]
		public extern static CIPHER* aes_192_wrap_pad();
#if !OPENSSL_NO_OCB
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_192_ocb")
		]
		public extern static CIPHER* aes_192_ocb();
#endif
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_256_ecb")
		]
		public extern static CIPHER* aes_256_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_256_cbc")
		]
		public extern static CIPHER* aes_256_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_256_cfb1")
		]
		public extern static CIPHER* aes_256_cfb1();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_256_cfb8")
		]
		public extern static CIPHER* aes_256_cfb8();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_256_cfb128")
		]
		public extern static CIPHER* aes_256_cfb128();
		[Inline]
		public static CIPHER* aes_256_cfb() => aes_256_cfb128();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_256_ofb")
		]
		public extern static CIPHER* aes_256_ofb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_256_ctr")
		]
		public extern static CIPHER* aes_256_ctr();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_256_ccm")
		]
		public extern static CIPHER* aes_256_ccm();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_256_gcm")
		]
		public extern static CIPHER* aes_256_gcm();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_256_xts")
		]
		public extern static CIPHER* aes_256_xts();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_256_wrap")
		]
		public extern static CIPHER* aes_256_wrap();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_256_wrap_pad")
		]
		public extern static CIPHER* aes_256_wrap_pad();
#if !OPENSSL_NO_OCB
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_256_ocb")
		]
		public extern static CIPHER* aes_256_ocb();
#endif
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_128_cbc_hmac_sha1")
		]
		public extern static CIPHER* aes_128_cbc_hmac_sha1();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_256_cbc_hmac_sha1")
		]
		public extern static CIPHER* aes_256_cbc_hmac_sha1();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_128_cbc_hmac_sha256")
		]
		public extern static CIPHER* aes_128_cbc_hmac_sha256();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aes_256_cbc_hmac_sha256")
		]
		public extern static CIPHER* aes_256_cbc_hmac_sha256();
#if !OPENSSL_NO_ARIA
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_128_ecb")
		]
		public extern static CIPHER* aria_128_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_128_cbc")
		]
		public extern static CIPHER* aria_128_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_128_cfb1")
		]
		public extern static CIPHER* aria_128_cfb1();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_128_cfb8")
		]
		public extern static CIPHER* aria_128_cfb8();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_128_cfb128")
		]
		public extern static CIPHER* aria_128_cfb128();
		[Inline]
		public static CIPHER* aria_128_cfb() => aria_128_cfb128();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_128_ctr")
		]
		public extern static CIPHER* aria_128_ctr();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_128_ofb")
		]
		public extern static CIPHER* aria_128_ofb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_128_gcm")
		]
		public extern static CIPHER* aria_128_gcm();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_128_ccm")
		]
		public extern static CIPHER* aria_128_ccm();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_192_ecb")
		]
		public extern static CIPHER* aria_192_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_192_cbc")
		]
		public extern static CIPHER* aria_192_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_192_cfb1")
		]
		public extern static CIPHER* aria_192_cfb1();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_192_cfb8")
		]
		public extern static CIPHER* aria_192_cfb8();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_192_cfb128")
		]
		public extern static CIPHER* aria_192_cfb128();
		[Inline]
		public static CIPHER* aria_192_cfb() => aria_192_cfb128();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_192_ctr")
		]
		public extern static CIPHER* aria_192_ctr();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_192_ofb")
		]
		public extern static CIPHER* aria_192_ofb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_192_gcm")
		]
		public extern static CIPHER* aria_192_gcm();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_192_ccm")
		]
		public extern static CIPHER* aria_192_ccm();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_256_ecb")
		]
		public extern static CIPHER* aria_256_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_256_cbc")
		]
		public extern static CIPHER* aria_256_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_256_cfb1")
		]
		public extern static CIPHER* aria_256_cfb1();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_256_cfb8")
		]
		public extern static CIPHER* aria_256_cfb8();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_256_cfb128")
		]
		public extern static CIPHER* aria_256_cfb128();
		[Inline]
		public static CIPHER* aria_256_cfb() => aria_256_cfb128();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_256_ctr")
		]
		public extern static CIPHER* aria_256_ctr();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_256_ofb")
		]
		public extern static CIPHER* aria_256_ofb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_256_gcm")
		]
		public extern static CIPHER* aria_256_gcm();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_aria_256_ccm")
		]
		public extern static CIPHER* aria_256_ccm();
#endif
#if !OPENSSL_NO_CAMELLIA
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_128_ecb")
		]
		public extern static CIPHER* camellia_128_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_128_cbc")
		]
		public extern static CIPHER* camellia_128_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_128_cfb1")
		]
		public extern static CIPHER* camellia_128_cfb1();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_128_cfb8")
		]
		public extern static CIPHER* camellia_128_cfb8();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_128_cfb128")
		]
		public extern static CIPHER* camellia_128_cfb128();
		[Inline]
		public static CIPHER* camellia_128_cfb() => camellia_128_cfb128();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_128_ofb")
		]
		public extern static CIPHER* camellia_128_ofb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_128_ctr")
		]
		public extern static CIPHER* camellia_128_ctr();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_192_ecb")
		]
		public extern static CIPHER* camellia_192_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_192_cbc")
		]
		public extern static CIPHER* camellia_192_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_192_cfb1")
		]
		public extern static CIPHER* camellia_192_cfb1();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_192_cfb8")
		]
		public extern static CIPHER* camellia_192_cfb8();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_192_cfb128")
		]
		public extern static CIPHER* camellia_192_cfb128();
		[Inline]
		public static CIPHER* camellia_192_cfb() => camellia_192_cfb128();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_192_ofb")
		]
		public extern static CIPHER* camellia_192_ofb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_192_ctr")
		]
		public extern static CIPHER* camellia_192_ctr();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_256_ecb")
		]
		public extern static CIPHER* camellia_256_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_256_cbc")
		]
		public extern static CIPHER* camellia_256_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_256_cfb1")
		]
		public extern static CIPHER* camellia_256_cfb1();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_256_cfb8")
		]
		public extern static CIPHER* camellia_256_cfb8();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_256_cfb128")
		]
		public extern static CIPHER* camellia_256_cfb128();
		[Inline]
		public static CIPHER* camellia_256_cfb() => camellia_256_cfb128();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_256_ofb")
		]
		public extern static CIPHER* camellia_256_ofb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_camellia_256_ctr")
		]
		public extern static CIPHER* camellia_256_ctr();
#endif
#if !OPENSSL_NO_CHACHA
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_chacha20")
		]
		public extern static CIPHER* chacha20();
	#if !OPENSSL_NO_POLY1305
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_chacha20_poly1305")
		]
		public extern static CIPHER* chacha20_poly1305();
	#endif
#endif

#if !OPENSSL_NO_SEED
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_seed_ecb")
		]
		public extern static CIPHER* seed_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_seed_cbc")
		]
		public extern static CIPHER* seed_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_seed_cfb128")
		]
		public extern static CIPHER* seed_cfb128();
		[Inline]
		public static CIPHER* seed_cfb() => seed_cfb128();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_seed_ofb")
		]
		public extern static CIPHER* seed_ofb();
#endif

#if !OPENSSL_NO_SM4
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sm4_ecb")
		]
		public extern static CIPHER* sm4_ecb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sm4_cbc")
		]
		public extern static CIPHER* sm4_cbc();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sm4_cfb128")
		]
		public extern static CIPHER* sm4_cfb128();
		[Inline]
		public static CIPHER* sm4_cfb() => sm4_cfb128();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sm4_ofb")
		]
		public extern static CIPHER* sm4_ofb();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_sm4_ctr")
		]
		public extern static CIPHER* sm4_ctr();
#endif
		
		[Inline, Obsolete("No longer available, no-op", true)]
		public static void cleanup() { while(false) continue; }
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_add_cipher")
		]
		public extern static int add_cipher(CIPHER* cipher);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_add_digest")
		]
		public extern static int add_digest(MD* digest);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_get_cipherbyname")
		]
		public extern static CIPHER* get_cipherbyname(char8* name);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_get_digestbyname")
		]
		public extern static MD* get_digestbyname(char8* name);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_do_all")
		]
		public extern static void CIPHER_do_all(function void(CIPHER* ciph, char8* from, char8* to, void* x) fn, void* arg);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_do_all_sorted")
		]
		public extern static void CIPHER_do_all_sorted(function void(CIPHER* ciph, char8* from, char8* to, void* x) fn, void* arg);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_do_all")
		]
		public extern static void MD_do_all(function void (MD* ciph, char8* from, char8* to, void* x) fn, void* arg);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_MD_do_all_sorted")
		]
		public extern static void MD_do_all_sorted(function void(MD* ciph, char8* from, char8* to, void* x) fn, void* arg);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_decrypt_old")
		]
		public extern static int PKEY_decrypt_old(uint8* dec_key, uint8* enc_key, int enc_key_len, PKEY* private_key);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_encrypt_old")
		]
		public extern static int PKEY_encrypt_old(uint8* enc_key, uint8* key, int key_len, PKEY* pub_key);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_type")
		]
		public extern static int PKEY_type(int type);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_id")
		]
		public extern static int PKEY_id(PKEY* pkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_base_id")
		]
		public extern static int PKEY_base_id(PKEY* pkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_bits")
		]
		public extern static int PKEY_bits(PKEY* pkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_security_bits")
		]
		public extern static int PKEY_security_bits(PKEY* pkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_size")
		]
		public extern static int PKEY_size(PKEY* pkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_set_type")
		]
		public extern static int PKEY_set_type(PKEY* pkey, int type);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_set_type_str")
		]
		public extern static int PKEY_set_type_str(PKEY* pkey, char8* str, int len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_set_alias_type")
		]
		public extern static int PKEY_set_alias_type(PKEY* pkey, int type);
#if !OPENSSL_NO_ENGINE
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_set1_engine")
		]
		public extern static int PKEY_set1_engine(PKEY* pkey, Engine.ENGINE* e);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get0_engine")
		]
		public extern static Engine.ENGINE* PKEY_get0_engine(PKEY* pkey);
#endif
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_assign")
		]
		public extern static int PKEY_assign(PKEY* pkey, int type, void* key);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get0")
		]
		public extern static void* PKEY_get0(PKEY* pkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get0_hmac")
		]
		public extern static uint8* PKEY_get0_hmac(PKEY* pkey, uint* len);
#if !OPENSSL_NO_POLY1305
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get0_poly1305")
		]
		public extern static uint8* PKEY_get0_poly1305(PKEY* pkey, uint* len);
#endif
#if !OPENSSL_NO_SIPHASH
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get0_siphash")
		]
		public extern static uint8* PKEY_get0_siphash(PKEY* pkey, uint* len);
#endif

#if !OPENSSL_NO_RSA
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_set1_RSA")
		]
		public extern static int PKEY_set1_RSA(PKEY* pkey, RSA.rsa_st* key);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get0_RSA")
		]
		public extern static RSA.rsa_st* PKEY_get0_RSA(PKEY* pkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get1_RSA")
		]
		public extern static RSA.rsa_st* PKEY_get1_RSA(PKEY* pkey);
#endif
#if !OPENSSL_NO_DSA
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_set1_DSA")
		]
		public extern static int PKEY_set1_DSA(PKEY* pkey, DSA.dsa_st* key);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get0_DSA")
		]
		public extern static DSA.dsa_st* PKEY_get0_DSA(PKEY* pkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get1_DSA")
		]
		public extern static DSA.dsa_st* PKEY_get1_DSA(PKEY* pkey);
#endif
#if !OPENSSL_NO_DH
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_set1_DH")
		]
		public extern static int PKEY_set1_DH(PKEY* pkey, DH.dh_st* key);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get0_DH")
		]
		public extern static DH.dh_st* PKEY_get0_DH(PKEY* pkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get1_DH")
		]
		public extern static DH.dh_st* PKEY_get1_DH(PKEY* pkey);
#endif
#if !OPENSSL_NO_EC
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_set1_EC_KEY")
		]
		public extern static int PKEY_set1_EC_KEY(PKEY* pkey, EC.key_st* key);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get0_EC_KEY")
		]
		public extern static EC.key_st* PKEY_get0_EC_KEY(PKEY* pkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get1_EC_KEY")
		]
		public extern static EC.key_st* PKEY_get1_EC_KEY(PKEY* pkey);
#endif
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_new")
		]
		public extern static PKEY* PKEY_new();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_up_ref")
		]
		public extern static int PKEY_up_ref(PKEY* pkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_free")
		]
		public extern static void PKEY_free(PKEY* pkey);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public extern static PKEY* d2i_PublicKey(int type, PKEY** a, uint8** pp, int length);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public extern static int i2d_PublicKey(PKEY* a, uint8** pp);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public extern static PKEY* d2i_PrivateKey(int type, PKEY** a, uint8** pp, int length);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public extern static PKEY* d2i_AutoPrivateKey(PKEY** a, uint8** pp, int length);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public extern static int i2d_PrivateKey(PKEY* a, uint8** pp);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_copy_parameters")
		]
		public extern static int PKEY_copy_parameters(PKEY* to, PKEY* from);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_missing_parameters")
		]
		public extern static int PKEY_missing_parameters(PKEY* pkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_save_parameters")
		]
		public extern static int PKEY_save_parameters(PKEY* pkey, int mode);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_cmp_parameters")
		]
		public extern static int PKEY_cmp_parameters(PKEY* a, PKEY* b);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_cmp")
		]
		public extern static int PKEY_cmp(PKEY* a, PKEY* b);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_print_public")
		]
		public extern static int PKEY_print_public(BIO.bio_st* outVal, PKEY* pkey, int indent, ASN1.PCTX* pctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_print_private")
		]
		public extern static int PKEY_print_private(BIO.bio_st* outVal, PKEY* pkey, int indent, ASN1.PCTX* pctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_print_params")
		]
		public extern static int PKEY_print_params(BIO.bio_st* outVal, PKEY* pkey, int indent, ASN1.PCTX* pctx);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get_default_digest_nid")
		]
		public extern static int PKEY_get_default_digest_nid(PKEY* pkey, int* pnid);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_set1_tls_encodedpoint")
		]
		public extern static int PKEY_set1_tls_encodedpoint(PKEY* pkey, uint8* pt, uint ptlen);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get1_tls_encodedpoint")
		]
		public extern static uint PKEY_get1_tls_encodedpoint(PKEY* pkey, uint8** ppt);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_type")
		]
		public extern static int CIPHER_type(CIPHER* ctx);

		/* calls methods */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_param_to_asn1")
		]
		public extern static int CIPHER_param_to_asn1(CIPHER_CTX* c, ASN1.TYPE* type);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_asn1_to_param")
		]
		public extern static int CIPHER_asn1_to_param(CIPHER_CTX* c, ASN1.TYPE* type);

		/* These are used by CIPHER methods */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_set_asn1_iv")
		]
		public extern static int CIPHER_set_asn1_iv(CIPHER_CTX* c, ASN1.TYPE* type);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_CIPHER_get_asn1_iv")
		]
		public extern static int CIPHER_get_asn1_iv(CIPHER_CTX* c, ASN1.TYPE* type);

#if !OPENSSL_NO_SCRYPT
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PBE_scrypt")
		]
		public extern static int PBE_scrypt(char8* pass, uint passlen, uint8* salt, uint saltlen, uint64 N, uint64 r, uint64 p, uint64 maxmem, uint8* key, uint keylen);
#endif

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PBE_CipherInit")
		]
		public extern static int PBE_CipherInit(ASN1.OBJECT* pbe_obj, char8* pass, int passlen, ASN1.TYPE* param, CIPHER_CTX* ctx, int en_de);

		/* PBE type */

		/* Can appear as the outermost AlgorithmIdentifier */
		public const int PBE_TYPE_OUTER = 0x0;
		/* Is an PRF type OID */
		public const int PBE_TYPE_PRF   = 0x1;
		/* Is a PKCS#5 v2.0 KDF */
		public const int PBE_TYPE_KDF   = 0x2;

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PBE_alg_add_type")
		]
		public extern static int PBE_alg_add_type(int pbe_type, int pbe_nid, int cipher_nid, int md_nid, PBE_KEYGEN* keygen);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PBE_alg_add")
		]
		public extern static int PBE_alg_add(int nid, CIPHER* cipher, MD* md, PBE_KEYGEN* keygen);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PBE_find")
		]
		public extern static int PBE_find(int type, int pbe_nid, int* pcnid, int* pmnid, PBE_KEYGEN** pkeygen);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PBE_cleanup")
		]
		public extern static void PBE_cleanup();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PBE_get")
		]
		public extern static int PBE_get(int* ptype, int* ppbe_nid, uint num);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_get_count")
		]
		public extern static int PKEY_asn1_get_count();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_get0")
		]
		public extern static PKEY_ASN1_METHOD* PKEY_asn1_get0(int idx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_find")
		]
		public extern static PKEY_ASN1_METHOD* PKEY_asn1_find(Engine.ENGINE** pe, int type);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_find_str")
		]
		public extern static PKEY_ASN1_METHOD* PKEY_asn1_find_str(Engine.ENGINE** pe, char8* str, int len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_add0")
		]
		public extern static int PKEY_asn1_add0(PKEY_ASN1_METHOD* ameth);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_add_alias")
		]
		public extern static int PKEY_asn1_add_alias(int to, int from);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_get0_info")
		]
		public extern static int PKEY_asn1_get0_info(int* ppkey_id, int* pkey_base_id, int* ppkey_flags, char8** pinfo, char8** ppem_str, PKEY_ASN1_METHOD* ameth);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get0_asn1")
		]
		public extern static PKEY_ASN1_METHOD* PKEY_get0_asn1(PKEY* pkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_new")
		]
		public extern static PKEY_ASN1_METHOD* PKEY_asn1_new(int id, int flags, char8* pem_str, char8* info);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_copy")
		]
		public extern static void PKEY_asn1_copy(PKEY_ASN1_METHOD* dst, PKEY_ASN1_METHOD* src);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_free")
		]
		public extern static void PKEY_asn1_free(PKEY_ASN1_METHOD* ameth);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_set_public")
		]
		public extern static void PKEY_asn1_set_public(PKEY_ASN1_METHOD* ameth, function int(PKEY* pk, X509.PUBKEY* pub) pub_decode, function int(X509.PUBKEY* pub, PKEY* pk) pub_encode,
			function int(PKEY* a, PKEY* b) pub_cmp, function int(BIO.bio_st* outVal, PKEY* pkey, int indent, ASN1.PCTX* pctx) pub_print, function int(PKEY* pk) pkey_size, function int(PKEY* pk) pkey_bits);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_set_private")
		]
		public extern static void PKEY_asn1_set_private(PKEY_ASN1_METHOD* ameth, function int(PKEY* pk, PKCS8.PRIV_KEY_INFO* p8inf) priv_decode, function int(PKCS8.PRIV_KEY_INFO* p8, PKEY* pk) priv_encode,
			function int(BIO.bio_st* outVal, PKEY* pkey, int indent, ASN1.PCTX* pctx) priv_print);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_set_param")
		]
		public extern static void PKEY_asn1_set_param(PKEY_ASN1_METHOD* ameth, function int(PKEY* pkey, uint8** pder, int derlen) param_decode, function int(PKEY* pkey, uint8** pder) param_encode,
			function int(PKEY* pk) param_missing, function int(PKEY* to, PKEY* from) param_copy, function int(PKEY* a, PKEY* b) param_cmp,
			function int(BIO.bio_st* outVal, PKEY* pkey, int indent, ASN1.PCTX* pctx) param_print);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_set_free")
		]
		public extern static void PKEY_asn1_set_free(PKEY_ASN1_METHOD* ameth, function void(PKEY* pkey) pkey_free);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_set_ctrl")
		]
		public extern static void PKEY_asn1_set_ctrl(PKEY_ASN1_METHOD* ameth, function int(PKEY* pkey, int op, int arg1, void* arg2) pkey_ctrl);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_set_item")
		]
		public extern static void PKEY_asn1_set_item(PKEY_ASN1_METHOD* ameth, function int(MD_CTX* ctx, ASN1.ITEM* it, void* asn, X509.ALGOR* a, ASN1.BIT_STRING* sig, PKEY* pkey) item_verify,
			function int(MD_CTX* ctx, ASN1.ITEM* it, void* asn, X509.ALGOR* alg1, X509.ALGOR* alg2, ASN1.BIT_STRING* sig) item_sign);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_set_siginf")
		]
		public extern static void PKEY_asn1_set_siginf(PKEY_ASN1_METHOD* ameth, function int(X509.SIG_INFO* siginf, X509.ALGOR* alg, ASN1.STRING *sig) siginf_set);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_set_check")
		]
		public extern static void PKEY_asn1_set_check(PKEY_ASN1_METHOD* ameth, function int(PKEY* pk) pkey_check);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_set_public_check")
		]
		public extern static void PKEY_asn1_set_public_check(PKEY_ASN1_METHOD* ameth, function int(PKEY* pk) pkey_pub_check);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_set_param_check")
		]
		public extern static void PKEY_asn1_set_param_check(PKEY_ASN1_METHOD* ameth, function int(PKEY* pk) pkey_param_check);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_set_set_priv_key")
		]
		public extern static void PKEY_asn1_set_set_priv_key(PKEY_ASN1_METHOD* ameth, function int(PKEY* pk, uint8* priv, uint len) set_priv_key);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_set_set_pub_key")
		]
		public extern static void PKEY_asn1_set_set_pub_key(PKEY_ASN1_METHOD* ameth, function int(PKEY* pk, uint8* pub, uint len) set_pub_key);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_set_get_priv_key")
		]
		public extern static void PKEY_asn1_set_get_priv_key(PKEY_ASN1_METHOD* ameth, function int(PKEY* pk, uint8* priv, uint* len) get_priv_key);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_set_get_pub_key")
		]
		public extern static void PKEY_asn1_set_get_pub_key(PKEY_ASN1_METHOD* ameth, function int(PKEY* pk, uint8* pub, uint* len) get_pub_key);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_asn1_set_security_bits")
		]
		public extern static void PKEY_asn1_set_security_bits(PKEY_ASN1_METHOD* ameth, function int(PKEY* pk) pkey_security_bits);

		public const int PKEY_OP_UNDEFINED     = 0;
		public const int PKEY_OP_PARAMGEN      = 1 << 1;
		public const int PKEY_OP_KEYGEN        = 1 << 2;
		public const int PKEY_OP_SIGN          = 1 << 3;
		public const int PKEY_OP_VERIFY        = 1 << 4;
		public const int PKEY_OP_VERIFYRECOVER = 1 << 5;
		public const int PKEY_OP_SIGNCTX       = 1 << 6;
		public const int PKEY_OP_VERIFYCTX     = 1 << 7;
		public const int PKEY_OP_ENCRYPT       = 1 << 8;
		public const int PKEY_OP_DECRYPT       = 1 << 9;
		public const int PKEY_OP_DERIVE        = 1 << 10;

		public const int PKEY_OP_TYPE_SIG   = PKEY_OP_SIGN | PKEY_OP_VERIFY | PKEY_OP_VERIFYRECOVER | PKEY_OP_SIGNCTX | PKEY_OP_VERIFYCTX;
		public const int PKEY_OP_TYPE_CRYPT = PKEY_OP_ENCRYPT | PKEY_OP_DECRYPT;
		public const int PKEY_OP_TYPE_NOGEN = PKEY_OP_TYPE_SIG | PKEY_OP_TYPE_CRYPT | PKEY_OP_DERIVE;
		public const int PKEY_OP_TYPE_GEN   = PKEY_OP_PARAMGEN | PKEY_OP_KEYGEN;
		
		[Inline]
		public static int PKEY_CTX_set_signature_md(PKEY_CTX* ctx, void* md) => PKEY_CTX_ctrl(ctx, -1, PKEY_OP_TYPE_SIG, PKEY_CTRL_MD, 0, md);
		[Inline]
		public static int PKEY_CTX_get_signature_md(PKEY_CTX* ctx, void* pmd) => PKEY_CTX_ctrl(ctx, -1, PKEY_OP_TYPE_SIG, PKEY_CTRL_GET_MD, 0, pmd);
		[Inline]
		public static int PKEY_CTX_set_mac_key(PKEY_CTX* ctx, void* key, int len) => PKEY_CTX_ctrl(ctx, -1, PKEY_OP_KEYGEN, PKEY_CTRL_SET_MAC_KEY, len, key);

		public const int PKEY_CTRL_MD              = 1;
		public const int PKEY_CTRL_PEER_KEY        = 2;
		
		public const int PKEY_CTRL_PKCS7_ENCRYPT   = 3;
		public const int PKEY_CTRL_PKCS7_DECRYPT   = 4;
		
		public const int PKEY_CTRL_PKCS7_SIGN      = 5;
		
		public const int PKEY_CTRL_SET_MAC_KEY     = 6;
		
		public const int PKEY_CTRL_DIGESTINIT      = 7;

		/* Used by GOST key encryption in TLS */
		public const int PKEY_CTRL_SET_IV          = 8;
		
		public const int PKEY_CTRL_CMS_ENCRYPT     = 9;
		public const int PKEY_CTRL_CMS_DECRYPT     = 10;
		public const int PKEY_CTRL_CMS_SIGN        = 11;
		
		public const int PKEY_CTRL_CIPHER          = 12;
		
		public const int PKEY_CTRL_GET_MD          = 13;
		
		public const int PKEY_CTRL_SET_DIGEST_SIZE = 14;
		
		public const int PKEY_ALG_CTRL             = 0x1000;
		
		public const int PKEY_FLAG_AUTOARGLEN      = 2;
		/*
		 * Method handles all operations: don't assume any digest related defaults.
		 */
		public const int PKEY_FLAG_SIGCTX_CUSTOM   = 4;

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_find")
		]
		public extern static PKEY_METHOD* PKEY_meth_find(int type);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_new")
		]
		public extern static PKEY_METHOD* PKEY_meth_new(int id, int flags);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get0_info")
		]
		public extern static void PKEY_meth_get0_info(int* ppkey_id, int* pflags, PKEY_METHOD* meth);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_copy")
		]
		public extern static void PKEY_meth_copy(PKEY_METHOD* dst, PKEY_METHOD* src);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_free")
		]
		public extern static void PKEY_meth_free(PKEY_METHOD* pmeth);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_add0")
		]
		public extern static int PKEY_meth_add0(PKEY_METHOD* pmeth);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_remove")
		]
		public extern static int PKEY_meth_remove(PKEY_METHOD* pmeth);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_count")
		]
		public extern static uint PKEY_meth_get_count();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get0")
		]
		public extern static PKEY_METHOD* PKEY_meth_get0(uint idx);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_new")
		]
		public extern static PKEY_CTX* PKEY_CTX_new(PKEY* pkey, Engine.ENGINE* e);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_new_id")
		]
		public extern static PKEY_CTX* PKEY_CTX_new_id(int id, Engine.ENGINE* e);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_dup")
		]
		public extern static PKEY_CTX* PKEY_CTX_dup(PKEY_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_free")
		]
		public extern static void PKEY_CTX_free(PKEY_CTX* ctx);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_ctrl")
		]
		public extern static int PKEY_CTX_ctrl(PKEY_CTX* ctx, int keytype, int optype, int cmd, int p1, void* p2);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_ctrl_str")
		]
		public extern static int PKEY_CTX_ctrl_str(PKEY_CTX* ctx, char8* type, char8* value);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_ctrl_uint64")
		]
		public extern static int PKEY_CTX_ctrl_uint64(PKEY_CTX* ctx, int keytype, int optype, int cmd, uint64 value);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_str2ctrl")
		]
		public extern static int PKEY_CTX_str2ctrl(PKEY_CTX* ctx, int cmd, char8* str);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_hex2ctrl")
		]
		public extern static int PKEY_CTX_hex2ctrl(PKEY_CTX* ctx, int cmd, char8* hex);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_md")
		]
		public extern static int PKEY_CTX_md(PKEY_CTX* ctx, int optype, int cmd, char8* md);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_get_operation")
		]
		public extern static int PKEY_CTX_get_operation(PKEY_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_set0_keygen_info")
		]
		public extern static void PKEY_CTX_set0_keygen_info(PKEY_CTX* ctx, int* dat, int datlen);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_new_mac_key")
		]
		public extern static PKEY* PKEY_new_mac_key(int type, Engine.ENGINE* e, uint8* key, int keylen);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_new_raw_private_key")
		]
		public extern static PKEY* PKEY_new_raw_private_key(int type, Engine.ENGINE* e, uint8* priv, uint len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_new_raw_public_key")
		]
		public extern static PKEY* PKEY_new_raw_public_key(int type, Engine.ENGINE* e, uint8* pub, uint len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get_raw_private_key")
		]
		public extern static int PKEY_get_raw_private_key(PKEY* pkey, uint8* priv, uint* len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get_raw_public_key")
		]
		public extern static int PKEY_get_raw_public_key(PKEY* pkey, uint8* pub, uint* len);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_new_CMAC_key")
		]
		public extern static PKEY* PKEY_new_CMAC_key(Engine.ENGINE* e, uint8* priv, uint len, CIPHER* cipher);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_set_data")
		]
		public extern static void PKEY_CTX_set_data(PKEY_CTX* ctx, void* data);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_get_data")
		]
		public extern static void* PKEY_CTX_get_data(PKEY_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_get0_pkey")
		]
		public extern static PKEY* PKEY_CTX_get0_pkey(PKEY_CTX* ctx);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_get0_peerkey")
		]
		public extern static PKEY* PKEY_CTX_get0_peerkey(PKEY_CTX* ctx);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_set_app_data")
		]
		public extern static void PKEY_CTX_set_app_data(PKEY_CTX* ctx, void* data);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_get_app_data")
		]
		public extern static void* PKEY_CTX_get_app_data(PKEY_CTX* ctx);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_sign_init")
		]
		public extern static int PKEY_sign_init(PKEY_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_sign")
		]
		public extern static int PKEY_sign(PKEY_CTX* ctx, uint8* sig, uint* siglen, uint8* tbs, uint tbslen);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_verify_init")
		]
		public extern static int PKEY_verify_init(PKEY_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_verify")
		]
		public extern static int PKEY_verify(PKEY_CTX* ctx, uint8* sig, uint siglen, uint8* tbs, uint tbslen);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_verify_recover_init")
		]
		public extern static int PKEY_verify_recover_init(PKEY_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_verify_recover")
		]
		public extern static int PKEY_verify_recover(PKEY_CTX* ctx, uint8* rout, uint* routlen, uint8* sig, uint siglen);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_encrypt_init")
		]
		public extern static int PKEY_encrypt_init(PKEY_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_encrypt")
		]
		public extern static int PKEY_encrypt(PKEY_CTX* ctx, uint8* outVal, uint* outlen, uint8* inVal, uint inlen);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_decrypt_init")
		]
		public extern static int PKEY_decrypt_init(PKEY_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_decrypt")
		]
		public extern static int PKEY_decrypt(PKEY_CTX* ctx, uint8* outVal, uint* outlen, uint8* inVal, uint inlen);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_derive_init")
		]
		public extern static int PKEY_derive_init(PKEY_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_derive_set_peer")
		]
		public extern static int PKEY_derive_set_peer(PKEY_CTX* ctx, PKEY* peer);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_derive")
		]
		public extern static int PKEY_derive(PKEY_CTX* ctx, uint8* key, uint* keylen);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_paramgen_init")
		]
		public extern static int PKEY_paramgen_init(PKEY_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_paramgen")
		]
		public extern static int PKEY_paramgen(PKEY_CTX* ctx, PKEY** ppkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_keygen_init")
		]
		public extern static int PKEY_keygen_init(PKEY_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_keygen")
		]
		public extern static int PKEY_keygen(PKEY_CTX* ctx, PKEY** ppkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_check")
		]
		public extern static int PKEY_check(PKEY_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_public_check")
		]
		public extern static int PKEY_public_check(PKEY_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_param_check")
		]
		public extern static int PKEY_param_check(PKEY_CTX* ctx);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_set_cb")
		]
		public extern static void PKEY_CTX_set_cb(PKEY_CTX* ctx, PKEY_gen_cb cb);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_get_cb")
		]
		public extern static PKEY_gen_cb PKEY_CTX_get_cb(PKEY_CTX* ctx);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_CTX_get_keygen_info")
		]
		public extern static int PKEY_CTX_get_keygen_info(PKEY_CTX* ctx, int idx);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_init")
		]
		public extern static void PKEY_meth_get_init(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx)* pinit);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_init")
		]
		public extern static void PKEY_meth_set_init(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx) init);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_copy")
		]
		public extern static void PKEY_meth_get_copy(PKEY_METHOD* pmeth, function int(PKEY_CTX* dst, PKEY_CTX* src)* pcopy);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_copy")
		]
		public extern static void PKEY_meth_set_copy(PKEY_METHOD* pmeth, function int(PKEY_CTX* dst, PKEY_CTX* src) copy);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_cleanup")
		]
		public extern static void PKEY_meth_get_cleanup(PKEY_METHOD* pmeth, function void(PKEY_CTX* ctx)* pcleanup);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_cleanup")
		]
		public extern static void PKEY_meth_set_cleanup(PKEY_METHOD* pmeth, function void(PKEY_CTX* ctx) cleanup);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_paramgen")
		]
		public extern static void PKEY_meth_get_paramgen(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx)* pparamgen_init, function int(PKEY_CTX* ctx, PKEY* pkey)* pparamgen);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_paramgen")
		]
		public extern static void PKEY_meth_set_paramgen(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx) paramgen_init, function int(PKEY_CTX* ctx, PKEY* pkey) paramgen);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_keygen")
		]
		public extern static void PKEY_meth_get_keygen(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx)* pkeygen_init, function int(PKEY_CTX* ctx, PKEY* pkey)* pkeygen);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_keygen")
		]
		public extern static void PKEY_meth_set_keygen(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx) keygen_init, function int(PKEY_CTX* ctx, PKEY* pkey) keygen);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_sign")
		]
		public extern static void PKEY_meth_get_sign(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx)* psign_init, function int(PKEY_CTX* ctx, uint8* sig, uint* siglen, uint8* tbs, uint tbslen)* psign);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_sign")
		]
		public extern static void PKEY_meth_set_sign(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx) sign_init, function int(PKEY_CTX* ctx, uint8* sig, uint* siglen, uint8* tbs, uint tbslen) sign);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_verify")
		]
		public extern static void PKEY_meth_get_verify(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx)* pverify_init, function int(PKEY_CTX* ctx, uint8* sig, uint siglen, uint8* tbs, uint tbslen)* pverify);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_verify")
		]
		public extern static void PKEY_meth_set_verify(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx) verify_init, function int(PKEY_CTX* ctx, uint8* sig, uint siglen, uint8* tbs, uint tbslen) verify);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_verify_recover")
		]
		public extern static void PKEY_meth_get_verify_recover(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx)* pverify_recover_init, function int(PKEY_CTX* ctx, uint8* sig, uint* siglen, uint8* tbs, uint tbslen)* pverify_recover);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_verify_recover")
		]
		public extern static void PKEY_meth_set_verify_recover(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx) verify_recover_init, function int(PKEY_CTX* ctx, uint8* sig, uint* siglen, uint8* tbs, uint tbslen) verify_recover);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_signctx")
		]
		public extern static void PKEY_meth_get_signctx(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx, MD_CTX* mctx)* psignctx_init, function int(PKEY_CTX* ctx, uint8* sig, uint* siglen, MD_CTX* mctx)* psignctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_signctx")
		]
		public extern static void PKEY_meth_set_signctx(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx, MD_CTX* mctx) signctx_init, function int(PKEY_CTX* ctx, uint8* sig, uint* siglen, MD_CTX* mctx) signctx);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_verifyctx")
		]
		public extern static void PKEY_meth_get_verifyctx(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx, MD_CTX* mctx)* pverifyctx_init, function int(PKEY_CTX* ctx, uint8* sig, int siglen, MD_CTX* mctx)* pverifyctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_verifyctx")
		]
		public extern static void PKEY_meth_set_verifyctx(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx, MD_CTX* mctx) verifyctx_init, function int(PKEY_CTX* ctx, uint8* sig, int siglen, MD_CTX* mctx) verifyctx);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_encrypt")
		]
		public extern static void PKEY_meth_get_encrypt(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx)* pencrypt_init, function int(PKEY_CTX* ctx, uint8* outVal, uint* outlen, uint8* inVal, uint inlen)* pencryptfn);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_encrypt")
		]
		public extern static void PKEY_meth_set_encrypt(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx) encrypt_init, function int(PKEY_CTX* ctx, uint8* outVal, uint* outlen, uint8* inVal, uint inlen) encryptfn);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_decrypt")
		]
		public extern static void PKEY_meth_get_decrypt(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx)* pdecrypt_init, function int(PKEY_CTX* ctx, uint8* outVal, uint* outlen, uint8* inVal, uint inlen)* pdecrypt);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_decrypt")
		]
		public extern static void PKEY_meth_set_decrypt(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx) decrypt_init, function int(PKEY_CTX* ctx, uint8* outVal, uint* outlen, uint8* inVal, uint inlen) decrypt);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_derive")
		]
		public extern static void PKEY_meth_get_derive(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx)* pderive_init, function int(PKEY_CTX* ctx, uint8* key, uint* keylen)* pderive);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_derive")
		]
		public extern static void PKEY_meth_set_derive(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx) derive_init, function int(PKEY_CTX* ctx, uint8* key, uint* keylen) derive);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_ctrl")
		]
		public extern static void PKEY_meth_get_ctrl(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx, int type, int p1, void* p2)* pctrl, function int(PKEY_CTX* ctx, char8* type, char8* value)* pctrl_str);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_ctrl")
		]
		public extern static void PKEY_meth_set_ctrl(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx, int type, int p1, void* p2) ctrl, function int(PKEY_CTX* ctx, char8* type, char8* value) ctrl_str);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_digestsign")
		]
		public extern static void PKEY_meth_get_digestsign(PKEY_METHOD* pmeth, function int(MD_CTX* ctx, uint8* sig, uint* siglen, uint8* tbs, uint tbslen)* digestsign);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_digestsign")
		]
		public extern static void PKEY_meth_set_digestsign(PKEY_METHOD* pmeth, function int(MD_CTX* ctx, uint8* sig, uint* siglen, uint8* tbs, uint tbslen) digestsign);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_digestverify")
		]
		public extern static void PKEY_meth_get_digestverify(PKEY_METHOD* pmeth, function int(MD_CTX* ctx, uint8* sig, uint siglen, uint8* tbs, uint tbslen)* digestverify);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_digestverify")
		]
		public extern static void PKEY_meth_set_digestverify(PKEY_METHOD* pmeth, function int(MD_CTX* ctx, uint8* sig, uint siglen, uint8* tbs, uint tbslen) digestverify);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_check")
		]
		public extern static void PKEY_meth_get_check(PKEY_METHOD* pmeth, function int(PKEY* pkey)* pcheck);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_check")
		]
		public extern static void PKEY_meth_set_check(PKEY_METHOD* pmeth, function int(PKEY* pkey) check);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_public_check")
		]
		public extern static void PKEY_meth_get_public_check(PKEY_METHOD* pmeth, function int(PKEY* pkey)* pcheck);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_public_check")
		]
		public extern static void PKEY_meth_set_public_check(PKEY_METHOD* pmeth, function int(PKEY* pkey) check);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_param_check")
		]
		public extern static void PKEY_meth_get_param_check(PKEY_METHOD* pmeth, function int(PKEY* pkey)* pcheck);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_param_check")
		]
		public extern static void PKEY_meth_set_param_check(PKEY_METHOD* pmeth, function int(PKEY* pkey) check);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_get_digest_custom")
		]
		public extern static void PKEY_meth_get_digest_custom(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx, MD_CTX* mctx)* pdigest_custom);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_meth_set_digest_custom")
		]
		public extern static void PKEY_meth_set_digest_custom(PKEY_METHOD* pmeth, function int(PKEY_CTX* ctx, MD_CTX* mctx) digest_custom);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_add_alg_module")
		]
		public extern static void add_alg_module();

		public const int PKEY_CTRL_TLS_MD                   = PKEY_ALG_CTRL;
		public const int PKEY_CTRL_TLS_SECRET               = PKEY_ALG_CTRL + 1;
		public const int PKEY_CTRL_TLS_SEED                 = PKEY_ALG_CTRL + 2;
		public const int PKEY_CTRL_HKDF_MD                  = PKEY_ALG_CTRL + 3;
		public const int PKEY_CTRL_HKDF_SALT                = PKEY_ALG_CTRL + 4;
		public const int PKEY_CTRL_HKDF_KEY                 = PKEY_ALG_CTRL + 5;
		public const int PKEY_CTRL_HKDF_INFO                = PKEY_ALG_CTRL + 6;
		public const int PKEY_CTRL_HKDF_MODE                = PKEY_ALG_CTRL + 7;
		public const int PKEY_CTRL_PASS                     = PKEY_ALG_CTRL + 8;
		public const int PKEY_CTRL_SCRYPT_SALT              = PKEY_ALG_CTRL + 9;
		public const int PKEY_CTRL_SCRYPT_N                 = PKEY_ALG_CTRL + 10;
		public const int PKEY_CTRL_SCRYPT_R                 = PKEY_ALG_CTRL + 11;
		public const int PKEY_CTRL_SCRYPT_P                 = PKEY_ALG_CTRL + 12;
		public const int PKEY_CTRL_SCRYPT_MAXMEM_BYTES      = PKEY_ALG_CTRL + 13;
		
		public const int PKEY_HKDEF_MODE_EXTRACT_AND_EXPAND = 0;
		public const int PKEY_HKDEF_MODE_EXTRACT_ONLY       = 1;
		public const int PKEY_HKDEF_MODE_EXPAND_ONLY        = 2;
		
		[Inline]
		public static int PKEY_CTX_set_tls1_prf_md(PKEY_CTX* pctx, void* md) => PKEY_CTX_ctrl(pctx, -1, PKEY_OP_DERIVE, PKEY_CTRL_TLS_MD, 0, md);
		[Inline]
		public static int PKEY_CTX_set1_tls1_prf_secret(PKEY_CTX* pctx, void* sec, int seclen) => PKEY_CTX_ctrl(pctx, -1, PKEY_OP_DERIVE, PKEY_CTRL_TLS_SECRET, seclen, sec);
		[Inline]
		public static int PKEY_CTX_add1_tls1_prf_seed(PKEY_CTX* pctx, void* seed, int seedlen) => PKEY_CTX_ctrl(pctx, -1, PKEY_OP_DERIVE, PKEY_CTRL_TLS_SEED, seedlen, seed);
		[Inline]
		public static int PKEY_CTX_set_hkdf_md(PKEY_CTX* pctx, void* md) => PKEY_CTX_ctrl(pctx, -1, PKEY_OP_DERIVE, PKEY_CTRL_HKDF_MD, 0, md);
		[Inline]
		public static int PKEY_CTX_set1_hkdf_salt(PKEY_CTX* pctx, void* salt, int saltlen) => PKEY_CTX_ctrl(pctx, -1, PKEY_OP_DERIVE, PKEY_CTRL_HKDF_SALT, saltlen, salt);
		[Inline]
		public static int PKEY_CTX_set1_hkdf_key(PKEY_CTX* pctx, void* key, int keylen) => PKEY_CTX_ctrl(pctx, -1, PKEY_OP_DERIVE, PKEY_CTRL_HKDF_KEY, keylen, key);
		[Inline]
		public static int PKEY_CTX_add1_hkdf_info(PKEY_CTX* pctx, void* info, int infolen) => PKEY_CTX_ctrl(pctx, -1, PKEY_OP_DERIVE, PKEY_CTRL_HKDF_INFO, infolen, info);
		[Inline]
		public static int PKEY_CTX_hkdf_mode(PKEY_CTX* pctx, int mode) => PKEY_CTX_ctrl(pctx, -1, PKEY_OP_DERIVE, PKEY_CTRL_HKDF_MODE, mode, null);
		[Inline]
		public static int PKEY_CTX_set1_pbe_pass(PKEY_CTX* pctx, void* pass, int passlen) => PKEY_CTX_ctrl(pctx, -1, PKEY_OP_DERIVE, PKEY_CTRL_PASS, passlen, pass);
		[Inline]
		public static int PKEY_CTX_set1_scrypt_salt(PKEY_CTX* pctx, void* salt, int saltlen) => PKEY_CTX_ctrl(pctx, -1, PKEY_OP_DERIVE, PKEY_CTRL_SCRYPT_SALT, saltlen, salt);
		[Inline]
		public static int PKEY_CTX_set_scrypt_N(PKEY_CTX* pctx, uint64 n) => PKEY_CTX_ctrl_uint64(pctx, -1, PKEY_OP_DERIVE, PKEY_CTRL_SCRYPT_N, n);
		[Inline]
		public static int PKEY_CTX_set_scrypt_r(PKEY_CTX* pctx, uint64 r) => PKEY_CTX_ctrl_uint64(pctx, -1, PKEY_OP_DERIVE, PKEY_CTRL_SCRYPT_R, r);
		[Inline]
		public static int PKEY_CTX_set_scrypt_p(PKEY_CTX* pctx, uint64 p) => PKEY_CTX_ctrl_uint64(pctx, -1, PKEY_OP_DERIVE, PKEY_CTRL_SCRYPT_P, p);
		[Inline]
		public static int PKEY_CTX_set_scrypt_maxmem_bytes(PKEY_CTX* pctx, uint64 maxmem_bytes) => PKEY_CTX_ctrl_uint64(pctx, -1, PKEY_OP_DERIVE, PKEY_CTRL_SCRYPT_MAXMEM_BYTES, maxmem_bytes);

#if !OPENSSL_NO_DH
		[Inline]
		public static int PKEY_CTX_set_dh_paramgen_prime_len(PKEY_CTX* ctx, int len) => PKEY_CTX_ctrl(ctx, PKEY_DH, PKEY_OP_PARAMGEN, PKEY_CTRL_DH_PARAMGEN_PRIME_LEN, len, null);
		[Inline]
		public static int PKEY_CTX_set_dh_paramgen_subprime_len(PKEY_CTX* ctx, int len) => PKEY_CTX_ctrl(ctx, PKEY_DH, PKEY_OP_PARAMGEN, PKEY_CTRL_DH_PARAMGEN_SUBPRIME_LEN, len, null);
		[Inline]
		public static int PKEY_CTX_set_dh_paramgen_type(PKEY_CTX* ctx, int typ) => PKEY_CTX_ctrl(ctx, PKEY_DH, PKEY_OP_PARAMGEN, PKEY_CTRL_DH_PARAMGEN_TYPE, typ, null);
		[Inline]
		public static int PKEY_CTX_set_dh_paramgen_generator(PKEY_CTX* ctx, int gen) => PKEY_CTX_ctrl(ctx, PKEY_DH, PKEY_OP_PARAMGEN, PKEY_CTRL_DH_PARAMGEN_GENERATOR, gen, null);
		[Inline]
		public static int PKEY_CTX_set_dh_rfc5114(PKEY_CTX* ctx, int gen) => PKEY_CTX_ctrl(ctx, PKEY_DHX, PKEY_OP_PARAMGEN, PKEY_CTRL_DH_RFC5114, gen, null);
		[Inline]
		public static int PKEY_CTX_set_dhx_rfc5114(PKEY_CTX* ctx, int gen) => PKEY_CTX_ctrl(ctx, PKEY_DHX, PKEY_OP_PARAMGEN, PKEY_CTRL_DH_RFC5114, gen, null);
		[Inline]
		public static int PKEY_CTX_set_dh_nid(PKEY_CTX* ctx, int nid) => PKEY_CTX_ctrl(ctx, PKEY_DH, PKEY_OP_PARAMGEN | PKEY_OP_KEYGEN, PKEY_CTRL_DH_NID, nid, null);
		[Inline]
		public static int PKEY_CTX_set_dh_pad(PKEY_CTX* ctx, int pad) => PKEY_CTX_ctrl(ctx, PKEY_DH, PKEY_OP_DERIVE, PKEY_CTRL_DH_PAD, pad, null);
		[Inline]
		public static int PKEY_CTX_set_dh_kdf_type(PKEY_CTX* ctx, int kdf) => PKEY_CTX_ctrl(ctx, PKEY_DHX, PKEY_OP_DERIVE, PKEY_CTRL_DH_KDF_TYPE, kdf, null);
		[Inline]
		public static int PKEY_CTX_get_dh_kdf_type(PKEY_CTX* ctx) => PKEY_CTX_ctrl(ctx, PKEY_DHX, PKEY_OP_DERIVE, PKEY_CTRL_DH_KDF_TYPE, -2, null);
		[Inline]
		public static int PKEY_CTX_set0_dh_kdf_oid(PKEY_CTX* ctx, int32[] oid) => PKEY_CTX_ctrl(ctx, PKEY_DHX, PKEY_OP_DERIVE, PKEY_CTRL_DH_KDF_OID, 0, &oid[0]);
		[Inline]
		public static int PKEY_CTX_get0_dh_kdf_oid(PKEY_CTX* ctx, int32* poid) => PKEY_CTX_ctrl(ctx, PKEY_DHX, PKEY_OP_DERIVE, PKEY_CTRL_GET_DH_KDF_OID, 0, poid);
		[Inline]
		public static int PKEY_CTX_set_dh_kdf_md(PKEY_CTX* ctx, void* md) => PKEY_CTX_ctrl(ctx, PKEY_DHX, PKEY_OP_DERIVE, PKEY_CTRL_DH_KDF_MD, 0, md);
		[Inline]
		public static int PKEY_CTX_get_dh_kdf_md(PKEY_CTX* ctx, void* pmd) => PKEY_CTX_ctrl(ctx, PKEY_DHX, PKEY_OP_DERIVE, PKEY_CTRL_GET_DH_KDF_MD, 0, pmd);
		[Inline]
		public static int PKEY_CTX_set_dh_kdf_outlen(PKEY_CTX* ctx, int len) => PKEY_CTX_ctrl(ctx, PKEY_DHX, PKEY_OP_DERIVE, PKEY_CTRL_DH_KDF_OUTLEN, len, null);
		[Inline]
		public static int PKEY_CTX_get_dh_kdf_outlen(PKEY_CTX* ctx, int* plen) => PKEY_CTX_ctrl(ctx, PKEY_DHX, PKEY_OP_DERIVE, PKEY_CTRL_GET_DH_KDF_OUTLEN, 0, plen);
		[Inline]
		public static int PKEY_CTX_set0_dh_kdf_ukm(PKEY_CTX* ctx, void* p, int plen) => PKEY_CTX_ctrl(ctx, PKEY_DHX, PKEY_OP_DERIVE, PKEY_CTRL_DH_KDF_UKM, plen, p);
		[Inline]
		public static int PKEY_CTX_get0_dh_kdf_ukm(PKEY_CTX* ctx, void* p) => PKEY_CTX_ctrl(ctx, PKEY_DHX, PKEY_OP_DERIVE, PKEY_CTRL_GET_DH_KDF_UKM, 0, p);
		
		public const int PKEY_CTRL_DH_PARAMGEN_PRIME_LEN    = PKEY_ALG_CTRL + 1;
		public const int PKEY_CTRL_DH_PARAMGEN_GENERATOR    = PKEY_ALG_CTRL + 2;
		public const int PKEY_CTRL_DH_RFC5114               = PKEY_ALG_CTRL + 3;
		public const int PKEY_CTRL_DH_PARAMGEN_SUBPRIME_LEN = PKEY_ALG_CTRL + 4;
		public const int PKEY_CTRL_DH_PARAMGEN_TYPE         = PKEY_ALG_CTRL + 5;
		public const int PKEY_CTRL_DH_KDF_TYPE              = PKEY_ALG_CTRL + 6;
		public const int PKEY_CTRL_DH_KDF_MD                = PKEY_ALG_CTRL + 7;
		public const int PKEY_CTRL_GET_DH_KDF_MD            = PKEY_ALG_CTRL + 8;
		public const int PKEY_CTRL_DH_KDF_OUTLEN            = PKEY_ALG_CTRL + 9;
		public const int PKEY_CTRL_GET_DH_KDF_OUTLEN        = PKEY_ALG_CTRL + 10;
		public const int PKEY_CTRL_DH_KDF_UKM               = PKEY_ALG_CTRL + 11;
		public const int PKEY_CTRL_GET_DH_KDF_UKM           = PKEY_ALG_CTRL + 12;
		public const int PKEY_CTRL_DH_KDF_OID               = PKEY_ALG_CTRL + 13;
		public const int PKEY_CTRL_GET_DH_KDF_OID           = PKEY_ALG_CTRL + 14;
		public const int PKEY_CTRL_DH_NID                   = PKEY_ALG_CTRL + 15;
		public const int PKEY_CTRL_DH_PAD                   = PKEY_ALG_CTRL + 16;

		/* KDF types */
		public const int PKEY_DH_KDF_NONE  = 1;
	#if !OPENSSL_NO_CMS
		public const int PKEY_DH_KDF_X9_42 = 2;
	#endif
#endif

#if !OPENSSL_NO_DSA
		[Inline]
		public static int PKEY_CTX_set_dsa_paramgen_bits(PKEY_CTX* ctx, int nbits) => PKEY_CTX_ctrl(ctx, PKEY_DSA, PKEY_OP_PARAMGEN, PKEY_CTRL_DSA_PARAMGEN_BITS, nbits, null);
		[Inline]
		public static int PKEY_CTX_set_dsa_paramgen_q_bits(PKEY_CTX* ctx, int qbits) => PKEY_CTX_ctrl(ctx, PKEY_DSA, PKEY_OP_PARAMGEN, PKEY_CTRL_DSA_PARAMGEN_Q_BITS, qbits, null);
		[Inline]
		public static int PKEY_CTX_set_dsa_paramgen_md(PKEY_CTX* ctx, void* md) => PKEY_CTX_ctrl(ctx, PKEY_DSA, PKEY_OP_PARAMGEN, PKEY_CTRL_DSA_PARAMGEN_MD, 0, md);

		public const int PKEY_CTRL_DSA_PARAMGEN_BITS   = PKEY_ALG_CTRL + 1;
		public const int PKEY_CTRL_DSA_PARAMGEN_Q_BITS = PKEY_ALG_CTRL + 2;
		public const int PKEY_CTRL_DSA_PARAMGEN_MD     = PKEY_ALG_CTRL + 3;
#endif
		
#if !OPENSSL_NO_EC
		[Inline]
		public static int PKEY_CTX_set_ec_paramgen_curve_nid(PKEY_CTX* ctx, int nid) => PKEY_CTX_ctrl(ctx, PKEY_EC, PKEY_OP_PARAMGEN | PKEY_OP_KEYGEN, PKEY_CTRL_EC_PARAMGEN_CURVE_NID, nid, null);
		[Inline]
		public static int PKEY_CTX_set_ec_param_enc(PKEY_CTX* ctx, int flag) => PKEY_CTX_ctrl(ctx, PKEY_EC, PKEY_OP_PARAMGEN | PKEY_OP_KEYGEN, PKEY_CTRL_EC_PARAM_ENC, flag, null);
		[Inline]
		public static int PKEY_CTX_set_ecdh_cofactor_mode(PKEY_CTX* ctx, int flag) => PKEY_CTX_ctrl(ctx, PKEY_EC, PKEY_OP_DERIVE, PKEY_CTRL_EC_ECDH_COFACTOR, flag, null);
		[Inline]
		public static int PKEY_CTX_get_ecdh_cofactor_mode(PKEY_CTX* ctx) => PKEY_CTX_ctrl(ctx, PKEY_EC, PKEY_OP_DERIVE, PKEY_CTRL_EC_ECDH_COFACTOR, -2, null);
		[Inline]
		public static int PKEY_CTX_set_ecdh_kdf_type(PKEY_CTX* ctx, int kdf) => PKEY_CTX_ctrl(ctx, PKEY_EC, PKEY_OP_DERIVE, PKEY_CTRL_EC_KDF_TYPE, kdf, null);
		[Inline]
		public static int PKEY_CTX_get_ecdh_kdf_type(PKEY_CTX* ctx) => PKEY_CTX_ctrl(ctx, PKEY_EC, PKEY_OP_DERIVE, PKEY_CTRL_EC_KDF_TYPE, -2, null);
		[Inline]
		public static int PKEY_CTX_set_ecdh_kdf_md(PKEY_CTX* ctx, void* md) => PKEY_CTX_ctrl(ctx, PKEY_EC, PKEY_OP_DERIVE, PKEY_CTRL_EC_KDF_MD, 0, md);
		[Inline]
		public static int PKEY_CTX_get_ecdh_kdf_md(PKEY_CTX* ctx, void* pmd) => PKEY_CTX_ctrl(ctx, PKEY_EC, PKEY_OP_DERIVE, PKEY_CTRL_GET_EC_KDF_MD, 0, pmd);
		[Inline]
		public static int PKEY_CTX_set_ecdh_kdf_outlen(PKEY_CTX* ctx, int len) => PKEY_CTX_ctrl(ctx, PKEY_EC, PKEY_OP_DERIVE, PKEY_CTRL_EC_KDF_OUTLEN, len, null);
		[Inline]
		public static int PKEY_CTX_get_ecdh_kdf_outlen(PKEY_CTX* ctx, void* plen) => PKEY_CTX_ctrl(ctx, PKEY_EC, PKEY_OP_DERIVE, PKEY_CTRL_GET_EC_KDF_OUTLEN, 0, plen);
		[Inline]
		public static int PKEY_CTX_set0_ecdh_kdf_ukm(PKEY_CTX* ctx, void* p, int plen) => PKEY_CTX_ctrl(ctx, PKEY_EC, PKEY_OP_DERIVE, PKEY_CTRL_EC_KDF_UKM, plen, p);
		[Inline]
		public static int PKEY_CTX_get0_ecdh_kdf_ukm(PKEY_CTX* ctx, void* p) => PKEY_CTX_ctrl(ctx, PKEY_EC, PKEY_OP_DERIVE, PKEY_CTRL_GET_EC_KDF_UKM, 0, p);

		/* SM2 will skip the operation check so no need to pass operation here */
		[Inline]
		public static int PKEY_CTX_set1_id(PKEY_CTX* ctx, void* id, int id_len) => PKEY_CTX_ctrl(ctx, -1, -1, PKEY_CTRL_SET1_ID, id_len, id);
		[Inline]
		public static int PKEY_CTX_get1_id(PKEY_CTX* ctx, void* id) => PKEY_CTX_ctrl(ctx, -1, -1, PKEY_CTRL_GET1_ID, 0, id);
		[Inline]
		public static int PKEY_CTX_get1_id_len(PKEY_CTX* ctx, void* id_len) => PKEY_CTX_ctrl(ctx, -1, -1, PKEY_CTRL_GET1_ID_LEN, 0, id_len);

		public const int PKEY_CTRL_EC_PARAMGEN_CURVE_NID = PKEY_ALG_CTRL + 1;
		public const int PKEY_CTRL_EC_PARAM_ENC          = PKEY_ALG_CTRL + 2;
		public const int PKEY_CTRL_EC_ECDH_COFACTOR      = PKEY_ALG_CTRL + 3;
		public const int PKEY_CTRL_EC_KDF_TYPE           = PKEY_ALG_CTRL + 4;
		public const int PKEY_CTRL_EC_KDF_MD             = PKEY_ALG_CTRL + 5;
		public const int PKEY_CTRL_GET_EC_KDF_MD         = PKEY_ALG_CTRL + 6;
		public const int PKEY_CTRL_EC_KDF_OUTLEN         = PKEY_ALG_CTRL + 7;
		public const int PKEY_CTRL_GET_EC_KDF_OUTLEN     = PKEY_ALG_CTRL + 8;
		public const int PKEY_CTRL_EC_KDF_UKM            = PKEY_ALG_CTRL + 9;
		public const int PKEY_CTRL_GET_EC_KDF_UKM        = PKEY_ALG_CTRL + 10;
		public const int PKEY_CTRL_SET1_ID               = PKEY_ALG_CTRL + 11;
		public const int PKEY_CTRL_GET1_ID               = PKEY_ALG_CTRL + 12;
		public const int PKEY_CTRL_GET1_ID_LEN           = PKEY_ALG_CTRL + 13;
		/* KDF types */
		public const int PKEY_ECDH_KDF_NONE              = 1;
		public const int PKEY_ECDH_KDF_X9_63             = 2;
		/*
		 * The old name for EVP_PKEY_ECDH_KDF_X9_63 The ECDH KDF specification has been mistakingly attributed to ANSI X9.62, it is actually specified in ANSI X9.63.
		 * This identifier is retained for backwards compatibility
		 */
		public const int PKEY_ECDH_KDF_X9_62             = PKEY_ECDH_KDF_X9_63;
#endif

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get_attr_count")
		]
		public extern static int PKEY_get_attr_count(PKEY* key);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get_attr_by_NID")
		]
		public extern static int PKEY_get_attr_by_NID(PKEY* key, int nid, int lastpos);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get_attr_by_OBJ")
		]
		public extern static int PKEY_get_attr_by_OBJ(PKEY* key, ASN1.OBJECT* obj, int lastpos);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_get_attr")
		]
		public extern static X509.ATTRIBUTE* PKEY_get_attr(PKEY* key, int loc);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_delete_attr")
		]
		public extern static X509.ATTRIBUTE* PKEY_delete_attr(PKEY* key, int loc);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_add1_attr")
		]
		public extern static int PKEY_add1_attr(PKEY* key, X509.ATTRIBUTE* attr);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_add1_attr_by_OBJ")
		]
		public extern static int PKEY_add1_attr_by_OBJ(PKEY* key, ASN1.OBJECT* obj, int type, uint8* bytes, int len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_add1_attr_by_NID")
		]
		public extern static int PKEY_add1_attr_by_NID(PKEY* key, int nid, int type, uint8* bytes, int len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY_add1_attr_by_txt")
		]
		public extern static int PKEY_add1_attr_by_txt(PKEY* key, char8* attrname, int type, uint8* bytes, int len);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKCS82PKEY")
		]
		public extern static PKEY* PKCS82PKEY(PKCS8.PRIV_KEY_INFO* p8);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EVP_PKEY2PKCS8")
		]
		public extern static PKCS8.PRIV_KEY_INFO* PKEY2PKCS8(PKEY* pkey);
		
#if !OPENSSL_NO_RSA
		[Inline]
		public static int PKEY_CTX_set_rsa_padding(PKEY_CTX* ctx, int pad) => RSA.pkey_ctx_ctrl(ctx, -1, PKEY_CTRL_RSA_PADDING, pad, null);
		[Inline]
		public static int PKEY_CTX_get_rsa_padding(PKEY_CTX* ctx, void* ppad) => RSA.pkey_ctx_ctrl(ctx, -1, PKEY_CTRL_GET_RSA_PADDING, 0, ppad);
		[Inline]
		public static int PKEY_CTX_set_rsa_pss_saltlen(PKEY_CTX* ctx, int len) => RSA.pkey_ctx_ctrl(ctx, PKEY_OP_SIGN | PKEY_OP_VERIFY, PKEY_CTRL_RSA_PSS_SALTLEN, len, null);
		[Inline]
		public static int PKEY_CTX_set_rsa_pss_keygen_saltlen(PKEY_CTX* ctx, int len) => PKEY_CTX_ctrl(ctx, PKEY_RSA_PSS, PKEY_OP_KEYGEN, PKEY_CTRL_RSA_PSS_SALTLEN, len, null);
		[Inline]
		public static int PKEY_CTX_get_rsa_pss_saltlen(PKEY_CTX* ctx, void* plen) => RSA.pkey_ctx_ctrl(ctx, PKEY_OP_SIGN | PKEY_OP_VERIFY, PKEY_CTRL_GET_RSA_PSS_SALTLEN, 0, plen);
		[Inline]
		public static int PKEY_CTX_set_rsa_keygen_bits(PKEY_CTX* ctx, int bits) => RSA.pkey_ctx_ctrl(ctx, PKEY_OP_KEYGEN, PKEY_CTRL_RSA_KEYGEN_BITS, bits, null);
		[Inline]
		public static int PKEY_CTX_set_rsa_keygen_pubexp(PKEY_CTX* ctx, void* pubexp) => RSA.pkey_ctx_ctrl(ctx, PKEY_OP_KEYGEN, PKEY_CTRL_RSA_KEYGEN_PUBEXP, 0, pubexp);
		[Inline]
		public static int PKEY_CTX_set_rsa_keygen_primes(PKEY_CTX* ctx, int primes) => RSA.pkey_ctx_ctrl(ctx, PKEY_OP_KEYGEN, PKEY_CTRL_RSA_KEYGEN_PRIMES, primes, null);
		[Inline]
		public static int PKEY_CTX_set_rsa_mgf1_md(PKEY_CTX* ctx, void* md) => RSA.pkey_ctx_ctrl(ctx, PKEY_OP_TYPE_SIG | PKEY_OP_TYPE_CRYPT, PKEY_CTRL_RSA_MGF1_MD, 0, md);
		[Inline]
		public static int PKEY_CTX_set_rsa_pss_keygen_mgf1_md(PKEY_CTX* ctx, void* md) => PKEY_CTX_ctrl(ctx, PKEY_RSA_PSS, PKEY_OP_KEYGEN, PKEY_CTRL_RSA_MGF1_MD, 0, md);
		[Inline]
		public static int PKEY_CTX_set_rsa_oaep_md(PKEY_CTX* ctx, void* md) => PKEY_CTX_ctrl(ctx, PKEY_RSA, PKEY_OP_TYPE_CRYPT, PKEY_CTRL_RSA_OAEP_MD, 0, md);
		[Inline]
		public static int PKEY_CTX_get_rsa_mgf1_md(PKEY_CTX* ctx, void* pmd) => RSA.pkey_ctx_ctrl(ctx, PKEY_OP_TYPE_SIG | PKEY_OP_TYPE_CRYPT, PKEY_CTRL_GET_RSA_MGF1_MD, 0, pmd);
		[Inline]
		public static int PKEY_CTX_get_rsa_oaep_md(PKEY_CTX* ctx, void* pmd) => PKEY_CTX_ctrl(ctx, PKEY_RSA, PKEY_OP_TYPE_CRYPT, PKEY_CTRL_GET_RSA_OAEP_MD, 0, pmd);
		[Inline]
		public static int PKEY_CTX_set0_rsa_oaep_label(PKEY_CTX* ctx, void* l, int llen) => PKEY_CTX_ctrl(ctx, PKEY_RSA, PKEY_OP_TYPE_CRYPT, PKEY_CTRL_RSA_OAEP_LABEL, llen, l);
		[Inline]
		public static int PKEY_CTX_get0_rsa_oaep_label(PKEY_CTX* ctx, void* l) => PKEY_CTX_ctrl(ctx, PKEY_RSA, PKEY_OP_TYPE_CRYPT, PKEY_CTRL_GET_RSA_OAEP_LABEL, 0, l);
		[Inline]
		public static int PKEY_CTX_set_rsa_pss_keygen_md(PKEY_CTX* ctx, void* md) => PKEY_CTX_ctrl(ctx, PKEY_RSA_PSS, PKEY_OP_KEYGEN, PKEY_CTRL_MD, 0, md);

		public const int PKEY_CTRL_RSA_PADDING         = PKEY_ALG_CTRL + 1;
		public const int PKEY_CTRL_RSA_PSS_SALTLEN     = PKEY_ALG_CTRL + 2;

		public const int PKEY_CTRL_RSA_KEYGEN_BITS     = PKEY_ALG_CTRL + 3;
		public const int PKEY_CTRL_RSA_KEYGEN_PUBEXP   = PKEY_ALG_CTRL + 4;
		public const int PKEY_CTRL_RSA_MGF1_MD         = PKEY_ALG_CTRL + 5;

		public const int PKEY_CTRL_GET_RSA_PADDING     = PKEY_ALG_CTRL + 6;
		public const int PKEY_CTRL_GET_RSA_PSS_SALTLEN = PKEY_ALG_CTRL + 7;
		public const int PKEY_CTRL_GET_RSA_MGF1_MD     = PKEY_ALG_CTRL + 8;

		public const int PKEY_CTRL_RSA_OAEP_MD         = PKEY_ALG_CTRL + 9;
		public const int PKEY_CTRL_RSA_OAEP_LABEL      = PKEY_ALG_CTRL + 10;

		public const int PKEY_CTRL_GET_RSA_OAEP_MD     = PKEY_ALG_CTRL + 11;
		public const int PKEY_CTRL_GET_RSA_OAEP_LABEL  = PKEY_ALG_CTRL + 12;

		public const int PKEY_CTRL_RSA_KEYGEN_PRIMES   = PKEY_ALG_CTRL + 13;
#endif
	}
}
