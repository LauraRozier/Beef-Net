/*
* Generated by util/mkerr.pl DO NOT EDIT
* Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.
*
* Licensed under the OpenSSL license (the "License").  You may not use
* this file except in compliance with the License.  You can obtain a copy
* in the file LICENSE in the source distribution or at
* https://www.openssl.org/source/license.html
*/
using System;

namespace Beef_Net.OpenSSL
{
	[AlwaysInclude]
	sealed abstract class EC
	{
#if !OPENSSL_NO_EC
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public extern static int ERR_load_EC_strings();
		
		/*
		 * EC function codes.
		 */
		public const int F_BN_TO_FELEM                                  = 224;
		public const int F_D2I_ECPARAMETERS                             = 144;
		public const int F_D2I_ECPKPARAMETERS                           = 145;
		public const int F_D2I_ECPRIVATEKEY                             = 146;
		public const int F_DO_EC_KEY_PRINT                              = 221;
		public const int F_ECDH_CMS_DECRYPT                             = 238;
		public const int F_ECDH_CMS_SET_SHARED_INFO                     = 239;
		public const int F_ECDH_COMPUTE_KEY                             = 246;
		public const int F_ECDH_SIMPLE_COMPUTE_KEY                      = 257;
		public const int F_ECDSA_DO_SIGN_EX                             = 251;
		public const int F_ECDSA_DO_VERIFY                              = 252;
		public const int F_ECDSA_SIGN_EX                                = 254;
		public const int F_ECDSA_SIGN_SETUP                             = 248;
		public const int F_ECDSA_SIG_NEW                                = 265;
		public const int F_ECDSA_VERIFY                                 = 253;
		public const int F_ECD_ITEM_VERIFY                              = 270;
		public const int F_ECKEY_PARAM2TYPE                             = 223;
		public const int F_ECKEY_PARAM_DECODE                           = 212;
		public const int F_ECKEY_PRIV_DECODE                            = 213;
		public const int F_ECKEY_PRIV_ENCODE                            = 214;
		public const int F_ECKEY_PUB_DECODE                             = 215;
		public const int F_ECKEY_PUB_ENCODE                             = 216;
		public const int F_ECKEY_TYPE2PARAM                             = 220;
		public const int F_ECPARAMETERS_PRINT                           = 147;
		public const int F_ECPARAMETERS_PRINT_FP                        = 148;
		public const int F_ECPKPARAMETERS_PRINT                         = 149;
		public const int F_ECPKPARAMETERS_PRINT_FP                      = 150;
		public const int F_ECP_NISTZ256_GET_AFFINE                      = 240;
		public const int F_ECP_NISTZ256_INV_MOD_ORD                     = 275;
		public const int F_ECP_NISTZ256_MULT_PRECOMPUTE                 = 243;
		public const int F_ECP_NISTZ256_POINTS_MUL                      = 241;
		public const int F_ECP_NISTZ256_PRE_COMP_NEW                    = 244;
		public const int F_ECP_NISTZ256_WINDOWED_MUL                    = 242;
		public const int F_ECX_KEY_OP                                   = 266;
		public const int F_ECX_PRIV_ENCODE                              = 267;
		public const int F_ECX_PUB_ENCODE                               = 268;
		public const int F_EC_ASN1_GROUP2CURVE                          = 153;
		public const int F_EC_ASN1_GROUP2FIELDID                        = 154;
		public const int F_EC_GF2M_MONTGOMERY_POINT_MULTIPLY            = 208;
		public const int F_EC_GF2M_SIMPLE_FIELD_INV                     = 296;
		public const int F_EC_GF2M_SIMPLE_GROUP_CHECK_DISCRIMINANT      = 159;
		public const int F_EC_GF2M_SIMPLE_GROUP_SET_CURVE               = 195;
		public const int F_EC_GF2M_SIMPLE_LADDER_POST                   = 285;
		public const int F_EC_GF2M_SIMPLE_LADDER_PRE                    = 288;
		public const int F_EC_GF2M_SIMPLE_OCT2POINT                     = 160;
		public const int F_EC_GF2M_SIMPLE_POINT2OCT                     = 161;
		public const int F_EC_GF2M_SIMPLE_POINTS_MUL                    = 289;
		public const int F_EC_GF2M_SIMPLE_POINT_GET_AFFINE_COORDINATES  = 162;
		public const int F_EC_GF2M_SIMPLE_POINT_SET_AFFINE_COORDINATES  = 163;
		public const int F_EC_GF2M_SIMPLE_SET_COMPRESSED_COORDINATES    = 164;
		public const int F_EC_GFP_MONT_FIELD_DECODE                     = 133;
		public const int F_EC_GFP_MONT_FIELD_ENCODE                     = 134;
		public const int F_EC_GFP_MONT_FIELD_INV                        = 297;
		public const int F_EC_GFP_MONT_FIELD_MUL                        = 131;
		public const int F_EC_GFP_MONT_FIELD_SET_TO_ONE                 = 209;
		public const int F_EC_GFP_MONT_FIELD_SQR                        = 132;
		public const int F_EC_GFP_MONT_GROUP_SET_CURVE                  = 189;
		public const int F_EC_GFP_NISTP224_GROUP_SET_CURVE              = 225;
		public const int F_EC_GFP_NISTP224_POINTS_MUL                   = 228;
		public const int F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES = 226;
		public const int F_EC_GFP_NISTP256_GROUP_SET_CURVE              = 230;
		public const int F_EC_GFP_NISTP256_POINTS_MUL                   = 231;
		public const int F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES = 232;
		public const int F_EC_GFP_NISTP521_GROUP_SET_CURVE              = 233;
		public const int F_EC_GFP_NISTP521_POINTS_MUL                   = 234;
		public const int F_EC_GFP_NISTP521_POINT_GET_AFFINE_COORDINATES = 235;
		public const int F_EC_GFP_NIST_FIELD_MUL                        = 200;
		public const int F_EC_GFP_NIST_FIELD_SQR                        = 201;
		public const int F_EC_GFP_NIST_GROUP_SET_CURVE                  = 202;
		public const int F_EC_GFP_SIMPLE_BLIND_COORDINATES              = 287;
		public const int F_EC_GFP_SIMPLE_FIELD_INV                      = 298;
		public const int F_EC_GFP_SIMPLE_GROUP_CHECK_DISCRIMINANT       = 165;
		public const int F_EC_GFP_SIMPLE_GROUP_SET_CURVE                = 166;
		public const int F_EC_GFP_SIMPLE_MAKE_AFFINE                    = 102;
		public const int F_EC_GFP_SIMPLE_OCT2POINT                      = 103;
		public const int F_EC_GFP_SIMPLE_POINT2OCT                      = 104;
		public const int F_EC_GFP_SIMPLE_POINTS_MAKE_AFFINE             = 137;
		public const int F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES   = 167;
		public const int F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES   = 168;
		public const int F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES     = 169;
		public const int F_EC_GROUP_CHECK                               = 170;
		public const int F_EC_GROUP_CHECK_DISCRIMINANT                  = 171;
		public const int F_EC_GROUP_COPY                                = 106;
		public const int F_EC_GROUP_GET_CURVE                           = 291;
		public const int F_EC_GROUP_GET_CURVE_GF2M                      = 172;
		public const int F_EC_GROUP_GET_CURVE_GFP                       = 130;
		public const int F_EC_GROUP_GET_DEGREE                          = 173;
		public const int F_EC_GROUP_GET_ECPARAMETERS                    = 261;
		public const int F_EC_GROUP_GET_ECPKPARAMETERS                  = 262;
		public const int F_EC_GROUP_GET_PENTANOMIAL_BASIS               = 193;
		public const int F_EC_GROUP_GET_TRINOMIAL_BASIS                 = 194;
		public const int F_EC_GROUP_NEW                                 = 108;
		public const int F_EC_GROUP_NEW_BY_CURVE_NAME                   = 174;
		public const int F_EC_GROUP_NEW_FROM_DATA                       = 175;
		public const int F_EC_GROUP_NEW_FROM_ECPARAMETERS               = 263;
		public const int F_EC_GROUP_NEW_FROM_ECPKPARAMETERS             = 264;
		public const int F_EC_GROUP_SET_CURVE                           = 292;
		public const int F_EC_GROUP_SET_CURVE_GF2M                      = 176;
		public const int F_EC_GROUP_SET_CURVE_GFP                       = 109;
		public const int F_EC_GROUP_SET_GENERATOR                       = 111;
		public const int F_EC_GROUP_SET_SEED                            = 286;
		public const int F_EC_KEY_CHECK_KEY                             = 177;
		public const int F_EC_KEY_COPY                                  = 178;
		public const int F_EC_KEY_GENERATE_KEY                          = 179;
		public const int F_EC_KEY_NEW                                   = 182;
		public const int F_EC_KEY_NEW_METHOD                            = 245;
		public const int F_EC_KEY_OCT2PRIV                              = 255;
		public const int F_EC_KEY_PRINT                                 = 180;
		public const int F_EC_KEY_PRINT_FP                              = 181;
		public const int F_EC_KEY_PRIV2BUF                              = 279;
		public const int F_EC_KEY_PRIV2OCT                              = 256;
		public const int F_EC_KEY_SET_PUBLIC_KEY_AFFINE_COORDINATES     = 229;
		public const int F_EC_KEY_SIMPLE_CHECK_KEY                      = 258;
		public const int F_EC_KEY_SIMPLE_OCT2PRIV                       = 259;
		public const int F_EC_KEY_SIMPLE_PRIV2OCT                       = 260;
		public const int F_EC_PKEY_CHECK                                = 273;
		public const int F_EC_PKEY_PARAM_CHECK                          = 274;
		public const int F_EC_POINTS_MAKE_AFFINE                        = 136;
		public const int F_EC_POINTS_MUL                                = 290;
		public const int F_EC_POINT_ADD                                 = 112;
		public const int F_EC_POINT_BN2POINT                            = 280;
		public const int F_EC_POINT_CMP                                 = 113;
		public const int F_EC_POINT_COPY                                = 114;
		public const int F_EC_POINT_DBL                                 = 115;
		public const int F_EC_POINT_GET_AFFINE_COORDINATES              = 293;
		public const int F_EC_POINT_GET_AFFINE_COORDINATES_GF2M         = 183;
		public const int F_EC_POINT_GET_AFFINE_COORDINATES_GFP          = 116;
		public const int F_EC_POINT_GET_JPROJECTIVE_COORDINATES_GFP     = 117;
		public const int F_EC_POINT_INVERT                              = 210;
		public const int F_EC_POINT_IS_AT_INFINITY                      = 118;
		public const int F_EC_POINT_IS_ON_CURVE                         = 119;
		public const int F_EC_POINT_MAKE_AFFINE                         = 120;
		public const int F_EC_POINT_NEW                                 = 121;
		public const int F_EC_POINT_OCT2POINT                           = 122;
		public const int F_EC_POINT_POINT2BUF                           = 281;
		public const int F_EC_POINT_POINT2OCT                           = 123;
		public const int F_EC_POINT_SET_AFFINE_COORDINATES              = 294;
		public const int F_EC_POINT_SET_AFFINE_COORDINATES_GF2M         = 185;
		public const int F_EC_POINT_SET_AFFINE_COORDINATES_GFP          = 124;
		public const int F_EC_POINT_SET_COMPRESSED_COORDINATES          = 295;
		public const int F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M     = 186;
		public const int F_EC_POINT_SET_COMPRESSED_COORDINATES_GFP      = 125;
		public const int F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP     = 126;
		public const int F_EC_POINT_SET_TO_INFINITY                     = 127;
		public const int F_EC_PRE_COMP_NEW                              = 196;
		public const int F_EC_SCALAR_MUL_LADDER                         = 284;
		public const int F_EC_WNAF_MUL                                  = 187;
		public const int F_EC_WNAF_PRECOMPUTE_MULT                      = 188;
		public const int F_I2D_ECPARAMETERS                             = 190;
		public const int F_I2D_ECPKPARAMETERS                           = 191;
		public const int F_I2D_ECPRIVATEKEY                             = 192;
		public const int F_I2O_ECPUBLICKEY                              = 151;
		public const int F_NISTP224_PRE_COMP_NEW                        = 227;
		public const int F_NISTP256_PRE_COMP_NEW                        = 236;
		public const int F_NISTP521_PRE_COMP_NEW                        = 237;
		public const int F_O2I_ECPUBLICKEY                              = 152;
		public const int F_OLD_EC_PRIV_DECODE                           = 222;
		public const int F_OSSL_ECDH_COMPUTE_KEY                        = 247;
		public const int F_OSSL_ECDSA_SIGN_SIG                          = 249;
		public const int F_OSSL_ECDSA_VERIFY_SIG                        = 250;
		public const int F_PKEY_ECD_CTRL                                = 271;
		public const int F_PKEY_ECD_DIGESTSIGN                          = 272;
		public const int F_PKEY_ECD_DIGESTSIGN25519                     = 276;
		public const int F_PKEY_ECD_DIGESTSIGN448                       = 277;
		public const int F_PKEY_ECX_DERIVE                              = 269;
		public const int F_PKEY_EC_CTRL                                 = 197;
		public const int F_PKEY_EC_CTRL_STR                             = 198;
		public const int F_PKEY_EC_DERIVE                               = 217;
		public const int F_PKEY_EC_INIT                                 = 282;
		public const int F_PKEY_EC_KDF_DERIVE                           = 283;
		public const int F_PKEY_EC_KEYGEN                               = 199;
		public const int F_PKEY_EC_PARAMGEN                             = 219;
		public const int F_PKEY_EC_SIGN                                 = 218;
		public const int F_VALIDATE_ECX_DERIVE                          = 278;
		
		/*
		 * EC reason codes.
		 */
		public const int R_ASN1_ERROR                                   = 115;
		public const int R_BAD_SIGNATURE                                = 156;
		public const int R_BIGNUM_OUT_OF_RANGE                          = 144;
		public const int R_BUFFER_TOO_SMALL                             = 100;
		public const int R_CANNOT_INVERT                                = 165;
		public const int R_COORDINATES_OUT_OF_RANGE                     = 146;
		public const int R_CURVE_DOES_NOT_SUPPORT_ECDH                  = 160;
		public const int R_CURVE_DOES_NOT_SUPPORT_SIGNING               = 159;
		public const int R_D2I_ECPKPARAMETERS_FAILURE                   = 117;
		public const int R_DECODE_ERROR                                 = 142;
		public const int R_DISCRIMINANT_IS_ZERO                         = 118;
		public const int R_EC_GROUP_NEW_BY_NAME_FAILURE                 = 119;
		public const int R_FIELD_TOO_LARGE                              = 143;
		public const int R_GF2M_NOT_SUPPORTED                           = 147;
		public const int R_GROUP2PKPARAMETERS_FAILURE                   = 120;
		public const int R_I2D_ECPKPARAMETERS_FAILURE                   = 121;
		public const int R_INCOMPATIBLE_OBJECTS                         = 101;
		public const int R_INVALID_ARGUMENT                             = 112;
		public const int R_INVALID_COMPRESSED_POINT                     = 110;
		public const int R_INVALID_COMPRESSION_BIT                      = 109;
		public const int R_INVALID_CURVE                                = 141;
		public const int R_INVALID_DIGEST                               = 151;
		public const int R_INVALID_DIGEST_TYPE                          = 138;
		public const int R_INVALID_ENCODING                             = 102;
		public const int R_INVALID_FIELD                                = 103;
		public const int R_INVALID_FORM                                 = 104;
		public const int R_INVALID_GROUP_ORDER                          = 122;
		public const int R_INVALID_KEY                                  = 116;
		public const int R_INVALID_OUTPUT_LENGTH                        = 161;
		public const int R_INVALID_PEER_KEY                             = 133;
		public const int R_INVALID_PENTANOMIAL_BASIS                    = 132;
		public const int R_INVALID_PRIVATE_KEY                          = 123;
		public const int R_INVALID_TRINOMIAL_BASIS                      = 137;
		public const int R_KDF_PARAMETER_ERROR                          = 148;
		public const int R_KEYS_NOT_SET                                 = 140;
		public const int R_LADDER_POST_FAILURE                          = 136;
		public const int R_LADDER_PRE_FAILURE                           = 153;
		public const int R_LADDER_STEP_FAILURE                          = 162;
		public const int R_MISSING_OID                                  = 167;
		public const int R_MISSING_PARAMETERS                           = 124;
		public const int R_MISSING_PRIVATE_KEY                          = 125;
		public const int R_NEED_NEW_SETUP_VALUES                        = 157;
		public const int R_NOT_A_NIST_PRIME                             = 135;
		public const int R_NOT_IMPLEMENTED                              = 126;
		public const int R_NOT_INITIALIZED                              = 111;
		public const int R_NO_PARAMETERS_SET                            = 139;
		public const int R_NO_PRIVATE_VALUE                             = 154;
		public const int R_OPERATION_NOT_SUPPORTED                      = 152;
		public const int R_PASSED_NULL_PARAMETER                        = 134;
		public const int R_PEER_KEY_ERROR                               = 149;
		public const int R_PKPARAMETERS2GROUP_FAILURE                   = 127;
		public const int R_POINT_ARITHMETIC_FAILURE                     = 155;
		public const int R_POINT_AT_INFINITY                            = 106;
		public const int R_POINT_COORDINATES_BLIND_FAILURE              = 163;
		public const int R_POINT_IS_NOT_ON_CURVE                        = 107;
		public const int R_RANDOM_NUMBER_GENERATION_FAILED              = 158;
		public const int R_SHARED_INFO_ERROR                            = 150;
		public const int R_SLOT_FULL                                    = 108;
		public const int R_UNDEFINED_GENERATOR                          = 113;
		public const int R_UNDEFINED_ORDER                              = 128;
		public const int R_UNKNOWN_COFACTOR                             = 164;
		public const int R_UNKNOWN_GROUP                                = 129;
		public const int R_UNKNOWN_ORDER                                = 114;
		public const int R_UNSUPPORTED_FIELD                            = 131;
		public const int R_WRONG_CURVE_PARAMETERS                       = 145;
		public const int R_WRONG_ORDER                                  = 130;

		/* Enum for the point conversion form as defined in X9.62 (ECDSA) for the encoding of a elliptic curve point (x,y) */
		[CRepr]
		public enum point_conversion_form_t
		{
	        /* the point is encoded as z||x, where the octet z specifies which solution of the quadratic equation y is */
		    POINT_CONVERSION_COMPRESSED   = 2,
		    /* the point is encoded as z||x||y, where z is the octet 0x04 */
		    POINT_CONVERSION_UNCOMPRESSED = 4,
	        /* the point is encoded as z||x||y, where the octet z specifies which solution of the quadratic equation y is */
		    POINT_CONVERSION_HYBRID       = 6
		}
		
		[CRepr]
		public struct key_st
		{
		    public KEY_METHOD* meth;
		    public Engine.ENGINE* engine;
		    public int version;
		    public GROUP* group;
		    public POINT* pub_key;
		    public BN.BIGNUM* priv_key;
		    public uint enc_flag;
		    public point_conversion_form_t conv_form;
		    public Crypto.REF_COUNT references;
		    public int flags;
		    public Crypto.EX_DATA ex_data;
		    public Crypto.RWLOCK* lock;
		}
		public typealias KEY = key_st;

		
		/* METHOD definitions */
		[CRepr]
		public struct key_method_st
		{
		    public char8* name;
		    public int32 flags;
		    public function int(KEY* key) init;
		    public function void(KEY* key) finish;
		    public function int(KEY* dest, KEY* src) copy;
		    public function int(KEY* key, GROUP* grp) set_group;
		    public function int(KEY* key, BN.BIGNUM* priv_key) set_private;
		    public function int(KEY* key, POINT* pub_key) set_public;
		    public function int(KEY* key) keygen;
		    public function int(uint8** pout, int* poutlen, POINT* pub_key, KEY* ecdh) compute_key;
		    public function int(int type, uint8* dgst, int dlen, uint8* sig, uint* siglen, BN.BIGNUM* kinv, BN.BIGNUM* r, KEY* eckey) sign;
		    public function int(KEY* eckey, BN.CTX* ctx_in, BN.BIGNUM** kinvp, BN.BIGNUM** rp) sign_setup;
		    public function ECDSA.SIG*(uint8* dgst, int dgst_len, BN.BIGNUM* in_kinv, BN.BIGNUM* in_r, KEY* eckey) sign_sig;

		    public function int(int type, uint8* dgst, int dgst_len, uint8* sigbuf, int sig_len, KEY* eckey) verify;
		    public function int(uint8* dgst, int dgst_len, ECDSA.SIG* sig, KEY* eckey) verify_sig;
		}
		public typealias KEY_METHOD = key_method_st;

		[CRepr]
		public struct method_st
		{
		    /* Various method flags */
		    public int flags;
		    /* used by METHOD_get_field_type: */
		    public int field_type; /* a NID */
		    /* used by GROUP_new, GROUP_free, GROUP_clear_free, GROUP_copy: */
		    public function int(GROUP*) group_init;
		    public function void(GROUP*) group_finish;
		    public function void(GROUP*) group_clear_finish;
		    public function int(GROUP*, GROUP*) group_copy;
		    /* used by GROUP_set_curve, GROUP_get_curve: */
		    public function int(GROUP*, BN.BIGNUM* p, BN.BIGNUM* a, BN.BIGNUM* b, BN.CTX*) group_set_curve;
		    public function int(GROUP*, BN.BIGNUM* p, BN.BIGNUM* a, BN.BIGNUM* b, BN.CTX*) group_get_curve;
		    /* used by GROUP_get_degree: */
		    public function int(GROUP*) group_get_degree;
		    public function int(GROUP*) group_order_bits;
		    /* used by GROUP_check: */
		    public function int(GROUP*, BN.CTX*) group_check_discriminant;
		    /* used by POINT_new, POINT_free, POINT_clear_free, POINT_copy: */
		    public function int(POINT*) point_init;
		    public function void(POINT*) point_finish;
		    public function void(POINT*) point_clear_finish;
		    public function int(POINT*, POINT*) point_copy;
		    /*-
		     * used by POINT_set_to_infinity,
		     * POINT_set_Jprojective_coordinates_GFp,
		     * POINT_get_Jprojective_coordinates_GFp,
		     * POINT_set_affine_coordinates,
		     * POINT_get_affine_coordinates,
		     * POINT_set_compressed_coordinates:
		     */
		    public function int(GROUP*, POINT*) point_set_to_infinity;
		    public function int(GROUP*, POINT*, BN.BIGNUM* x, BN.BIGNUM* y, BN.BIGNUM* z, BN.CTX*) point_set_Jprojective_coordinates_GFp;
		    public function int(GROUP*, POINT*, BN.BIGNUM* x, BN.BIGNUM* y, BN.BIGNUM* z, BN.CTX*) point_get_Jprojective_coordinates_GFp;
		    public function int(GROUP*, POINT*, BN.BIGNUM* x, BN.BIGNUM* y, BN.CTX*) point_set_affine_coordinates;
		    public function int(GROUP*, POINT*, BN.BIGNUM* x, BN.BIGNUM* y, BN.CTX*) point_get_affine_coordinates;
		    public function int(GROUP* , POINT* , BN.BIGNUM* x, int y_bit, BN.CTX*) point_set_compressed_coordinates;
		    /* used by POINT_point2oct, POINT_oct2point: */
		    public function int(GROUP*, POINT*, point_conversion_form_t form, uint8* buf, int len, BN.CTX*) point2oct;
		    public function int(GROUP*, POINT*, uint8* buf, int len, BN.CTX*) oct2point;
		    /* used by POINT_add, POINT_dbl, ECP.POINT_invert: */
		    public function int(GROUP*, POINT* r, POINT* a, POINT* b, BN.CTX*) add;
		    public function int(GROUP*, POINT* r, POINT* a, BN.CTX*) dbl;
		    public function int(GROUP*, POINT*, BN.CTX*) invert;
		    /* used by POINT_is_at_infinity, POINT_is_on_curve, POINT_cmp: */
		    public function int(GROUP*, POINT*) is_at_infinity;
		    public function int(GROUP*, POINT*, BN.CTX*) is_on_curve;
		    public function int(GROUP*, POINT* a, POINT* b, BN.CTX*) point_cmp;
		    /* used by POINT_make_affine, POINTs_make_affine: */
		    public function int(GROUP*, POINT*, BN.CTX*) make_affine;
		    public function int(GROUP*, int num, POINT*[], BN.CTX*) points_make_affine;
		    /* used by POINTs_mul, POINT_mul, POINT_precompute_mult, POINT_have_precompute_mult (default implementations are used if the 'mul' pointer is 0): */
		    /*-
		     * mul() calculates the value
		     *
		     *   r := generator * scalar
		     *        + points[0] * scalars[0]
		     *        + ...
		     *        + points[num-1] * scalars[num-1].
		     *
		     * For a fixed point multiplication (scalar != NULL, num == 0) or a variable point multiplication (scalar == NULL, num == 1), mul() must use a constant time algorithm:
			 * in both cases callers should provide an input scalar (either scalar or scalars[0]) in the range [0, ec_group_order); for robustness, implementers should handle the case when the scalar has not been reduced, but
		     * may treat it as an unusual input, without any constant-timeness guarantee.
		     */
		    public function int(GROUP* group, POINT* r, BN.BIGNUM* scalar, int num, POINT*[] points, BN.BIGNUM*[] scalars, BN.CTX*) mul;
		    public function int(GROUP* group, BN.CTX*) precompute_mult;
		    public function int(GROUP* group) have_precompute_mult;
		    /* internal functions */
		    /* 'field_mul', 'field_sqr', and 'field_div' can be used by 'add' and 'dbl' so that the same implementations of point operations can be used with different optimized implementations of expensive field operations: */
		    public function int(GROUP*, BN.BIGNUM* r, BN.BIGNUM* a, BN.BIGNUM* b, BN.CTX*) field_mul;
		    public function int(GROUP*, BN.BIGNUM* r, BN.BIGNUM* a, BN.CTX*) field_sqr;
		    public function int(GROUP*, BN.BIGNUM* r, BN.BIGNUM* a, BN.BIGNUM* b, BN.CTX*) field_div;
		    /*-
		     * 'field_inv' computes the multiplicative inverse of a in the field, storing the result in r.
		     *
		     * If 'a' is zero (or equivalent), you'll get an R_CANNOT_INVERT error.
		     */
		    public function int(GROUP*, BN.BIGNUM* r, BN.BIGNUM* a, BN.CTX*) field_inv;
		    /* e.g. to Montgomery */
		    public function int(GROUP*, BN.BIGNUM* r, BN.BIGNUM* a, BN.CTX*) field_encode;
		    /* e.g. from Montgomery */
		    public function int(GROUP*, BN.BIGNUM* r, BN.BIGNUM* a, BN.CTX*) field_decode;
		    public function int(GROUP*, BN.BIGNUM* r, BN.CTX*) field_set_to_one;
		    /* private key operations */
		    public function int(KEY* eckey, uint8* buf, int len) priv2oct;
		    public function int(KEY* eckey, uint8* buf, int len) oct2priv;
		    public function int(KEY* eckey, BN.BIGNUM* priv_key) set_private;
		    public function int(KEY* eckey) keygen;
		    public function int(KEY* eckey) keycheck;
		    public function int(KEY* eckey) keygenpub;
		    public function int(KEY* dst, KEY* src) keycopy;
		    public function void(KEY* eckey) keyfinish;
		    /* custom ECDH operation */
		    public function int(uint8** pout, int *poutlen, POINT* pub_key, KEY* ecdh) ecdh_compute_key;
		    /* Inverse modulo order */
		    public function int(GROUP* , BN.BIGNUM* r, BN.BIGNUM* x, BN.CTX*) field_inverse_mod_ord;
		    public function int(GROUP* group, POINT* p, BN.CTX* ctx) blind_coordinates;
		    public function int(GROUP* group, POINT* r, POINT* s, POINT* p, BN.CTX* ctx) ladder_pre;
		    public function int(GROUP* group, POINT* r, POINT* s, POINT* p, BN.CTX* ctx) ladder_step;
		    public function int(GROUP* group, POINT* r, POINT* s, POINT* p, BN.CTX* ctx) ladder_post;
		}
		typealias METHOD = method_st;

		[CRepr]
		public struct group_st
		{
		    public METHOD* meth;
		    public POINT* generator;                  /* optional */
		    public BN.BIGNUM* order;
			public BN.BIGNUM* cofactor;
		    public int curve_name;                    /* optional NID for named curve */
		    public int asn1_flag;                     /* flag to control the asn1 encoding */
		    public int decoded_from_explicit_params;  /* set if decoded from explicit curve parameters encoding */
		    public point_conversion_form_t asn1_form;
		    public uint8* seed;                       /* optional seed for parameters (appears in ASN1) */
		    public int seed_len;
		    /* The following members are handled by the method functions, even if they appear generic */
		    /* Field specification. For curves over GF(p), this is the modulus; for curves over GF(2^m), this is the irreducible polynomial defining the field. */
		    public BN.BIGNUM* field;
		    /*
		     * Field specification for curves over GF(2^m). The irreducible f(t) is then of the form: t^poly[0] + t^poly[1] + ... + t^poly[k] where m = poly[0] > poly[1] > ... > poly[k] = 0.
			 * The array is terminated with poly[k+1]=-1. All elliptic curve irreducibles have at most 5 non-zero terms.
		     */
		    public int[6] poly;
		    /*
		     * Curve coefficients. (Here the assumption is that BIGNUMs can be used or abused for all kinds of fields, not just GF(p).) For characteristic > 3, the curve is defined by a Weierstrass equation
			 * of the form y^2 = x^3 + a*x + b. For characteristic 2, the curve is defined by an equation of the form y^2 + x*y = x^3 + a*x^2 + b.
		     */
		    public BN.BIGNUM* a;
			public BN.BIGNUM* b;
		    /* enable optimized point arithmetics for special case */
		    public int a_is_minus3;
		    /* method-specific (e.g., Montgomery structure) */
		    public void* field_data1;
		    /* method-specific */
		    public void* field_data2;
		    /* method-specific */
		    public function int(BN.BIGNUM*, BN.BIGNUM*, BN.BIGNUM*, BN.CTX*) field_mod_func;
		    /* data for ECDSA inverse */
		    public BN.MONT_CTX* mont_data;
			public pre_comp_type_enum pre_comp_type;
			public pre_comp_struct pre_comp;

		    /* Precomputed values for speed. The PCT_xxx names match the pre_comp.xxx union names; see the SETPRECOMP and HAVEPRECOMP macros, below. */
			[CRepr]
		    public enum pre_comp_type_enum
			{
		        PCT_none,
		        PCT_nistp224, PCT_nistp256, PCT_nistp521, PCT_nistz256,
		        PCT_ec
		    }

			[CRepr, Union]
		    public struct pre_comp_struct
			{
		        public NISTP224.PRE_COMP* nistp224;
		        public NISTP256.PRE_COMP* nistp256;
		        public NISTP521.PRE_COMP* nistp521;
		        public NISTZ256.PRE_COMP* nistz256;
		        public PRE_COMP* ec;
		    }
		}
		public typealias GROUP = group_st;

		[CRepr]
		public struct point_st
		{
		    public METHOD* meth;
		    /* NID for the curve if known */
		    public int curve_name;
		    /* All members except 'meth' are handled by the method functions, even if they appear generic */
		    public BN.BIGNUM* X;
		    public BN.BIGNUM* Y;
		    public BN.BIGNUM* Z;  /* Jacobian projective coordinates: * (X, Y, Z) represents (X/Z^2, Y/Z^3) if Z != 0 */
		    public int Z_is_one;  /* enable optimized point arithmetics for special case */
		}
		public typealias POINT = point_st;

		/* some structures needed for the asn1 encoding */
		[CRepr]
		public struct x9_62_pentanomial_st
		{
		    public int32 k1;
		    public int32 k2;
		    public int32 k3;
		}
		public typealias X9_62_PENTANOMIAL = x9_62_pentanomial_st;

		[CRepr]
		public struct x9_62_characteristic_two_st
		{
		    public int32 m;
		    public ASN1.OBJECT* type;
			public p_struct p;

			[CRepr, Union]
		    public struct p_struct
			{
		        public char8* ptr;
		        /* NID.X9_62_onBasis */
		        public ASN1.NULL* onBasis;
		        /* NID.X9_62_tpBasis */
		        public ASN1.INTEGER* tpBasis;
		        /* NID.X9_62_ppBasis */
		        public X9_62_PENTANOMIAL* ppBasis;
		        /* anything else */
		        public ASN1.TYPE* other;
		    }
		}
		public typealias X9_62_CHARACTERISTIC_TWO = x9_62_characteristic_two_st;

		[CRepr]
		public struct x9_62_fieldid_st
		{
		    public ASN1.OBJECT* fieldType;
			public p_struct p;

			[CRepr, Union]
		    public struct p_struct
			{
		        public char8* ptr;
		        /* NID.X9_62_prime_field */
		        public ASN1.INTEGER* prime;
		        /* NID.X9_62_characteristic_two_field */
		        public X9_62_CHARACTERISTIC_TWO* char_two;
		        /* anything else */
		        public ASN1.TYPE* other;
		    }
		}
		public typealias X9_62_FIELDID = x9_62_fieldid_st;

		[CRepr]
		public struct x9_62_curve_st
		{
		    public ASN1.OCTET_STRING* a;
		    public ASN1.OCTET_STRING* b;
		    public ASN1.BIT_STRING* seed;
		}
		public typealias X9_62_CURVE = x9_62_curve_st;

		[CRepr]
		public struct parameters_st
		{
		    public int32 version;
		    public X9_62_FIELDID* fieldID;
		    public X9_62_CURVE* curve;
		    public ASN1.OCTET_STRING* base_;
		    public ASN1.INTEGER* order;
		    public ASN1.INTEGER* cofactor;
		}
		public typealias ECPARAMETERS = parameters_st;

		[CRepr]
		public struct ecpk_parameters_st
		{
		    public int type;
			public value_struct value;

			[CRepr, Union]
		    public struct value_struct
			{
		        public ASN1.OBJECT* named_curve;
		        public ECPARAMETERS* parameters;
		        public ASN1.NULL* implicitlyCA;
		    }
		}
		public typealias ECPKPARAMETERS = ecpk_parameters_st;

		/* structure for precomputed multiples of the generator */
		[CRepr]
		public struct pre_comp_st
		{
		    public GROUP* group;                /* parent GROUP object */
		    public int blocksize;               /* block size for wNAF splitting */
		    public int numblocks;               /* max. number of blocks for which we have precomputation */
		    public int w;                       /* window size */
		    public POINT** points;              /* array with pre-calculated multiples of generator: 'num' pointers to POINT objects followed by a NULL */
		    public int num;                     /* numblocks * 2^(w-1) */
		    public Crypto.REF_COUNT references;
		    public Crypto.RWLOCK* lock;
		}
		public typealias PRE_COMP = pre_comp_st;

		/********************************************************************/
		/*                 METHODs for curves over GF(p)                    */
		/********************************************************************/

		/** Returns the basic GFp ec methods which provides the basis for the optimized methods.
		 *  \return  METHOD object
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GFp_simple_method")
		]
		public static extern METHOD* GFp_simple_method();

		/** Returns GFp methods using montgomery multiplication.
		 *  \return  METHOD object
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GFp_mont_method")
		]
		public static extern METHOD* GFp_mont_method();

		/** Returns GFp methods using optimized methods for NIST recommended curves
		 *  \return  METHOD object
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GFp_nist_method")
		]
		public static extern METHOD* GFp_nist_method();

	#if !OPENSSL_NO_EC_NISTP_64_GCC_128
		/** Returns 64-bit optimized methods for nistp224
		 *  \return  METHOD object
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GFp_nistp224_method")
		]
		public static extern METHOD* GFp_nistp224_method();

		/** Returns 64-bit optimized methods for nistp256
		 *  \return  METHOD object
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GFp_nistp256_method")
		]
		public static extern METHOD* GFp_nistp256_method();

		/** Returns 64-bit optimized methods for nistp521
		 *  \return  METHOD object
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GFp_nistp521_method")
		]
		public static extern METHOD* GFp_nistp521_method();
	#endif

	#if !OPENSSL_NO_EC2M
		/********************************************************************/
		/*             METHOD for curves over GF(2^m)                       */
		/********************************************************************/

		/** Returns the basic GF2m ec method
		 *  \return  METHOD object
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GF2m_simple_method")
		]
		public static extern METHOD* GF2m_simple_method();

	#endif

		/********************************************************************/
		/*                     GROUP functions                              */
		/********************************************************************/

		/** Creates a new GROUP object
		 *  \param   meth  METHOD to use
		 *  \return  newly created EC_GROUP object or NULL in case of an error.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_new")
		]
		public static extern GROUP* GROUP_new(METHOD* meth);

		/** Frees a GROUP object
		 *  \param  group  GROUP object to be freed.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_free")
		]
		public static extern void GROUP_free(GROUP* group);

		/** Clears and frees a GROUP object
		 *  \param  group  GROUP object to be cleared and freed.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_clear_free")
		]
		public static extern void GROUP_clear_free(GROUP* group);

		/** Copies GROUP objects. Note: both GROUPs must use the same METHOD.
		 *  \param  dst  destination GROUP object
		 *  \param  src  source GROUP object
		 *  \return 1 on success and 0 if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_copy")
		]
		public static extern int GROUP_copy(GROUP* dst, GROUP* src);

		/** Creates a new GROUP object and copies the copies the content form src to the newly created KEY object
		 *  \param  src  source GROUP object
		 *  \return newly created GROUP object or NULL in case of an error.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_dup")
		]
		public static extern GROUP* GROUP_dup(GROUP* src);

		/** Returns the METHOD of the GROUP object.
		 *  \param  group  GROUP object
		 *  \return METHOD used in this GROUP object.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_method_of")
		]
		public static extern METHOD* GROUP_method_of(GROUP* group);

		/** Returns the field type of the METHOD.
		 *  \param  meth  METHOD object
		 *  \return NID of the underlying field type OID.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_METHOD_get_field_type")
		]
		public static extern int METHOD_get_field_type(METHOD* meth);

		/** Sets the generator and its order/cofactor of a GROUP object.
		 *  \param  group      GROUP object
		 *  \param  generator  POINT object with the generator.
		 *  \param  order      the order of the group generated by the generator.
		 *  \param  cofactor   the index of the sub-group generated by the generator in the group of all points on the elliptic curve.
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_set_generator")
		]
		public static extern int GROUP_set_generator(GROUP* group, POINT* generator, BN.BIGNUM* order, BN.BIGNUM* cofactor);

		/** Returns the generator of a GROUP object.
		 *  \param  group  GROUP object
		 *  \return the currently used generator (possibly NULL).
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get0_generator")
		]
		public static extern POINT* GROUP_get0_generator(GROUP* group);

		/** Returns the montgomery data for order(Generator)
		 *  \param  group  GROUP object
		 *  \return the currently used montgomery data (possibly NULL).
		*/
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get_mont_data")
		]
		public static extern BN.MONT_CTX* GROUP_get_mont_data(GROUP* group);

		/** Gets the order of a GROUP
		 *  \param  group  GROUP object
		 *  \param  order  BN.BIGNUM to which the order is copied
		 *  \param  ctx    unused
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get_order")
		]
		public static extern int GROUP_get_order(GROUP* group, BN.BIGNUM* order, BN.CTX* ctx);

		/** Gets the order of an GROUP
		 *  \param  group  GROUP object
		 *  \return the group order
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get0_order")
		]
		public static extern BN.BIGNUM* GROUP_get0_order(GROUP* group);

		/** Gets the number of bits of the order of an GROUP
		 *  \param  group  GROUP object
		 *  \return number of bits of group order.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_order_bits")
		]
		public static extern int GROUP_order_bits(GROUP* group);

		/** Gets the cofactor of a GROUP
		 *  \param  group     GROUP object
		 *  \param  cofactor  BN.BIGNUM to which the cofactor is copied
		 *  \param  ctx       unused
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get_cofactor")
		]
		public static extern int GROUP_get_cofactor(GROUP* group, BN.BIGNUM* cofactor, BN.CTX* ctx);

		/** Gets the cofactor of an GROUP
		 *  \param  group  GROUP object
		 *  \return the group cofactor
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get0_cofactor")
		]
		public static extern BN.BIGNUM* GROUP_get0_cofactor(GROUP* group);

		/** Sets the name of a GROUP object
		 *  \param  group  GROUP object
		 *  \param  nid    NID of the curve name OID
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_set_curve_name")
		]
		public static extern void GROUP_set_curve_name(GROUP* group, int nid);

		/** Returns the curve name of a GROUP object
		 *  \param  group  GROUP object
		 *  \return NID of the curve name OID or 0 if not set.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get_curve_name")
		]
		public static extern int GROUP_get_curve_name(GROUP* group);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_set_asn1_flag")
		]
		public static extern void GROUP_set_asn1_flag(GROUP* group, int flag);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get_asn1_flag")
		]
		public static extern int GROUP_get_asn1_flag(GROUP* group);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_set_point_conversion_form")
		]
		public static extern void GROUP_set_point_conversion_form(GROUP* group, point_conversion_form_t form);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get_point_conversion_form")
		]
		public static extern point_conversion_form_t GROUP_get_point_conversion_form(GROUP* group);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get0_seed")
		]
		public static extern uint8* GROUP_get0_seed(GROUP* group);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get_seed_len")
		]
		public static extern int GROUP_get_seed_len(GROUP* group);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_set_seed")
		]
		public static extern int GROUP_set_seed(GROUP* group, uint8* p, int len);

		/** Sets the parameters of a ec curve defined by y^2 = x^3 + a*x + b (for GFp) or y^2 + x*y = x^3 + a*x^2 + b (for GF2m)
		 *  \param  group  GROUP object
		 *  \param  p      BN.BIGNUM with the prime number (GFp) or the polynomial defining the underlying field (GF2m)
		 *  \param  a      BN.BIGNUM with parameter a of the equation
		 *  \param  b      BN.BIGNUM with parameter b of the equation
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_set_curve")
		]
		public static extern int GROUP_set_curve(GROUP* group, BN.BIGNUM* p, BN.BIGNUM* a, BN.BIGNUM* b, BN.CTX* ctx);

		/** Gets the parameters of the ec curve defined by y^2 = x^3 + a*x + b (for GFp) or y^2 + x*y = x^3 + a*x^2 + b (for GF2m)
		 *  \param  group  GROUP object
		 *  \param  p      BN.BIGNUM with the prime number (GFp) or the polynomial defining the underlying field (GF2m)
		 *  \param  a      BN.BIGNUM for parameter a of the equation
		 *  \param  b      BN.BIGNUM for parameter b of the equation
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get_curve")
		]
		public static extern int GROUP_get_curve(GROUP* group, BN.BIGNUM* p, BN.BIGNUM* a, BN.BIGNUM* b, BN.CTX* ctx);

		/** Sets the parameters of an ec curve. Synonym for GROUP_set_curve
		 *  \param  group  GROUP object
		 *  \param  p      BN.BIGNUM with the prime number (GFp) or the polynomial defining the underlying field (GF2m)
		 *  \param  a      BN.BIGNUM with parameter a of the equation
		 *  \param  b      BN.BIGNUM with parameter b of the equation
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_set_curve_GFp")
		]
		public static extern int GROUP_set_curve_GFp(GROUP* group, BN.BIGNUM* p, BN.BIGNUM* a, BN.BIGNUM* b, BN.CTX* ctx);

		/** Gets the parameters of an ec curve. Synonym for GROUP_get_curve
		 *  \param  group  GROUP object
		 *  \param  p      BN.BIGNUM with the prime number (GFp) or the polynomial defining the underlying field (GF2m)
		 *  \param  a      BN.BIGNUM for parameter a of the equation
		 *  \param  b      BN.BIGNUM for parameter b of the equation
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get_curve_GFp")
		]
		public static extern int GROUP_get_curve_GFp(GROUP* group, BN.BIGNUM* p, BN.BIGNUM* a, BN.BIGNUM* b, BN.CTX* ctx);

	#if !OPENSSL_NO_EC2M
		/** Sets the parameter of an ec curve. Synonym for GROUP_set_curve
		 *  \param  group  GROUP object
		 *  \param  p      BN.BIGNUM with the prime number (GFp) or the polynomial defining the underlying field (GF2m)
		 *  \param  a      BN.BIGNUM with parameter a of the equation
		 *  \param  b      BN.BIGNUM with parameter b of the equation
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_set_curve_GF2m")
		]
		public static extern int GROUP_set_curve_GF2m(GROUP* group, BN.BIGNUM* p, BN.BIGNUM* a, BN.BIGNUM* b, BN.CTX* ctx);

		/** Gets the parameters of an ec curve. Synonym for GROUP_get_curve
		 *  \param  group  GROUP object
		 *  \param  p      BN.BIGNUM with the prime number (GFp) or the polynomial defining the underlying field (GF2m)
		 *  \param  a      BN.BIGNUM for parameter a of the equation
		 *  \param  b      BN.BIGNUM for parameter b of the equation
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get_curve_GF2m")
		]
		public static extern int GROUP_get_curve_GF2m(GROUP* group, BN.BIGNUM* p, BN.BIGNUM* a, BN.BIGNUM* b, BN.CTX* ctx);
	#endif
		/** Returns the number of bits needed to represent a field element
		 *  \param  group  GROUP object
		 *  \return number of bits needed to represent a field element
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get_degree")
		]
		public static extern int GROUP_get_degree(GROUP* group);

		/** Checks whether the parameter in the GROUP define a valid ec group
		 *  \param  group  GROUP object
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 if group is a valid ec group and 0 otherwise
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_check")
		]
		public static extern int GROUP_check(GROUP* group, BN.CTX* ctx);

		/** Checks whether the discriminant of the elliptic curve is zero or not
		 *  \param  group  GROUP object
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 if the discriminant is not zero and 0 otherwise
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_check_discriminant")
		]
		public static extern int GROUP_check_discriminant(GROUP* group, BN.CTX* ctx);

		/** Compares two GROUP objects
		 *  \param  a    first GROUP object
		 *  \param  b    second GROUP object
		 *  \param  ctx  BN.CTX object (optional)
		 *  \return 0 if the groups are equal, 1 if not, or -1 on error
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_cmp")
		]
		public static extern int GROUP_cmp(GROUP* a, GROUP* b, BN.CTX* ctx);

		/*
		 * GROUP_new_GF*() calls GROUP_new() and GROUP_set_GF*() after choosing an appropriate METHOD
		 */

		/** Creates a new GROUP object with the specified parameters defined over GFp (defined by the equation y^2 = x^3 + a*x + b)
		 *  \param  p    BN.BIGNUM with the prime number
		 *  \param  a    BN.BIGNUM with the parameter a of the equation
		 *  \param  b    BN.BIGNUM with the parameter b of the equation
		 *  \param  ctx  BN.CTX object (optional)
		 *  \return newly created GROUP object with the specified parameters
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_new_curve_GFp")
		]
		public static extern GROUP* GROUP_new_curve_GFp(BN.BIGNUM* p, BN.BIGNUM* a, BN.BIGNUM* b, BN.CTX* ctx);
	#if !OPENSSL_NO_EC2M
		/** Creates a new GROUP object with the specified parameters defined over GF2m (defined by the equation y^2 + x*y = x^3 + a*x^2 + b)
		 *  \param  p    BN.BIGNUM with the polynomial defining the underlying field
		 *  \param  a    BN.BIGNUM with the parameter a of the equation
		 *  \param  b    BN.BIGNUM with the parameter b of the equation
		 *  \param  ctx  BN.CTX object (optional)
		 *  \return newly created GROUP object with the specified parameters
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_new_curve_GF2m")
		]
		public static extern GROUP* GROUP_new_curve_GF2m(BN.BIGNUM* p, BN.BIGNUM* a, BN.BIGNUM* b, BN.CTX* ctx);
	#endif

		/** Creates a GROUP object with a curve specified by a NID
		 *  \param  nid  NID of the OID of the curve name
		 *  \return newly created GROUP object with specified curve or NULL if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_new_by_curve_name")
		]
		public static extern GROUP* GROUP_new_by_curve_name(int nid);

		/** Creates a new GROUP object from an ECPARAMETERS object
		 *  \param  params  pointer to the ECPARAMETERS object
		 *  \return newly created GROUP object with specified curve or NULL if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_new_from_ecparameters")
		]
		public static extern GROUP* GROUP_new_from_ecparameters(ECPARAMETERS* params_);

		/** Creates an ECPARAMETERS object for the given GROUP object.
		 *  \param  group   pointer to the GROUP object
		 *  \param  params  pointer to an existing ECPARAMETERS object or NULL
		 *  \return pointer to the new ECPARAMETERS object or NULL if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get_ecparameters")
		]
		public static extern ECPARAMETERS* GROUP_get_ecparameters(GROUP* group, ECPARAMETERS* params_);

		/** Creates a new GROUP object from an ECPKPARAMETERS object
		 *  \param  params  pointer to an existing ECPKPARAMETERS object, or NULL
		 *  \return newly created GROUP object with specified curve, or NULL if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_new_from_ecpkparameters")
		]
		public static extern GROUP* GROUP_new_from_ecpkparameters(ECPKPARAMETERS* params_);

		/** Creates an ECPKPARAMETERS object for the given GROUP object.
		 *  \param  group   pointer to the GROUP object
		 *  \param  params  pointer to an existing ECPKPARAMETERS object or NULL
		 *  \return pointer to the new ECPKPARAMETERS object or NULL if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get_ecpkparameters")
		]
		public static extern ECPKPARAMETERS* GROUP_get_ecpkparameters(GROUP* group, ECPKPARAMETERS* params_);

		/********************************************************************/
		/*               handling of internal curves                        */
		/********************************************************************/
		[CRepr]
		public struct builtin_curve
		{
		    public int nid;
		    public char8* comment;
		}

		/*
		 * builtin_curves(EC_builtin_curve *r, int size) returns number of all available curves or zero if a error occurred. In case r is not zero,
		 * nitems builtin_curve structures are filled with the data of the first nitems internal groups
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_get_builtin_curves")
		]
		public static extern int get_builtin_curves(builtin_curve* r, int nitems);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_curve_nid2nist")
		]
		public static extern char8* curve_nid2nist(int nid);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_curve_nist2nid")
		]
		public static extern int curve_nist2nid(char8* name);

		/********************************************************************/
		/*                    EC_POINT functions                            */
		/********************************************************************/

		/** Creates a new POINT object for the specified GROUP
		 *  \param  group  GROUP the underlying GROUP object
		 *  \return newly created POINT object or NULL if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_new")
		]
		public static extern POINT* POINT_new(GROUP* group);

		/** Frees a POINT object
		 *  \param  point  POINT object to be freed
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_free")
		]
		public static extern void POINT_free(POINT* point);

		/** Clears and frees a POINT object
		 *  \param  point  POINT object to be cleared and freed
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_clear_free")
		]
		public static extern void POINT_clear_free(POINT* point);

		/** Copies POINT object
		 *  \param  dst  destination POINT object
		 *  \param  src  source POINT object
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_copy")
		]
		public static extern int POINT_copy(POINT* dst, POINT* src);

		/** Creates a new POINT object and copies the content of the supplied POINT
		 *  \param  src    source POINT object
		 *  \param  group  underlying the GROUP object
		 *  \return newly created POINT object or NULL if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_dup")
		]
		public static extern POINT* POINT_dup(POINT* src, GROUP* group);

		/** Returns the METHOD used in POINT object
		 *  \param  point  POINT object
		 *  \return the METHOD used
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_method_of")
		]
		public static extern METHOD* POINT_method_of(POINT* point);

		/** Sets a point to infinity (neutral element)
		 *  \param  group  underlying GROUP object
		 *  \param  point  POINT to set to infinity
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_set_to_infinity")
		]
		public static extern int POINT_set_to_infinity(GROUP* group, POINT* point);

		/** Sets the jacobian projective coordinates of a POINT over GFp
		 *  \param  group  underlying GROUP object
		 *  \param  p      POINT object
		 *  \param  x      BN.BIGNUM with the x-coordinate
		 *  \param  y      BN.BIGNUM with the y-coordinate
		 *  \param  z      BN.BIGNUM with the z-coordinate
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_set_Jprojective_coordinates_GFp")
		]
		public static extern int POINT_set_Jprojective_coordinates_GFp(GROUP* group, POINT* p, BN.BIGNUM* x, BN.BIGNUM* y, BN.BIGNUM* z, BN.CTX* ctx);

		/** Gets the jacobian projective coordinates of a POINT over GFp
		 *  \param  group  underlying GROUP object
		 *  \param  p      POINT object
		 *  \param  x      BN.BIGNUM for the x-coordinate
		 *  \param  y      BN.BIGNUM for the y-coordinate
		 *  \param  z      BN.BIGNUM for the z-coordinate
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_get_Jprojective_coordinates_GFp")
		]
		public static extern int POINT_get_Jprojective_coordinates_GFp(GROUP* group, POINT* p, BN.BIGNUM* x, BN.BIGNUM* y, BN.BIGNUM* z, BN.CTX* ctx);

		/** Sets the affine coordinates of an POINT
		 *  \param  group  underlying GROUP object
		 *  \param  p      POINT object
		 *  \param  x      BN.BIGNUM with the x-coordinate
		 *  \param  y      BN.BIGNUM with the y-coordinate
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_set_affine_coordinates")
		]
		public static extern int POINT_set_affine_coordinates(GROUP* group, POINT* p, BN.BIGNUM* x, BN.BIGNUM* y, BN.CTX* ctx);

		/** Gets the affine coordinates of an POINT.
		 *  \param  group  underlying GROUP object
		 *  \param  p      POINT object
		 *  \param  x      BN.BIGNUM for the x-coordinate
		 *  \param  y      BN.BIGNUM for the y-coordinate
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_get_affine_coordinates")
		]
		public static extern int POINT_get_affine_coordinates(GROUP* group, POINT* p, BN.BIGNUM* x, BN.BIGNUM* y, BN.CTX* ctx);

		/** Sets the affine coordinates of an POINT. A synonym of POINT_set_affine_coordinates
		 *  \param  group  underlying GROUP object
		 *  \param  p      POINT object
		 *  \param  x      BN.BIGNUM with the x-coordinate
		 *  \param  y      BN.BIGNUM with the y-coordinate
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_set_affine_coordinates_GFp")
		]
		public static extern int POINT_set_affine_coordinates_GFp(GROUP* group, POINT* p, BN.BIGNUM* x, BN.BIGNUM* y, BN.CTX* ctx);

		/** Gets the affine coordinates of an POINT. A synonym of POINT_get_affine_coordinates
		 *  \param  group  underlying GROUP object
		 *  \param  p      POINT object
		 *  \param  x      BN.BIGNUM for the x-coordinate
		 *  \param  y      BN.BIGNUM for the y-coordinate
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_get_affine_coordinates_GFp")
		]
		public static extern int POINT_get_affine_coordinates_GFp(GROUP* group, POINT* p, BN.BIGNUM* x, BN.BIGNUM* y, BN.CTX* ctx);

		/** Sets the x9.62 compressed coordinates of a POINT
		 *  \param  group  underlying GROUP object
		 *  \param  p      POINT object
		 *  \param  x      BN.BIGNUM with x-coordinate
		 *  \param  y_bit  integer with the y-Bit (either 0 or 1)
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_set_compressed_coordinates")
		]
		public static extern int POINT_set_compressed_coordinates(GROUP* group, POINT* p, BN.BIGNUM* x, int y_bit, BN.CTX* ctx);

		/** Sets the x9.62 compressed coordinates of a POINT. A synonym of POINT_set_compressed_coordinates
		 *  \param  group  underlying GROUP object
		 *  \param  p      POINT object
		 *  \param  x      BN.BIGNUM with x-coordinate
		 *  \param  y_bit  integer with the y-Bit (either 0 or 1)
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_set_compressed_coordinates_GFp")
		]
		public static extern int POINT_set_compressed_coordinates_GFp(GROUP* group, POINT* p, BN.BIGNUM* x, int y_bit, BN.CTX* ctx);
	#if !OPENSSL_NO_EC2M
		/** Sets the affine coordinates of an POINT. A synonym of POINT_set_affine_coordinates
		 *  \param  group  underlying GROUP object
		 *  \param  p      POINT object
		 *  \param  x      BN.BIGNUM with the x-coordinate
		 *  \param  y      BN.BIGNUM with the y-coordinate
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_set_affine_coordinates_GF2m")
		]
		public static extern int POINT_set_affine_coordinates_GF2m(GROUP* group, POINT* p, BN.BIGNUM* x, BN.BIGNUM* y, BN.CTX* ctx);

		/** Gets the affine coordinates of an POINT. A synonym of POINT_get_affine_coordinates
		 *  \param  group  underlying GROUP object
		 *  \param  p      POINT object
		 *  \param  x      BN.BIGNUM for the x-coordinate
		 *  \param  y      BN.BIGNUM for the y-coordinate
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_get_affine_coordinates_GF2m")
		]
		public static extern int POINT_get_affine_coordinates_GF2m(GROUP* group, POINT* p, BN.BIGNUM* x, BN.BIGNUM* y, BN.CTX* ctx);

		/** Sets the x9.62 compressed coordinates of a POINT. A synonym of POINT_set_compressed_coordinates
		 *  \param  group  underlying GROUP object
		 *  \param  p      POINT object
		 *  \param  x      BN.BIGNUM with x-coordinate
		 *  \param  y_bit  integer with the y-Bit (either 0 or 1)
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_set_compressed_coordinates_GF2m")
		]
		public static extern int POINT_set_compressed_coordinates_GF2m(GROUP* group, POINT* p, BN.BIGNUM* x, int y_bit, BN.CTX* ctx);
	#endif
		/** Encodes a POINT object to a octet string
		 *  \param  group  underlying GROUP object
		 *  \param  p      POINT object
		 *  \param  form   point conversion form
		 *  \param  buf    memory buffer for the result. If NULL the function returns required buffer size.
		 *  \param  len    length of the memory buffer
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return the length of the encoded octet string or 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_point2oct")
		]
		public static extern int POINT_point2oct(GROUP* group, POINT* p, point_conversion_form_t form, uint8* buf, int len, BN.CTX* ctx);

		/** Decodes a POINT from a octet string
		 *  \param  group  underlying GROUP object
		 *  \param  p      POINT object
		 *  \param  buf    memory buffer with the encoded ec point
		 *  \param  len    length of the encoded ec point
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_oct2point")
		]
		public static extern int POINT_oct2point(GROUP* group, POINT* p, uint8* buf, int len, BN.CTX* ctx);

		/** Encodes an POINT object to an allocated octet string
		 *  \param  group  underlying GROUP object
		 *  \param  point  POINT object
		 *  \param  form   point conversion form
		 *  \param  pbuf   returns pointer to allocated buffer
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return the length of the encoded octet string or 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_point2buf")
		]
		public static extern int POINT_point2buf(GROUP* group, POINT* point, point_conversion_form_t form, uint8** pbuf, BN.CTX* ctx);

		/* other interfaces to point2oct/oct2point: */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_point2bn")
		]
		public static extern BN.BIGNUM* POINT_point2bn(GROUP* group, POINT* point, point_conversion_form_t form, BN.BIGNUM* pbuf, BN.CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_bn2point")
		]
		public static extern POINT* POINT_bn2point(GROUP* group, BN.BIGNUM* pbuf, POINT* point, BN.CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_point2hex")
		]
		public static extern char8* POINT_point2hex(GROUP* group, POINT* point, point_conversion_form_t form, BN.CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_hex2point")
		]
		public static extern POINT* POINT_hex2point(GROUP* group, char8* pbuf, POINT* point, BN.CTX* ctx);

		/********************************************************************/
		/*           functions for doing POINT arithmetic                   */
		/********************************************************************/

		/** Computes the sum of two POINT
		 *  \param  group  underlying GROUP object
		 *  \param  r      POINT object for the result (r = a + b)
		 *  \param  a      POINT object with the first summand
		 *  \param  b      POINT object with the second summand
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_add")
		]
		public static extern int POINT_add(GROUP* group, POINT* r, POINT* a, POINT* b, BN.CTX* ctx);

		/** Computes the double of a POINT
		 *  \param  group  underlying GROUP object
		 *  \param  r      POINT object for the result (r = 2 * a)
		 *  \param  a      POINT object
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_dbl")
		]
		public static extern int POINT_dbl(GROUP* group, POINT* r, POINT* a, BN.CTX* ctx);

		/** Computes the inverse of a POINT
		 *  \param  group  underlying GROUP object
		 *  \param  a      POINT object to be inverted (it's used for the result as well)
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_invert")
		]
		public static extern int POINT_invert(GROUP* group, POINT* a, BN.CTX* ctx);

		/** Checks whether the point is the neutral element of the group
		 *  \param  group  the underlying GROUP object
		 *  \param  p      POINT object
		 *  \return 1 if the point is the neutral element and 0 otherwise
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_is_at_infinity")
		]
		public static extern int POINT_is_at_infinity(GROUP* group, POINT* p);

		/** Checks whether the point is on the curve
		 *  \param  group  underlying GROUP object
		 *  \param  point  POINT object to check
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 if the point is on the curve, 0 if not, or -1 on error
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_is_on_curve")
		]
		public static extern int POINT_is_on_curve(GROUP* group, POINT* point, BN.CTX* ctx);

		/** Compares two POINTs
		 *  \param  group  underlying GROUP object
		 *  \param  a      first POINT object
		 *  \param  b      second POINT object
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 if the points are not equal, 0 if they are, or -1 on error
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_cmp")
		]
		public static extern int POINT_cmp(GROUP* group, POINT* a, POINT* b, BN.CTX* ctx);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_make_affine")
		]
		public static extern int POINT_make_affine(GROUP* group, POINT* point, BN.CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINTs_make_affine")
		]
		public static extern int POINTs_make_affine(GROUP* group, int num, POINT*[] points, BN.CTX* ctx);

		/** Computes r = generator * n + sum_{i=0}^{num-1} p[i] * m[i]
		 *  \param  group  underlying GROUP object
		 *  \param  r      POINT object for the result
		 *  \param  n      BN.BIGNUM with the multiplier for the group generator (optional)
		 *  \param  num    number further summands
		 *  \param  p      array of size num of POINT objects
		 *  \param  m      array of size num of BN.BIGNUM objects
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINTs_mul")
		]
		public static extern int POINTs_mul(GROUP* group, POINT* r, BN.BIGNUM* n, int num, POINT*[] p, BN.BIGNUM*[] m, BN.CTX* ctx);

		/** Computes r = generator * n + q * m
		 *  \param  group  underlying GROUP object
		 *  \param  r      POINT object for the result
		 *  \param  n      BN.BIGNUM with the multiplier for the group generator (optional)
		 *  \param  q      POINT object with the first factor of the second summand
		 *  \param  m      BN.BIGNUM with the second factor of the second summand
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_POINT_mul")
		]
		public static extern int POINT_mul(GROUP* group, POINT* r, BN.BIGNUM* n, POINT* q, BN.BIGNUM* m, BN.CTX* ctx);

		/** Stores multiples of generator for faster point multiplication
		 *  \param  group  GROUP object
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_precompute_mult")
		]
		public static extern int GROUP_precompute_mult(GROUP* group, BN.CTX* ctx);

		/** Reports whether a precomputation has been done
		 *  \param  group  GROUP object
		 *  \return 1 if a pre-computation has been done and 0 otherwise
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_have_precompute_mult")
		]
		public static extern int GROUP_have_precompute_mult(GROUP* group);

		/********************************************************************/
		/*                       ASN1 stuff                                 */
		/********************************************************************/

		/* GROUP_get_basis_type() returns the NID of the basis type used to represent the field elements */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get_basis_type")
		]
		public static extern int GROUP_get_basis_type(GROUP* group);
	#if !OPENSSL_NO_EC2M
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get_trinomial_basis")
		]
		public static extern int GROUP_get_trinomial_basis(GROUP* group, uint* k);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_GROUP_get_pentanomial_basis")
		]
		public static extern int GROUP_get_pentanomial_basis(GROUP* group, uint* k1, uint* k2, uint* k3);
	#endif

		/********************************************************************/
		/*                        KEY functions                             */
		/********************************************************************/

		/* some values for the encoding_flag */
		public const int PKEY_NO_PARAMETERS  = 0x001;
		public const int PKEY_NO_PUBKEY      = 0x002;

		/* some values for the flags field */
		public const int FLAG_NON_FIPS_ALLOW = 0x1;
		public const int FLAG_FIPS_CHECKED   = 0x2;
		public const int FLAG_COFACTOR_ECDH  = 0x1000;

		/** Creates a new KEY object.
		 *  \return KEY object or NULL if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_new")
		]
		public static extern KEY* KEY_new();

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_get_flags")
		]
		public static extern int KEY_get_flags(KEY* key);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_set_flags")
		]
		public static extern void KEY_set_flags(KEY* key, int flags);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_clear_flags")
		]
		public static extern void KEY_clear_flags(KEY* key, int flags);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_decoded_from_explicit_params")
		]
		public static extern int KEY_decoded_from_explicit_params(KEY* key);

		/** Creates a new KEY object using a named curve as underlying GROUP object.
		 *  \param  nid  NID of the named curve.
		 *  \return KEY object or NULL if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_new_by_curve_name")
		]
		public static extern KEY* KEY_new_by_curve_name(int nid);

		/** Frees a KEY object.
		 *  \param  key  KEY object to be freed.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_free")
		]
		public static extern void KEY_free(KEY* key);

		/** Copies a KEY object.
		 *  \param  dst  destination KEY object
		 *  \param  src  src KEY object
		 *  \return dst or NULL if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_copy")
		]
		public static extern KEY* KEY_copy(KEY* dst, KEY* src);

		/** Creates a new KEY object and copies the content from src to it.
		 *  \param  src  the source KEY object
		 *  \return newly created KEY object or NULL if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_dup")
		]
		public static extern KEY* KEY_dup(KEY* src);

		/** Increases the internal reference count of a KEY object.
		 *  \param  key  KEY object
		 *  \return 1 on success and 0 if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_up_ref")
		]
		public static extern int KEY_up_ref(KEY* key);

		/** Returns the Engine.ENGINE object of a KEY object
		 *  \param  eckey  KEY object
		 *  \return the Engine.ENGINE object (possibly NULL).
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_get0_engine")
		]
		public static extern Engine.ENGINE* KEY_get0_engine(KEY* eckey);

		/** Returns the GROUP object of a KEY object
		 *  \param  key  KEY object
		 *  \return the GROUP object (possibly NULL).
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_get0_group")
		]
		public static extern GROUP* KEY_get0_group(KEY* key);

		/** Sets the GROUP of a KEY object.
		 *  \param  key    KEY object
		 *  \param  group  GROUP to use in the KEY object (note: the KEY object will use an own copy of the GROUP).
		 *  \return 1 on success and 0 if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_set_group")
		]
		public static extern int KEY_set_group(KEY* key, GROUP* group);

		/** Returns the private key of a KEY object.
		 *  \param  key  KEY object
		 *  \return a BN.BIGNUM with the private key (possibly NULL).
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_get0_private_key")
		]
		public static extern BN.BIGNUM* KEY_get0_private_key(KEY* key);

		/** Sets the private key of a KEY object.
		 *  \param  key  KEY object
		 *  \param  prv  BN.BIGNUM with the private key (note: the KEY object will use an own copy of the BIGNUM).
		 *  \return 1 on success and 0 if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_set_private_key")
		]
		public static extern int KEY_set_private_key(KEY* key, BN.BIGNUM* prv);

		/** Returns the public key of a KEY object.
		 *  \param  key  the KEY object
		 *  \return a POINT object with the public key (possibly NULL)
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_get0_public_key")
		]
		public static extern POINT* KEY_get0_public_key(KEY* key);

		/** Sets the public key of a KEY object.
		 *  \param  key  KEY object
		 *  \param  pub  POINT object with the public key (note: the KEY object will use an own copy of the POINT object).
		 *  \return 1 on success and 0 if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_set_public_key")
		]
		public static extern int KEY_set_public_key(KEY* key, POINT* pub);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_get_enc_flags")
		]
		public static extern uint KEY_get_enc_flags(KEY* key);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_set_enc_flags")
		]
		public static extern void KEY_set_enc_flags(KEY* eckey, uint flags);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_get_conv_form")
		]
		public static extern point_conversion_form_t KEY_get_conv_form(KEY* key);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_set_conv_form")
		]
		public static extern void KEY_set_conv_form(KEY* eckey, point_conversion_form_t cform);

		[Inline]
		public static int KEY_get_ex_new_index(int l, void* p, Crypto.EX_new newf, Crypto.EX_dup dupf, Crypto.EX_free freef) =>
			Crypto.get_ex_new_index(Crypto.EX_INDEX_EC_KEY, l, p, newf, dupf, freef);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_set_ex_data")
		]
		public static extern int KEY_set_ex_data(KEY* key, int idx, void* arg);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_get_ex_data")
		]
		public static extern void* KEY_get_ex_data(KEY* key, int idx);

		/* wrapper functions for the underlying GROUP object */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_set_asn1_flag")
		]
		public static extern void EC_KEY_set_asn1_flag(KEY* eckey, int asn1_flag);

		/** Creates a table of pre-computed multiples of the generator to accelerate further KEY operations.
		 *  \param  key  KEY object
		 *  \param  ctx  BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_precompute_mult")
		]
		public static extern int KEY_precompute_mult(KEY* key, BN.CTX* ctx);

		/** Creates a new ec private (and optional a new public) key.
		 *  \param  key  KEY object
		 *  \return 1 on success and 0 if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_generate_key")
		]
		public static extern int KEY_generate_key(KEY* key);

		/** Verifies that a private and/or public key is valid.
		 *  \param  key  the KEY object
		 *  \return 1 on success and 0 otherwise.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_check_key")
		]
		public static extern int KEY_check_key(KEY* key);

		/** Indicates if an KEY can be used for signing.
		 *  \param  eckey  the KEY object
		 *  \return 1 if can can sign and 0 otherwise.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_can_sign")
		]
		public static extern int KEY_can_sign(KEY* eckey);

		/** Sets a public key from affine coordinates performing necessary NIST PKV tests.
		 *  \param  key  the KEY object
		 *  \param  x    public key x coordinate
		 *  \param  y    public key y coordinate
		 *  \return 1 on success and 0 otherwise.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_set_public_key_affine_coordinates")
		]
		public static extern int KEY_set_public_key_affine_coordinates(KEY* key, BN.BIGNUM* x, BN.BIGNUM* y);

		/** Encodes an KEY public key to an allocated octet string
		 *  \param  key    key to encode
		 *  \param  form   point conversion form
		 *  \param  pbuf   returns pointer to allocated buffer
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return the length of the encoded octet string or 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_key2buf")
		]
		public static extern int KEY_key2buf(KEY* key, point_conversion_form_t form, uint8** pbuf, BN.CTX* ctx);

		/** Decodes a KEY public key from a octet string
		 *  \param  key    key to decode
		 *  \param  buf    memory buffer with the encoded ec point
		 *  \param  len    length of the encoded ec point
		 *  \param  ctx    BN.CTX object (optional)
		 *  \return 1 on success and 0 if an error occurred
		 */

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_oct2key")
		]
		public static extern int KEY_oct2key(KEY* key, uint8* buf, int len, BN.CTX* ctx);

		/** Decodes an KEY private key from an octet string
		 *  \param  key    key to decode
		 *  \param  buf    memory buffer with the encoded private key
		 *  \param  len    length of the encoded key
		 *  \return 1 on success and 0 if an error occurred
		 */

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_oct2priv")
		]
		public static extern int KEY_oct2priv(KEY* key, uint8* buf, int len);

		/** Encodes a KEY private key to an octet string
		 *  \param  key    key to encode
		 *  \param  buf    memory buffer for the result. If NULL the function returns required buffer size.
		 *  \param  len    length of the memory buffer
		 *  \return the length of the encoded octet string or 0 if an error occurred
		 */

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_priv2oct")
		]
		public static extern int KEY_priv2oct(KEY* key, uint8* buf, int len);

		/** Encodes an KEY private key to an allocated octet string
		 *  \param  eckey  key to encode
		 *  \param  pbuf   returns pointer to allocated buffer
		 *  \return the length of the encoded octet string or 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_priv2buf")
		]
		public static extern int KEY_priv2buf(KEY* eckey, uint8** pbuf);

		/********************************************************************/
		/*        de- and encoding functions for SEC1 ECPrivateKey          */
		/********************************************************************/

		/** Decodes a private key from a memory buffer.
		 *  \param  key  a pointer to a KEY object which should be used (or NULL)
		 *  \param  in   pointer to memory with the DER encoded private key
		 *  \param  len  length of the DER encoded private key
		 *  \return the decoded private key or NULL if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public static extern KEY* d2i_ECPrivateKey(KEY** key, uint8** inVal, int len);

		/** Encodes a private key object and stores the result in a buffer.
		 *  \param  key  the KEY object to encode
		 *  \param  out  the buffer for the result (if NULL the function returns number of bytes needed).
		 *  \return 1 on success and 0 if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public static extern int i2d_ECPrivateKey(KEY* key, uint8** outVal);

		/********************************************************************/
		/*         de- and encoding functions for EC public key             */
		/*         (octet string, not DER -- hence 'o2i' and 'i2o')         */
		/********************************************************************/

		/** Decodes a ec public key from a octet string.
		 *  \param  key  a pointer to a KEY object which should be used
		 *  \param  in   memory buffer with the encoded public key
		 *  \param  len  length of the encoded public key
		 *  \return KEY object with decoded public key or NULL if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public static extern KEY* o2i_ECPublicKey(KEY** key, uint8** inVal, int len);

		/** Encodes a ec public key in an octet string.
		 *  \param  key  the KEY object with the public key
		 *  \param  out  the buffer for the result (if NULL the function returns number of bytes needed).
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public static extern int i2o_ECPublicKey(KEY* key, uint8** outVal);

		/** Prints out the contents of a KEY object
		 *  \param  bp   BIO.bio_st object to which the information is printed
		 *  \param  key  KEY object
		 *  \param  off  line offset
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_print")
		]
		public static extern int KEY_print(BIO.bio_st* bp, KEY* key, int off);

	#if !OPENSSL_NO_STDIO
		/** Prints out the contents of a KEY object
		 *  \param  fp   file descriptor to which the information is printed
		 *  \param  key  KEY object
		 *  \param  off  line offset
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_print_fp")
		]
		public static extern int KEY_print_fp(Platform.BfpFile* fp, KEY* key, int off);
	#endif

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_OpenSSL")
		]
		public static extern KEY_METHOD* KEY_OpenSSL();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_get_default_method")
		]
		public static extern KEY_METHOD* KEY_get_default_method();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_set_default_method")
		]
		public static extern void KEY_set_default_method(KEY_METHOD* meth);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_get_method")
		]
		public static extern KEY_METHOD* KEY_get_method(KEY* key);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_set_method")
		]
		public static extern int KEY_set_method(KEY* key, KEY_METHOD* meth);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_new_method")
		]
		public static extern KEY* KEY_new_method(Engine.ENGINE* engine);

		/********************************************************************/
		/*    KEY_METHOD constructors, destructors, writers and accessors   */
		/********************************************************************/

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_METHOD_new")
		]
		public static extern KEY_METHOD* KEY_METHOD_new(KEY_METHOD* meth);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_METHOD_free")
		]
		public static extern void KEY_METHOD_free(KEY_METHOD* meth);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_METHOD_set_init")
		]
		public static extern void KEY_METHOD_set_init(KEY_METHOD* meth, function int(KEY* key) init, function void(KEY* key) finish, function int(KEY* dest, KEY* src) copy, function int(KEY* key, GROUP* grp) set_group,
			function int(KEY* key, BN.BIGNUM* priv_key) set_private, function int(KEY* key, POINT* pub_key) set_public);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_METHOD_set_keygen")
		]
		public static extern void KEY_METHOD_set_keygen(KEY_METHOD* meth, function int(KEY* key) keygen);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_METHOD_set_compute_key")
		]
		public static extern void KEY_METHOD_set_compute_key(KEY_METHOD* meth, function int(uint8** psec, int *pseclen, POINT* pub_key, KEY* ecdh) ckey);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_METHOD_set_sign")
		]
		public static extern void KEY_METHOD_set_sign(KEY_METHOD* meth, function int(int type, uint8* dgst, int dlen, uint8* sig, uint* siglen, BN.BIGNUM* kinv, BN.BIGNUM* r, KEY* eckey) sign,
			function int(KEY* eckey, BN.CTX* ctx_in, BN.BIGNUM** kinvp, BN.BIGNUM** rp) sign_setup, function ECDSA.SIG*(uint8* dgst, int dgst_len, BN.BIGNUM* in_kinv, BN.BIGNUM* in_r, KEY* eckey) sign_sig);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_METHOD_set_verify")
		]
		public static extern void KEY_METHOD_set_verify(KEY_METHOD* meth, function int(int type, uint8* dgst, int dgst_len, uint8* sigbuf, int sig_len, KEY* eckey) verify,
			function int(uint8* dgst, int dgst_len, ECDSA.SIG* sig, KEY* eckey) verify_sig);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_METHOD_get_init")
		]
		public static extern void KEY_METHOD_get_init(KEY_METHOD* meth, function int(KEY* key)* pinit, function void(KEY* key)* pfinish, function int(KEY* dest, KEY* src)* pcopy, function int(KEY* key, GROUP* grp)* pset_group,
			function int(KEY* key, BN.BIGNUM* priv_key)* pset_private, function int(KEY* key, POINT* pub_key)* pset_public);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_METHOD_get_keygen")
		]
		public static extern void KEY_METHOD_get_keygen(KEY_METHOD* meth, function int(KEY* key)* pkeygen);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_METHOD_get_compute_key")
		]
		public static extern void KEY_METHOD_get_compute_key(KEY_METHOD* meth, function int(uint8** psec, int *pseclen, POINT* pub_key, KEY* ecdh)* pck);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_METHOD_get_sign")
		]
		public static extern void KEY_METHOD_get_sign(KEY_METHOD* meth, function int(int type, uint8* dgst, int dlen, uint8* sig, uint* siglen, BN.BIGNUM* kinv, BN.BIGNUM* r, KEY* eckey)* psign,
			function int(KEY* eckey, BN.CTX* ctx_in, BN.BIGNUM** kinvp, BN.BIGNUM** rp)* psign_setup, function ECDSA.SIG*(uint8* dgst, int dgst_len, BN.BIGNUM* in_kinv, BN.BIGNUM* in_r, KEY* eckey)* psign_sig);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("EC_KEY_METHOD_get_verify")
		]
		public static extern void KEY_METHOD_get_verify(KEY_METHOD* meth, function int(int type, uint8* dgst, int dgst_len, uint8* sigbuf, int sig_len, KEY* eckey)* pverify,
			function int(uint8* dgst, int dgst_len, ECDSA.SIG* sig, KEY* eckey)* pverify_sig);
#endif
	}

	[AlwaysInclude]
	sealed abstract class ECParameters
	{
#if !OPENSSL_NO_EC
		/********************************************************************/
		/*        de- and encoding functions for EC parameters              */
		/********************************************************************/

		/** Decodes ec parameter from a memory buffer.
		 *  \param  key  a pointer to a KEY object which should be used (or NULL)
		 *  \param  in   pointer to memory with the DER encoded ec parameters
		 *  \param  len  length of the DER encoded ec parameters
		 *  \return a KEY object with the decoded parameters or NULL if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public static extern EC.KEY* d2i_ECParameters(EC.KEY** key, uint8** inVal, int len);

		/** Encodes ec parameter and stores the result in a buffer.
		 *  \param  key  the KEY object with ec parameters to encode
		 *  \param  out  the buffer for the result (if NULL the function returns number of bytes needed).
		 *  \return 1 on success and 0 if an error occurred.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public static extern int i2d_ECParameters(EC.KEY* key, uint8** outVal);

		/** Prints out the ec parameters on human readable form.
		 *  \param  bp   BIO.bio_st object to which the information is printed
		 *  \param  key  KEY object
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECParameters_print")
		]
		public static extern int print(BIO.bio_st* bp, EC.KEY* key);

	#if !OPENSSL_NO_STDIO
		/** Prints out the ec parameters on human readable form.
		 *  \param  fp   file descriptor to which the information is printed
		 *  \param  key  KEY object
		 *  \return 1 on success and 0 if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECParameters_print_fp")
		]
		public static extern int print_fp(Platform.BfpFile* fp, EC.KEY* key);
	#endif

		[Inline]
		public static EC.KEY* dup(EC.KEY* x)
		{
			int internalF1(void* p, uint8** n) => i2d_ECParameters((EC.KEY*)p, n);
			void* internalF2(void** p, uint8** n, int l) => d2i_ECParameters((EC.KEY**)p, n, l);
			return (EC.KEY*)ASN1.dup(=> internalF1, => internalF2, (void*)x);
		}
#endif
	}

	[AlwaysInclude]
	sealed abstract class ECPKParameters
	{
#if !OPENSSL_NO_EC
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public static extern EC.GROUP* d2i_ECPKParameters(EC.GROUP** group, uint8** inVal, int len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public static extern int i2d_ECPKParameters(EC.GROUP* group, uint8** outVal);

		[Inline]
		public static EC.GROUP* d2i_ECPKParameters_bio(BIO.bio_st* bp, EC.GROUP* x)
		{
			void* internalF(void** p, uint8** n, int l) => (void*)d2i_ECPKParameters((EC.GROUP**)p, n, l);
			return (EC.GROUP*)ASN1.d2i_bio(null, => internalF, bp, (void**)x);
		}
		[Inline]
		public static int i2d_ECPKParameters_bio(BIO.bio_st* bp, EC.GROUP* x)
		{
			int internalF(void* p, uint8** n) => i2d_ECPKParameters((EC.GROUP*)p, n);
			return ASN1.i2d_bio(=> internalF, bp, (uint8*)x);
		}
		[Inline]
		public static EC.GROUP* d2i_ECPKParameters_fp(Platform.BfpFile* fp, EC.GROUP** x)
		{
			void* internalF(void** p, uint8** n, int l) => (void*)d2i_ECPKParameters((EC.GROUP**)p, n, l);
			return (EC.GROUP*)ASN1.d2i_fp(null, => internalF, fp, (void**)x);
		}
		[Inline]
		public static int i2d_ECPKParameters_fp(Platform.BfpFile* fp, EC.GROUP* x)
		{
			int internalF(void* p, uint8** n) => i2d_ECPKParameters((EC.GROUP*)p, n);
			return ASN1.i2d_fp(=> internalF, fp, (uint8*)x);
		}

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECPKParameters_print")
		]
		public static extern int print(BIO.bio_st* bp, EC.GROUP* x, int off);
	#if !OPENSSL_NO_STDIO
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECPKParameters_print_fp")
		]
		public static extern int print_fp(Platform.BfpFile* fp, EC.GROUP* x, int off);
	#endif
#endif
	}

	[AlwaysInclude]
	sealed abstract class ECX
	{
#if !OPENSSL_NO_EC
		public const int X25519_KEYLEN = 32;
		public const int X448_KEYLEN   = 56;
		public const int ED448_KEYLEN  = 57;
		public const int MAX_KEYLEN    = ED448_KEYLEN;

		[CRepr]
		public struct key_st
		{
		    public uint8[MAX_KEYLEN] pubkey;
		    public uint8* privkey;
		}
		public typealias KEY = key_st;
#endif
	}
	
	[AlwaysInclude]
	sealed abstract class ECDH
	{
#if !OPENSSL_NO_EC
		/** The old name for ecdh_KDF_X9_63 The ECDH KDF specification has been mistakingly attributed to ANSI X9.62, it is actually specified in ANSI X9.63.
		 *  This identifier is retained for backwards compatibility
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECDH_KDF_X9_62")
		]
		public static extern int KDF_X9_62(uint8* outVal, int outlen, uint8* Z, int Zlen, uint8* sinfo, int sinfolen, EVP.MD* md);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECDH_compute_key")
		]
		public static extern int compute_key(void* outVal, int outlen, EC.POINT* pub_key, EC.KEY* ecdh, function void*(void* inVal, int inlen, void* outVal, int* outlen) KDF);
#endif
	}
	
	[AlwaysInclude]
	sealed abstract class ECDSA
	{
#if !OPENSSL_NO_EC
		[CRepr]
		public struct SIG_st
		{
		    public BN.BIGNUM* r;
		    public BN.BIGNUM* s;
		}
		public typealias SIG = SIG_st;

		/** Allocates and initialize a SIG structure
		 *  \return pointer to a SIG structure or NULL if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECDSA_SIG_new")
		]
		public static extern SIG* SIG_new();

		/** frees a SIG structure
		 *  \param  sig  pointer to the SIG structure
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECDSA_SIG_free")
		]
		public static extern void SIG_free(SIG* sig);

		/** DER encode content of SIG object (note: this function modifies *pp (*pp += length of the DER encoded signature)).
		 *  \param  sig  pointer to the SIG object
		 *  \param  pp   pointer to a unsigned char pointer for the output or NULL
		 *  \return the length of the DER encoded SIG object or a negative value on error
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public static extern int i2d_ECDSA_SIG(SIG* sig, uint8** pp);

		/** Decodes a DER encoded ECDSA signature (note: this function changes *pp (*pp += len)).
		 *  \param  sig  pointer to SIG pointer (may be NULL)
		 *  \param  pp   memory buffer with the DER encoded signature
		 *  \param  len  length of the buffer
		 *  \return pointer to the decoded SIG structure (or NULL)
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			CLink
		]
		public static extern SIG* d2i_ECDSA_SIG(SIG** sig, uint8** pp, int len);

		/** Accessor for r and s fields of SIG
		 *  \param  sig  pointer to SIG structure
		 *  \param  pr   pointer to BN.BIGNUM pointer for r (may be NULL)
		 *  \param  ps   pointer to BN.BIGNUM pointer for s (may be NULL)
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECDSA_SIG_get0")
		]
		public static extern void SIG_get0(SIG* sig, BN.BIGNUM** pr, BN.BIGNUM** ps);

		/** Accessor for r field of SIG
		 *  \param  sig  pointer to SIG structure
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECDSA_SIG_get0_r")
		]
		public static extern BN.BIGNUM* SIG_get0_r(SIG* sig);

		/** Accessor for s field of SIG
		 *  \param  sig  pointer to SIG structure
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECDSA_SIG_get0_s")
		]
		public static extern BN.BIGNUM* SIG_get0_s(SIG* sig);

		/** Setter for r and s fields of SIG
		 *  \param  sig  pointer to SIG structure
		 *  \param  r    pointer to BN.BIGNUM for r (may be NULL)
		 *  \param  s    pointer to BN.BIGNUM for s (may be NULL)
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECDSA_SIG_set0")
		]
		public static extern int SIG_set0(SIG* sig, BN.BIGNUM* r, BN.BIGNUM* s);

		/** Computes the ECDSA signature of the given hash value using the supplied private key and returns the created signature.
		 *  \param  dgst      pointer to the hash value
		 *  \param  dgst_len  length of the hash value
		 *  \param  eckey     EC.KEY object containing a private EC key
		 *  \return pointer to a SIG structure or NULL if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECDSA_do_sign")
		]
		public static extern SIG* do_sign(uint8* dgst, int dgst_len, EC.KEY* eckey);

		/** Computes ECDSA signature of a given hash value using the supplied private key (note: sig must point to size(eckey) bytes of memory).
		 *  \param  dgst     pointer to the hash value to sign
		 *  \param  dgstlen  length of the hash value
		 *  \param  kinv     BN.BIGNUM with a pre-computed inverse k (optional)
		 *  \param  rp       BN.BIGNUM with a pre-computed rp value (optional), see sign_setup
		 *  \param  eckey    EC.KEY object containing a private EC key
		 *  \return pointer to a SIG structure or NULL if an error occurred
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECDSA_do_sign_ex")
		]
		public static extern SIG* do_sign_ex(uint8* dgst, int dgstlen, BN.BIGNUM* kinv, BN.BIGNUM* rp, EC.KEY* eckey);

		/** Verifies that the supplied signature is a valid ECDSA signature of the supplied hash value using the supplied public key.
		 *  \param  dgst      pointer to the hash value
		 *  \param  dgst_len  length of the hash value
		 *  \param  sig       SIG structure
		 *  \param  eckey     EC.KEY object containing a public EC key
		 *  \return 1 if the signature is valid, 0 if the signature is invalid and -1 on error
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECDSA_do_verify")
		]
		public static extern int do_verify(uint8* dgst, int dgst_len, SIG* sig, EC.KEY* eckey);

		/** Precompute parts of the signing operation
		 *  \param  eckey  EC.KEY object containing a private EC key
		 *  \param  ctx    BN.CTX object (optional)
		 *  \param  kinv   BN.BIGNUM pointer for the inverse of k
		 *  \param  rp     BN.BIGNUM pointer for x coordinate of k * generator
		 *  \return 1 on success and 0 otherwise
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECDSA_sign_setup")
		]
		public static extern int sign_setup(EC.KEY* eckey, BN.CTX* ctx, BN.BIGNUM** kinv, BN.BIGNUM** rp);

		/** Computes ECDSA signature of a given hash value using the supplied private key (note: sig must point to size(eckey) bytes of memory).
		 *  \param  type     this parameter is ignored
		 *  \param  dgst     pointer to the hash value to sign
		 *  \param  dgstlen  length of the hash value
		 *  \param  sig      memory for the DER encoded created signature
		 *  \param  siglen   pointer to the length of the returned signature
		 *  \param  eckey    EC.KEY object containing a private EC key
		 *  \return 1 on success and 0 otherwise
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECDSA_sign")
		]
		public static extern int sign(int type, uint8* dgst, int dgstlen, uint8* sig, uint* siglen, EC.KEY* eckey);

		/** Computes ECDSA signature of a given hash value using the supplied private key (note: sig must point to size(eckey) bytes of memory).
		 *  \param  type     this parameter is ignored
		 *  \param  dgst     pointer to the hash value to sign
		 *  \param  dgstlen  length of the hash value
		 *  \param  sig      buffer to hold the DER encoded signature
		 *  \param  siglen   pointer to the length of the returned signature
		 *  \param  kinv     BN.BIGNUM with a pre-computed inverse k (optional)
		 *  \param  rp       BN.BIGNUM with a pre-computed rp value (optional), see sign_setup
		 *  \param  eckey    EC.KEY object containing a private EC key
		 *  \return 1 on success and 0 otherwise
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECDSA_sign_ex")
		]
		public static extern int sign_ex(int type, uint8* dgst, int dgstlen, uint8* sig, uint* siglen, BN.BIGNUM* kinv, BN.BIGNUM* rp, EC.KEY* eckey);

		/** Verifies that the given signature is valid ECDSA signature of the supplied hash value using the specified public key.
		 *  \param  type     this parameter is ignored
		 *  \param  dgst     pointer to the hash value
		 *  \param  dgstlen  length of the hash value
		 *  \param  sig      pointer to the DER encoded signature
		 *  \param  siglen   length of the DER encoded signature
		 *  \param  eckey    EC.KEY object containing a public EC key
		 *  \return 1 if the signature is valid, 0 if the signature is invalid and -1 on error
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECDSA_verify")
		]
		public static extern int verify(int type, uint8* dgst, int dgstlen, uint8* sig, int siglen, EC.KEY* eckey);

		/** Returns the maximum length of the DER encoded signature
		 *  \param  eckey  EC. KEY object
		 *  \return numbers of bytes required for the DER encoded signature
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("ECDSA_size")
		]
		public static extern int size(EC.KEY* eckey);
#endif
	}
}
