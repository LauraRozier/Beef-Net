/*
* Generated by util/mkerr.pl DO NOT EDIT
* Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.
*
* Licensed under the OpenSSL license (the "License").  You may not use
* this file except in compliance with the License.  You can obtain a copy
* in the file LICENSE in the source distribution or at
* https://www.openssl.org/source/license.html
*/
using System;

namespace Beef_Net.OpenSSL
{
	sealed abstract class SSLeay
	{
		/* SSLeay compat */
		public const int VERSION_NUMBER = OpenSSL.VERSION_NUMBER;

		public const int VERSION        = OpenSSL.VERSION;
		public const int CFLAGS         = OpenSSL.CFLAGS;
		public const int BUILT_ON       = OpenSSL.BUILT_ON;
		public const int PLATFORM       = OpenSSL.PLATFORM;
		public const int DIR            = OpenSSL.DIR;
		
		[Inline]
		public uint SSLeay()            => OpenSSL.version_num();
		[Inline]
		public char8* version(int type) => OpenSSL.version(type);
		[Inline]
		public static void add_ssl_algorithms() => SSL.library_init();
	}

	sealed abstract class OpenSSL
	{
		public const int VERSION     = 0;
		public const int CFLAGS      = 1;
		public const int BUILT_ON    = 2;
		public const int PLATFORM    = 3;
		public const int DIR         = 4;
		public const int ENGINES_DIR = 5;

		/*-
		 * Numeric release version identifier:
		 * MNNFFPPS: major minor fix patch status The status nibble has one of the values 0 for development, 1 to e for betas 1 to 14, and f for release.  The patch level is exactly that.
		 * For example:
		 * 0.9.3-dev       0x00903000
		 * 0.9.3-beta1     0x00903001
		 * 0.9.3-beta2-dev 0x00903002
		 * 0.9.3-beta2     0x00903002 (same as ...beta2-dev)
		 * 0.9.3           0x0090300f
		 * 0.9.3a          0x0090301f
		 * 0.9.4           0x0090400f
		 * 1.2.3z          0x102031af
		 *
		 * For continuity reasons (because 0.9.5 is already out, and is coded 0x00905100), between 0.9.5 and 0.9.6 the coding of the patch level part is slightly different, by setting the highest bit.  This means
		 * that 0.9.5a looks like this: 0x0090581f.  At 0.9.6, we can start with 0x0090600S...
		 *
		 * (Prior to 0.9.3-dev a different scheme was used: 0.9.2b is 0x0922.) (Prior to 0.9.5a beta1, a different scheme was used: MMNNFFRBB for major minor fix final patch/beta)
		 */
		public const int VERSION_NUMBER  = 0x1010108FL;
		public const char8* VERSION_TEXT = "OpenSSL 1.1.1h  22 Sep 2020";

		public const int MIN_API         = 0;
		public const int API_COMPAT      = MIN_API;

		public const char8* FILE         = "";
		public const int LINE            = 0;

		[Inline, Obsolete("No longer needed, so this is a no-op", true)]
		public static void malloc_init() { while(false) continue; }

		[Inline]
		public static void* malloc(uint num) => Crypto.malloc(num, FILE, LINE);

		[Inline]
		public static void* zalloc(uint num) => Crypto.zalloc(num, FILE, LINE);

		[Inline]
		public static void* realloc(void* addr, uint num) => Crypto.realloc(addr, num, FILE, LINE);

		[Inline]
		public static void* clear_realloc(void* addr, uint old_num, uint num) => Crypto.clear_realloc(addr, old_num, num, FILE, LINE);

		[Inline]
		public static void clear_free(void* addr, uint num) => Crypto.clear_free(addr, num, FILE, LINE);

		[Inline]
		public static void free(void* addr) => Crypto.free(addr, FILE, LINE);

		[Inline]
		public static void* memdup(void* data, uint size) => Crypto.memdup(data, size, FILE, LINE);

		[Inline]
		public static char8* strdup(char8* str) => Crypto.strdup(str, FILE, LINE);

		[Inline]
		public static char8* strndup(char8* str, uint n) => Crypto.strndup(str, n, FILE, LINE);

		[Inline]
		public static void* secure_malloc(uint num) => Crypto.secure_malloc(num, FILE, LINE);

		[Inline]
		public static void* secure_zalloc(uint num) => Crypto.secure_zalloc(num, FILE, LINE);

		[Inline]
		public static void secure_free(void* addr) => Crypto.secure_free(addr, FILE, LINE);

		[Inline]
		public static void secure_clear_free(void* addr, uint num) => Crypto.secure_clear_free(addr, num, FILE, LINE);

		[Inline]
		public static uint secure_actual_size(void* ptr) => Crypto.secure_actual_size(ptr);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_strlcpy")
		]
		public extern static uint strlcpy(char8* dst, char8* src, uint size);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_strlcat")
		]
		public extern static uint strlcat(char8* dst, char8* src, uint size);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_strnlen")
		]
		public extern static uint strnlen(char8* str, uint maxlen);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_buf2hexstr")
		]
		public extern static char8* buf2hexstr(uint8* buffer, int len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_hexstr2buf")
		]
		public extern static uint8* hexstr2buf(char8* str, int* len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_hexchar2int")
		]
		public extern static int hexchar2int(uint8 c);

		[Inline]
		public static uint MALLOC_MAX_NELEMS<T>() => ((1U << (sizeof(int) * 8 - 1)) - 1) / (uint32)sizeof(T);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OpenSSL_version_num")
		]
		public extern static uint version_num();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OpenSSL_version")
		]
		public extern static char8* version(int type);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_issetugid")
		]
		public extern static int issetugid();

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_cleanse")
		]
		public extern static void cleanse(void* ptr, uint len);

		/* die if we have to */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_die"),
			NoReturn
		]
		public extern static void die(char8* assertion, char8* file, int line);
		[Inline]
		public static void OpenSSLDie(char8* f, int l, char8* a) => die(a, f, l);
		[Inline]
		public static void assert(bool check, StringView msg)
		{
			if (!check) {
				String tmp = scope:: .();
				tmp.AppendF("assertion failed: {}", msg);
				die(tmp.CStr(), FILE, LINE);
			}
		}

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_isservice")
		]
		public extern static int isservice();

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_init")
		]
		public extern static void init();

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_gmtime")
		]
		public extern static OSSLType.tm* gmtime(int64* timer, OSSLType.tm* result);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_gmtime_adj")
		]
		public extern static int gmtime_adj(OSSLType.tm* tm, int offset_day, int offset_sec);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_gmtime_diff")
		]
		public extern static int gmtime_diff(int* pday, int* psec, OSSLType.tm* from, OSSLType.tm* to);

		/* Standard initialisation options */
		public const int INIT_NO_LOAD_CRYPTO_STRINGS = 0x00000001L;
		public const int INIT_LOAD_CRYPTO_STRINGS    = 0x00000002L;
		public const int INIT_ADD_ALL_CIPHERS        = 0x00000004L;
		public const int INIT_ADD_ALL_DIGESTS        = 0x00000008L;
		public const int INIT_NO_ADD_ALL_CIPHERS     = 0x00000010L;
		public const int INIT_NO_ADD_ALL_DIGESTS     = 0x00000020L;
		public const int INIT_LOAD_CONFIG            = 0x00000040L;
		public const int INIT_NO_LOAD_CONFIG         = 0x00000080L;
		public const int INIT_ASYNC                  = 0x00000100L;
		public const int INIT_ENGINE_RDRAND          = 0x00000200L;
		public const int INIT_ENGINE_DYNAMIC         = 0x00000400L;
		public const int INIT_ENGINE_OPENSSL         = 0x00000800L;
		public const int INIT_ENGINE_CRYPTODEV       = 0x00001000L;
		public const int INIT_ENGINE_CAPI            = 0x00002000L;
		public const int INIT_ENGINE_PADLOCK         = 0x00004000L;
		public const int INIT_ENGINE_AFALG           = 0x00008000L;
		/* public const int INIT_ZLIB                   = 0x00010000L; */
		public const int INIT_ATFORK                 = 0x00020000L;
		/* public const int INIT_BASE_ONLY              = 0x00040000L; */
		public const int INIT_NO_ATEXIT              = 0x00080000L;
		/* INIT flag range 0xfff00000 reserved for init_ssl() */
		/* Max INIT flag value is 0x80000000 */

		/* openssl and dasync not counted as builtin */
		public const int INIT_ENGINE_ALL_BUILTIN = INIT_ENGINE_RDRAND | INIT_ENGINE_DYNAMIC | INIT_ENGINE_CRYPTODEV | INIT_ENGINE_CAPI | INIT_ENGINE_PADLOCK;

		[CRepr]
		public struct init_settings_st
		{
		    public char8* filename;
		    public char8* appname;
		    public uint flags;
		}
		public typealias INIT_SETTINGS = init_settings_st;

		/* Library initialisation functions */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_cleanup")
		]
		public extern static void cleanup();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_init_crypto")
		]
		public extern static int init_crypto(uint64 opts, INIT_SETTINGS* settings);
		function void atexit_handler();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_atexit")
		]
		public extern static int atexit(atexit_handler handler);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_thread_stop")
		]
		public extern static void thread_stop();

		/* Low-level control of initialization */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_INIT_new")
		]
		public extern static INIT_SETTINGS* INIT_new();
#if !OPENSSL_NO_STDIO
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_INIT_set_config_filename")
		]
		public extern static int INIT_set_config_filename(INIT_SETTINGS* settings, char8* config_filename);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_INIT_set_config_file_flags")
		]
		public extern static void INIT_set_config_file_flags(INIT_SETTINGS* settings, uint flags);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_INIT_set_config_appname")
		]
		public extern static int INIT_set_config_appname(INIT_SETTINGS* settings, char8* config_appname);
#endif
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_INIT_free")
		]
		public extern static void INIT_free(INIT_SETTINGS* settings);

		[Inline]
		public static int add_all_algorithms_conf() => init_crypto(INIT_ADD_ALL_CIPHERS | INIT_ADD_ALL_DIGESTS | INIT_LOAD_CONFIG, null);
		[Inline]
		public static int add_all_algorithms_noconf() => init_crypto(INIT_ADD_ALL_CIPHERS | INIT_ADD_ALL_DIGESTS, null);

#if OPENSSL_LOAD_CONF
		[Inline]
		public static int add_all_algorithms() => add_all_algorithms_conf();
#else
		[Inline]
		public static int add_all_algorithms() => add_all_algorithms_noconf();
#endif

		[Inline]
		public static int add_all_ciphers() => init_crypto(INIT_ADD_ALL_CIPHERS, null);
		[Inline]
		public static int add_all_digests() => init_crypto(INIT_ADD_ALL_DIGESTS, null);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_config")
		]
		public extern static void config(char8* config_name);

		[Inline]
		public static int no_config() => init_crypto(INIT_NO_LOAD_CONFIG, null);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_load_builtin_modules")
		]
		public extern static void load_builtin_modules();

#if !OPENSSL_DH_MAX_MODULUS_BITS
		public const int DH_MAX_MODULUS_BITS      = 10000;
#endif
		public const int DH_FIPS_MIN_MODULUS_BITS = 1024;

#if !OPENSSL_DSA_MAX_MODULUS_BITS
		public const int DSA_MAX_MODULUS_BITS      = 10000;
#endif
		public const int DSA_FIPS_MIN_MODULUS_BITS = 1024;

		public const int EC_EXPLICIT_CURVE = 0x000;
		public const int EC_NAMED_CURVE    = 0x001;

		public const int ECC_MAX_FIELD_BITS = 661;

		public function int LH_COMPFUNC(void* a, void* b);
		public function uint LH_HASHFUNC(void* p);
		public function void LH_DOALL_FUNC(void* p);
		public function void LH_DOALL_FUNCARG(void* a, void* b);

		public typealias LHASH = LHash.lhash_st;
		public typealias LH_NODE = LHash.node_st;

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_error")
		]
		public extern static int LH_error(LHash.lhash_st* lh);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_new")
		]
		public extern static LHash.lhash_st* LH_new(LH_HASHFUNC h, LH_COMPFUNC c);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_free")
		]
		public extern static void LH_free(LHash.lhash_st* lh);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_insert")
		]
		public extern static void* LH_insert(LHash.lhash_st* lh, void* data);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_delete")
		]
		public extern static void* LH_delete(LHash.lhash_st* lh, void* data);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_retrieve")
		]
		public extern static void* LH_retrieve(LHash.lhash_st* lh, void* data);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_doall")
		]
		public extern static void LH_doall(LHash.lhash_st* lh, LH_DOALL_FUNC func);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_doall_arg")
		]
		public extern static void LH_doall_arg(LHash.lhash_st* lh, LH_DOALL_FUNCARG func, void* arg);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_strhash")
		]
		public extern static uint LH_strhash(char8* c);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_num_items")
		]
		public extern static uint LH_num_items(LHash.lhash_st* lh);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_get_down_load")
		]
		public extern static uint LH_get_down_load(LHash.lhash_st* lh);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_set_down_load")
		]
		public extern static void LH_set_down_load(LHash.lhash_st* lh, uint down_load);

#if !OPENSSL_NO_STDIO
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_stats")
		]
		public extern static void LH_stats(LHash.lhash_st* lh, Platform.BfpFile* fp);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_node_stats")
		]
		public extern static void LH_node_stats(LHash.lhash_st* lh, Platform.BfpFile* fp);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_node_usage_stats")
		]
		public extern static void LH_node_usage_stats(LHash.lhash_st* lh, Platform.BfpFile* fp);
#endif
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_stats_bio")
		]
		public extern static void LH_stats_bio(LHash.lhash_st* lh, BIO.bio_st* outVal);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_node_stats_bio")
		]
		public extern static void LH_node_stats_bio(LHash.lhash_st* lh, BIO.bio_st* outVal);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_LH_node_usage_stats_bio")
		]
		public extern static void LH_node_usage_stats_bio(LHash.lhash_st* lh, BIO.bio_st* outVal);
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_asc2uni")
		]
		public extern static uint8* asc2uni(char8* asc, int asclen, uint8** uni, int* unilen);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_uni2asc")
		]
		public extern static char8* uni2asc(uint8* uni, int unilen);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_utf82uni")
		]
		public extern static uint8* utf82uni(char8* asc, int asclen, uint8** uni, int* unilen);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_uni2utf8")
		]
		public extern static char8* uni2utf8(uint8* uni, int unilen);
		
#if !OPENSSL_NO_RSA
		/* The types RSA and RSA_METHOD are defined in ossl_typ.h */
		public const int RSA_MAX_MODULUS_BITS      = 16384;
		public const int RSA_FIPS_MIN_MODULUS_BITS = 1024;
		public const int RSA_SMALL_MODULUS_BITS    = 3072;
		/* exponent limit enforced for "large" modulus only */
		public const int RSA_MAX_PUBEXP_BITS       = 64;
#endif

		public function int sk_compfunc(void* a, void* b);
		public function void sk_freefunc(void* a);
		public function void* sk_copyfunc(void* a);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_num")
		]
		public extern static int sk_num(Stack.OPENSSL_STACK* st);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_value")
		]
		public extern static void* sk_value(Stack.OPENSSL_STACK* st, int i);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_set")
		]
		public extern static void* sk_set(Stack.OPENSSL_STACK* st, int i, void* data);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_new")
		]
		public extern static Stack.OPENSSL_STACK* sk_new(sk_compfunc cmp);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_new_null")
		]
		public extern static Stack.OPENSSL_STACK* sk_new_null();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_new_reserve")
		]
		public extern static Stack.OPENSSL_STACK* sk_new_reserve(sk_compfunc c, int n);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_reserve")
		]
		public extern static int sk_reserve(Stack.OPENSSL_STACK* st, int n);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_free")
		]
		public extern static void sk_free(Stack.OPENSSL_STACK* st);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_pop_free")
		]
		public extern static void sk_pop_free(Stack.OPENSSL_STACK* st, function void(void*) func);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_deep_copy")
		]
		public extern static Stack.OPENSSL_STACK* sk_deep_copy(Stack.OPENSSL_STACK* st, sk_copyfunc c, sk_freefunc f);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_insert")
		]
		public extern static int sk_insert(Stack.OPENSSL_STACK* sk, void* data, int where_);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_delete")
		]
		public extern static void* sk_delete(Stack.OPENSSL_STACK* st, int loc);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_delete_ptr")
		]
		public extern static void* sk_delete_ptr(Stack.OPENSSL_STACK* st, void* p);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_find")
		]
		public extern static int sk_find(Stack.OPENSSL_STACK* st, void* data);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_find_ex")
		]
		public extern static int sk_find_ex(Stack.OPENSSL_STACK* st, void* data);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_push")
		]
		public extern static int sk_push(Stack.OPENSSL_STACK* st, void* data);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_unshift")
		]
		public extern static int sk_unshift(Stack.OPENSSL_STACK* st, void* data);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_shift")
		]
		public extern static void* sk_shift(Stack.OPENSSL_STACK* st);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_pop")
		]
		public extern static void* sk_pop(Stack.OPENSSL_STACK* st);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_zero")
		]
		public extern static void sk_zero(Stack.OPENSSL_STACK* st);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_set_cmp_func")
		]
		public extern static sk_compfunc sk_set_cmp_func(Stack.OPENSSL_STACK* sk, sk_compfunc cmp);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_dup")
		]
		public extern static Stack.OPENSSL_STACK* sk_dup(Stack.OPENSSL_STACK* st);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_sort")
		]
		public extern static void sk_sort(Stack.OPENSSL_STACK* st);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OPENSSL_sk_is_sorted")
		]
		public extern static int sk_is_sorted(Stack.OPENSSL_STACK* st);

		[CRepr]
		public struct dir_context_st {} // Too platform dependent
		public typealias DIR_CTX = dir_context_st;

		/*
		** MOVED for convenience
		** libssl-1_1.dll
		**	  20   13 0000180C OPENSSL_cipher_name
		**	  21   14 00002059 OPENSSL_init_ssl
		*/
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_SSL),
#endif
			LinkName("OPENSSL_cipher_name")
		]
		public extern static char8* cipher_name(char8* rfc_name);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_SSL),
#endif
			LinkName("OPENSSL_init_ssl")
		]
		public extern static int init_ssl(uint64 opts, INIT_SETTINGS* settings);

		/* OPENSSL_INIT flag 0x010000 reserved for internal use */
		public const int INIT_NO_LOAD_SSL_STRINGS = 0x00100000L;
		public const int INIT_LOAD_SSL_STRINGS    = 0x00200000L;

		public const int INIT_SSL_DEFAULT         = INIT_LOAD_SSL_STRINGS | INIT_LOAD_CRYPTO_STRINGS;

		public const int NPN_UNSUPPORTED = 0;
		public const int NPN_NEGOTIATED  = 1;
		public const int NPN_NO_OVERLAP  = 2;

		/* Default security level if not overridden at config time */
		public const int TLS_SECURITY_LEVEL = 1;

		[Inline]
		public static void add_ssl_algorithms() => SSL.library_init();

#if !OPENSSL_NO_UNIT_TEST
		[
	#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_SSL),
	#endif
			LinkName("SSL_test_functions")
		]
		public extern static ssl_test_functions* test_functions();
#endif
	}
}
