/*
* Generated by util/mkerr.pl DO NOT EDIT
* Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.
*
* Licensed under the OpenSSL license (the "License").  You may not use
* this file except in compliance with the License.  You can obtain a copy
* in the file LICENSE in the source distribution or at
* https://www.openssl.org/source/license.html
*/
using System;

namespace Beef_Net.OpenSSL
{
	[AlwaysInclude]
	sealed abstract class SSLeay
	{
		/* SSLeay compat */
		public const int VERSION_NUMBER = OpenSSL.VERSION_NUMBER;

		public const int VERSION        = OpenSSL.VERSION;
		public const int CFLAGS         = OpenSSL.CFLAGS;
		public const int BUILT_ON       = OpenSSL.BUILT_ON;
		public const int PLATFORM       = OpenSSL.PLATFORM;
		public const int DIR            = OpenSSL.DIR;

		public uint SSLeay()            => OpenSSL.version_num();
		public char8* version(int type) => OpenSSL.version(type);
	}
	
	[AlwaysInclude]
	sealed abstract class OpenSSL
	{
		public const int VERSION     = 0;
		public const int CFLAGS      = 1;
		public const int BUILT_ON    = 2;
		public const int PLATFORM    = 3;
		public const int DIR         = 4;
		public const int ENGINES_DIR = 5;

		/*-
		 * Numeric release version identifier:
		 * MNNFFPPS: major minor fix patch status
		 * The status nibble has one of the values 0 for development, 1 to e for betas
		 * 1 to 14, and f for release.  The patch level is exactly that.
		 * For example:
		 * 0.9.3-dev      0x00903000
		 * 0.9.3-beta1    0x00903001
		 * 0.9.3-beta2-dev 0x00903002
		 * 0.9.3-beta2    0x00903002 (same as ...beta2-dev)
		 * 0.9.3          0x0090300f
		 * 0.9.3a         0x0090301f
		 * 0.9.4          0x0090400f
		 * 1.2.3z         0x102031af
		 *
		 * For continuity reasons (because 0.9.5 is already out, and is coded
		 * 0x00905100), between 0.9.5 and 0.9.6 the coding of the patch level
		 * part is slightly different, by setting the highest bit.  This means
		 * that 0.9.5a looks like this: 0x0090581f.  At 0.9.6, we can start
		 * with 0x0090600S...
		 *
		 * (Prior to 0.9.3-dev a different scheme was used: 0.9.2b is 0x0922.)
		 * (Prior to 0.9.5a beta1, a different scheme was used: MMNNFFRBB for
		 *  major minor fix final patch/beta)
		 */
		public const int VERSION_NUMBER  = 0x1010108FL;
		public const char8* VERSION_TEXT = "OpenSSL 1.1.1h  22 Sep 2020";

		public const int MIN_API         = 0;
		public const int API_COMPAT      = MIN_API;

		public const char8* FILE         = "";
		public const int LINE            = 0;

		[Inline, Obsolete("No longer needed, so this is a no-op", true)]
		public static void malloc_init() { while(false) continue; }

		[Inline]
		public static void* malloc(uint num) => Crypto.malloc(num, FILE, LINE);

		[Inline]
		public static void* zalloc(uint num) => Crypto.zalloc(num, FILE, LINE);

		[Inline]
		public static void* realloc(void* addr, uint num) => Crypto.realloc(addr, num, FILE, LINE);

		[Inline]
		public static void* clear_realloc(void* addr, uint old_num, uint num) => Crypto.clear_realloc(addr, old_num, num, FILE, LINE);

		[Inline]
		public static void clear_free(void* addr, uint num) => Crypto.clear_free(addr, num, FILE, LINE);

		[Inline]
		public static void free(void* addr) => Crypto.free(addr, FILE, LINE);

		[Inline]
		public static void* memdup(void* data, uint size) => Crypto.memdup(data, size, FILE, LINE);

		[Inline]
		public static char8* strdup(char8* str) => Crypto.strdup(str, FILE, LINE);

		[Inline]
		public static char8* strndup(char8* str, uint n) => Crypto.strndup(str, n, FILE, LINE);

		[Inline]
		public static void* secure_malloc(uint num) => Crypto.secure_malloc(num, FILE, LINE);

		[Inline]
		public static void* secure_zalloc(uint num) => Crypto.secure_zalloc(num, FILE, LINE);

		[Inline]
		public static void secure_free(void* addr) => Crypto.secure_free(addr, FILE, LINE);

		[Inline]
		public static void secure_clear_free(void* addr, uint num) => Crypto.secure_clear_free(addr, num, FILE, LINE);

		[Inline]
		public static uint secure_actual_size(void* ptr) => Crypto.secure_actual_size(ptr);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_strlcpy")]
		public extern static uint strlcpy(char8* dst, char8* src, uint size);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_strlcat")]
		public extern static uint strlcat(char8* dst, char8* src, uint size);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_strnlen")]
		public extern static uint strnlen(char8* str, uint maxlen);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_buf2hexstr")]
		public extern static char8* buf2hexstr(uint8* buffer, int len);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_hexstr2buf")]
		public extern static uint8* hexstr2buf(char8* str, int* len);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_hexchar2int")]
		public extern static int hexchar2int(uint8 c);

		[Inline]
		public static uint MALLOC_MAX_NELEMS<T>() => ((1U << (sizeof(int) * 8 - 1)) - 1) / (uint32)sizeof(T);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("OpenSSL_version_num")]
		public extern static uint version_num();
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OpenSSL_version")]
		public extern static char8* version(int type);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_issetugid")]
		public extern static int issetugid();

		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_cleanse")]
		public extern static void cleanse(void* ptr, uint len);

		/* die if we have to */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_die"), NoReturn]
		public extern static void die(char8* assertion, char8* file, int line);
		[Inline]
		public static void OpenSSLDie(char8* f, int l, char8* a) => die(a, f, l);
		[Inline]
		public static void assert(bool check, StringView msg)
		{
			if (!check) {
				String tmp = scope:: .();
				tmp.AppendF("assertion failed: {}", msg);
				die(tmp.CStr(), FILE, LINE);
			}
		}

		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_isservice")]
		public extern static int isservice();

		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_init")]
		public extern static void init();

		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_gmtime")]
		public extern static OSSLType.tm* gmtime(int64* timer, OSSLType.tm* result);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_gmtime_adj")]
		public extern static int gmtime_adj(OSSLType.tm* tm, int offset_day, int offset_sec);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_gmtime_diff")]
		public extern static int gmtime_diff(int* pday, int* psec, OSSLType.tm* from, OSSLType.tm* to);

		/* Standard initialisation options */
		public const int INIT_NO_LOAD_CRYPTO_STRINGS = 0x00000001L;
		public const int INIT_LOAD_CRYPTO_STRINGS    = 0x00000002L;
		public const int INIT_ADD_ALL_CIPHERS        = 0x00000004L;
		public const int INIT_ADD_ALL_DIGESTS        = 0x00000008L;
		public const int INIT_NO_ADD_ALL_CIPHERS     = 0x00000010L;
		public const int INIT_NO_ADD_ALL_DIGESTS     = 0x00000020L;
		public const int INIT_LOAD_CONFIG            = 0x00000040L;
		public const int INIT_NO_LOAD_CONFIG         = 0x00000080L;
		public const int INIT_ASYNC                  = 0x00000100L;
		public const int INIT_ENGINE_RDRAND          = 0x00000200L;
		public const int INIT_ENGINE_DYNAMIC         = 0x00000400L;
		public const int INIT_ENGINE_OPENSSL         = 0x00000800L;
		public const int INIT_ENGINE_CRYPTODEV       = 0x00001000L;
		public const int INIT_ENGINE_CAPI            = 0x00002000L;
		public const int INIT_ENGINE_PADLOCK         = 0x00004000L;
		public const int INIT_ENGINE_AFALG           = 0x00008000L;
		/* public const int INIT_ZLIB                   = 0x00010000L; */
		public const int INIT_ATFORK                 = 0x00020000L;
		/* public const int INIT_BASE_ONLY              = 0x00040000L; */
		public const int INIT_NO_ATEXIT              = 0x00080000L;
		/* INIT flag range 0xfff00000 reserved for init_ssl() */
		/* Max INIT flag value is 0x80000000 */

		/* openssl and dasync not counted as builtin */
		public const int INIT_ENGINE_ALL_BUILTIN = INIT_ENGINE_RDRAND | INIT_ENGINE_DYNAMIC | INIT_ENGINE_CRYPTODEV | INIT_ENGINE_CAPI | INIT_ENGINE_PADLOCK;

		[CRepr]
		public struct init_settings_st
		{
		    public char8* filename;
		    public char8* appname;
		    public uint flags;
		}
		public typealias INIT_SETTINGS = init_settings_st;

		/* Library initialisation functions */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_cleanup")]
		public extern static void cleanup();
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_init_crypto")]
		public extern static int init_crypto(uint64 opts, INIT_SETTINGS* settings);
		function void atexit_handler();
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_atexit")]
		public extern static int atexit(atexit_handler handler);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_thread_stop")]
		public extern static void thread_stop();

		/* Low-level control of initialization */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_INIT_new")]
		public extern static INIT_SETTINGS* INIT_new();
#if !OPENSSL_NO_STDIO
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_INIT_set_config_filename")]
		public extern static int INIT_set_config_filename(INIT_SETTINGS* settings, char8* config_filename);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_INIT_set_config_file_flags")]
		public extern static void INIT_set_config_file_flags(INIT_SETTINGS* settings, uint flags);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_INIT_set_config_appname")]
		public extern static int INIT_set_config_appname(INIT_SETTINGS* settings, char8* config_appname);
#endif
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_INIT_free")]
		public extern static void INIT_free(INIT_SETTINGS* settings);

		[Inline]
		public static int add_all_algorithms_conf() => init_crypto(INIT_ADD_ALL_CIPHERS | INIT_ADD_ALL_DIGESTS | INIT_LOAD_CONFIG, null);
		[Inline]
		public static int add_all_algorithms_noconf() => init_crypto(INIT_ADD_ALL_CIPHERS | INIT_ADD_ALL_DIGESTS, null);

#if OPENSSL_LOAD_CONF
		[Inline]
		public static int add_all_algorithms() => add_all_algorithms_conf();
#else
		[Inline]
		public static int add_all_algorithms() => add_all_algorithms_noconf();
#endif

		[Inline]
		public static int add_all_ciphers() => init_crypto(INIT_ADD_ALL_CIPHERS, null);
		[Inline]
		public static int add_all_digests() => init_crypto(INIT_ADD_ALL_DIGESTS, null);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_config")]
		public extern static void config(char8* config_name);

		[Inline]
		public static int no_config() => init_crypto(INIT_NO_LOAD_CONFIG, null);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_load_builtin_modules")]
		public extern static void load_builtin_modules();

#if !OPENSSL_DH_MAX_MODULUS_BITS
		public const int DH_MAX_MODULUS_BITS      = 10000;
#endif
		public const int DH_FIPS_MIN_MODULUS_BITS = 1024;

#if !OPENSSL_DSA_MAX_MODULUS_BITS
		public const int DSA_MAX_MODULUS_BITS      = 10000;
#endif
		public const int DSA_FIPS_MIN_MODULUS_BITS = 1024;

		public const int EC_EXPLICIT_CURVE = 0x000;
		public const int EC_NAMED_CURVE    = 0x001;

		public const int ECC_MAX_FIELD_BITS = 661;

		public function int LH_COMPFUNC(void* a, void* b);
		public function uint LH_HASHFUNC(void* p);
		public function void LH_DOALL_FUNC(void* p);
		public function void LH_DOALL_FUNCARG(void* a, void* b);

		public typealias LHASH = LHash.lhash_st;
		public typealias LH_NODE = LHash.node_st;

		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_error")]
		public extern static int LH_error(LHash.lhash_st* lh);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_new")]
		public extern static LHash.lhash_st* LH_new(LH_HASHFUNC h, LH_COMPFUNC c);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_free")]
		public extern static void LH_free(LHash.lhash_st* lh);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_insert")]
		public extern static void* LH_insert(LHash.lhash_st* lh, void* data);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_delete")]
		public extern static void* LH_delete(LHash.lhash_st* lh, void* data);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_retrieve")]
		public extern static void* LH_retrieve(LHash.lhash_st* lh, void* data);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_doall")]
		public extern static void LH_doall(LHash.lhash_st* lh, LH_DOALL_FUNC func);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_doall_arg")]
		public extern static void LH_doall_arg(LHash.lhash_st* lh, LH_DOALL_FUNCARG func, void* arg);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_strhash")]
		public extern static uint LH_strhash(char8* c);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_num_items")]
		public extern static uint LH_num_items(LHash.lhash_st* lh);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_get_down_load")]
		public extern static uint LH_get_down_load(LHash.lhash_st* lh);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_set_down_load")]
		public extern static void LH_set_down_load(LHash.lhash_st* lh, uint down_load);

#if !OPENSSL_NO_STDIO
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_stats")]
		public extern static void LH_stats(LHash.lhash_st* lh, Platform.BfpFile* fp);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_node_stats")]
		public extern static void LH_node_stats(LHash.lhash_st* lh, Platform.BfpFile* fp);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_node_usage_stats")]
		public extern static void LH_node_usage_stats(LHash.lhash_st* lh, Platform.BfpFile* fp);
#endif
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_stats_bio")]
		public extern static void LH_stats_bio(LHash.lhash_st* lh, BIO.bio_st* outVal);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_node_stats_bio")]
		public extern static void LH_node_stats_bio(LHash.lhash_st* lh, BIO.bio_st* outVal);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_LH_node_usage_stats_bio")]
		public extern static void LH_node_usage_stats_bio(LHash.lhash_st* lh, BIO.bio_st* outVal);
		
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_asc2uni")]
		public extern static uint8* asc2uni(char8* asc, int asclen, uint8** uni, int* unilen);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_uni2asc")]
		public extern static char8* uni2asc(uint8* uni, int unilen);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_utf82uni")]
		public extern static uint8* utf82uni(char8* asc, int asclen, uint8** uni, int* unilen);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("OPENSSL_uni2utf8")]
		public extern static char8* uni2utf8(uint8* uni, int unilen);
	}
}
