/*
* Generated by util/mkerr.pl DO NOT EDIT
* Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.
*
* Licensed under the OpenSSL license (the "License").  You may not use
* this file except in compliance with the License.  You can obtain a copy
* in the file LICENSE in the source distribution or at
* https://www.openssl.org/source/license.html
*/
using System;

namespace Beef_Net.OpenSSL
{
	[AlwaysInclude]
	sealed abstract class LHash
	{
		[CRepr]
		public struct lhash_st
		{
		    public OpenSSL.LH_NODE** b;
		    public OpenSSL.LH_COMPFUNC comp;
		    public OpenSSL.LH_HASHFUNC hash;
		    public uint num_nodes;
		    public uint num_alloc_nodes;
		    public uint p;
		    public uint pmax;
		    public uint up_load;                       /* load times 256 */
		    public uint down_load;                     /* load times 256 */
		    public uint num_items;
		    public uint num_expands;
		    public uint num_expand_reallocs;
		    public uint num_contracts;
		    public uint num_contract_reallocs;
		    public volatile uint num_hash_calls;
		    public volatile uint num_comp_calls;
		    public uint num_insert;
		    public uint num_replace;
		    public uint num_delete;
		    public uint num_no_delete;
			
		    public volatile uint num_retrieve;
		    public volatile uint num_retrieve_miss;
		    public volatile uint num_hash_comps;
		    public int error;
		}
		public typealias LHASH = lhash_st;

		[CRepr]
		public struct node_st
		{
		    public void* data;
		    public node_st* next;
		    public uint hash;
		}
		public typealias LH_NODE = node_st;
				
		public const int LH_LOAD_MULT = 256;

		public typealias _LHASH = LHASH;
		public typealias LHASH_NODE = LH_NODE;
		[Inline]
		public static int lh_error(lhash_st* lh) => OpenSSL.LH_error(lh);
		[Inline]
		public static lhash_st* lh_new(OpenSSL.LH_HASHFUNC h, OpenSSL.LH_COMPFUNC c) => OpenSSL.LH_new(h, c);
		[Inline]
		public static void lh_free(lhash_st* lh) => OpenSSL.LH_free(lh);
		[Inline]
		public static void* lh_insert(lhash_st* lh, void* data) => OpenSSL.LH_insert(lh, data);
		[Inline]
		public static void* lh_delete(lhash_st* lh, void* data) => OpenSSL.LH_delete(lh, data);
		[Inline]
		public static void* lh_retrieve(lhash_st* lh, void* data) => OpenSSL.LH_retrieve(lh, data);
		[Inline]
		public static void lh_doall(lhash_st* lh, OpenSSL.LH_DOALL_FUNC func) => OpenSSL.LH_doall(lh, func);
		[Inline]
		public static void lh_doall_arg(lhash_st* lh, OpenSSL.LH_DOALL_FUNCARG func, void* arg) => OpenSSL.LH_doall_arg(lh, func, arg);
		[Inline]
		public static uint lh_strhash(char8* c) => OpenSSL.LH_strhash(c);
		[Inline]
		public static uint lh_num_items(lhash_st* lh) => OpenSSL.LH_num_items(lh);
#if !OPENSSL_NO_STDIO
		[Inline]
		public static void lh_stats(lhash_st* lh, Platform.BfpFile* fp) => OpenSSL.LH_stats(lh, fp);
		[Inline]
		public static void lh_node_stats(lhash_st* lh, Platform.BfpFile* fp) => OpenSSL.LH_node_stats(lh, fp);
		[Inline]
		public static void lh_node_usage_stats(lhash_st* lh, Platform.BfpFile* fp) => OpenSSL.LH_node_usage_stats(lh, fp);
#endif
		[Inline]
		public static void lh_stats_bio(lhash_st* lh, BIO.bio_st* outVal) => OpenSSL.LH_stats_bio(lh, outVal);
		[Inline]
		public static void lh_node_stats_bio(lhash_st* lh, BIO.bio_st* outVal) => OpenSSL.LH_node_stats_bio(lh, outVal);
		[Inline]
		public static void lh_node_usage_stats_bio(lhash_st* lh, BIO.bio_st* outVal) => OpenSSL.LH_node_usage_stats_bio(lh, outVal);
	}
}
