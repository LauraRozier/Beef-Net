/*
* Generated by util/mkerr.pl DO NOT EDIT
* Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.
*
* Licensed under the OpenSSL license (the "License").  You may not use
* this file except in compliance with the License.  You can obtain a copy
* in the file LICENSE in the source distribution or at
* https://www.openssl.org/source/license.html
*/
using System;

namespace Beef_Net.OpenSSL
{
	[AlwaysInclude]
	sealed abstract class PKCS1
	{
#if !OPENSSL_NO_RSA
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS1_MGF1")]
		public extern static int MGF1(uint8* mask, int len, uint8* seed, int seedlen, EVP.MD* dgst);
#endif
	}

	[AlwaysInclude]
	sealed abstract class PKCS5
	{
		public const int SALT_LEN     = 8;
		/* Default PKCS#5 iteration count */
		public const int DEFAULT_ITER = 2048;

		/* PKCS5 password based encryption */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS5_PBE_keyivgen")]
		public extern static int PBE_keyivgen(EVP.CIPHER_CTX* ctx, char8* pass, int passlen, ASN1.TYPE* param, EVP.CIPHER* cipher, EVP.MD* md, int en_de);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS5_PBKDF2_HMAC_SHA1")]
		public extern static int PBKDF2_HMAC_SHA1(char8* pass, int passlen, uint8* salt, int saltlen, int iter, int keylen, uint8* outVal);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS5_PBKDF2_HMAC")]
		public extern static int PBKDF2_HMAC(char8* pass, int passlen, uint8* salt, int saltlen, int iter, EVP.MD* digest, int keylen, uint8* outVal);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS5_v2_PBE_keyivgen")]
		public extern static int v2_PBE_keyivgen(EVP.CIPHER_CTX* ctx, char8* pass, int passlen, ASN1.TYPE* param, EVP.CIPHER* cipher, EVP.MD* md, int en_de);

#if !OPENSSL_NO_SCRYPT
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS5_v2_scrypt_keyivgen")]
		public extern static int v2_scrypt_keyivgen(EVP.CIPHER_CTX* ctx, char8* pass, int passlen, ASN1.TYPE* param, EVP.CIPHER* c, EVP.MD* md, int en_de);
#endif

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS5_PBE_add")]
		public extern static void PBE_add();
		

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS5_pbe_set0_algor")]
		public extern static int pbe_set0_algor(X509.ALGOR* algor, int alg, int iter, uint8* salt, int saltlen);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS5_pbe_set")]
		public extern static X509.ALGOR* pbe_set(int alg, int iter, uint8* salt, int saltlen);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS5_pbe2_set")]
		public extern static X509.ALGOR* pbe2_set(EVP.CIPHER* cipher, int iter, uint8* salt, int saltlen);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS5_pbe2_set_iv")]
		public extern static X509.ALGOR* pbe2_set_iv(EVP.CIPHER* cipher, int iter, uint8* salt, int saltlen, uint8* aiv, int prf_nid);

#if !OPENSSL_NO_SCRYPT
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS5_pbe2_set_scrypt")]
		public extern static X509.ALGOR* pbe2_set_scrypt(EVP.CIPHER* cipher, uint8* salt, int saltlen, uint8* aiv, uint64 N, uint64 r, uint64 p);
#endif

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS5_pbkdf2_set")]
		public extern static X509.ALGOR* pbkdf2_set(int iter, uint8* salt, int saltlen, int prf_nid, int keylen);
	}
	
	[AlwaysInclude]
	sealed abstract class PKCS7
	{
		[Import(OPENSSL_LIB_CRYPTO), CLink]
		public extern static int ERR_load_PKCS7_strings();
		
		/*
		 * PKCS7 function codes.
		 */
		public const int F_DO_PKCS7_SIGNED_ATTRIB                     = 136;
		public const int F_PKCS7_ADD0_ATTRIB_SIGNING_TIME             = 135;
		public const int F_PKCS7_ADD_ATTRIB_SMIMECAP                  = 118;
		public const int F_PKCS7_ADD_CERTIFICATE                      = 100;
		public const int F_PKCS7_ADD_CRL                              = 101;
		public const int F_PKCS7_ADD_RECIPIENT_INFO                   = 102;
		public const int F_PKCS7_ADD_SIGNATURE                        = 131;
		public const int F_PKCS7_ADD_SIGNER                           = 103;
		public const int F_PKCS7_BIO_ADD_DIGEST                       = 125;
		public const int F_PKCS7_COPY_EXISTING_DIGEST                 = 138;
		public const int F_PKCS7_CTRL                                 = 104;
		public const int F_PKCS7_DATADECODE                           = 112;
		public const int F_PKCS7_DATAFINAL                            = 128;
		public const int F_PKCS7_DATAINIT                             = 105;
		public const int F_PKCS7_DATAVERIFY                           = 107;
		public const int F_PKCS7_DECRYPT                              = 114;
		public const int F_PKCS7_DECRYPT_RINFO                        = 133;
		public const int F_PKCS7_ENCODE_RINFO                         = 132;
		public const int F_PKCS7_ENCRYPT                              = 115;
		public const int F_PKCS7_FINAL                                = 134;
		public const int F_PKCS7_FIND_DIGEST                          = 127;
		public const int F_PKCS7_GET0_SIGNERS                         = 124;
		public const int F_PKCS7_RECIP_INFO_SET                       = 130;
		public const int F_PKCS7_SET_CIPHER                           = 108;
		public const int F_PKCS7_SET_CONTENT                          = 109;
		public const int F_PKCS7_SET_DIGEST                           = 126;
		public const int F_PKCS7_SET_TYPE                             = 110;
		public const int F_PKCS7_SIGN                                 = 116;
		public const int F_PKCS7_SIGNATUREVERIFY                      = 113;
		public const int F_PKCS7_SIGNER_INFO_SET                      = 129;
		public const int F_PKCS7_SIGNER_INFO_SIGN                     = 139;
		public const int F_PKCS7_SIGN_ADD_SIGNER                      = 137;
		public const int F_PKCS7_SIMPLE_SMIMECAP                      = 119;
		public const int F_PKCS7_VERIFY                               = 117;
		
		/*
		 * PKCS7 reason codes.
		 */
		public const int R_CERTIFICATE_VERIFY_ERROR                   = 117;
		public const int R_CIPHER_HAS_NO_OBJECT_IDENTIFIER            = 144;
		public const int R_CIPHER_NOT_INITIALIZED                     = 116;
		public const int R_CONTENT_AND_DATA_PRESENT                   = 118;
		public const int R_CTRL_ERROR                                 = 152;
		public const int R_DECRYPT_ERROR                              = 119;
		public const int R_DIGEST_FAILURE                             = 101;
		public const int R_ENCRYPTION_CTRL_FAILURE                    = 149;
		public const int R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE = 150;
		public const int R_ERROR_ADDING_RECIPIENT                     = 120;
		public const int R_ERROR_SETTING_CIPHER                       = 121;
		public const int R_INVALID_NULL_POINTER                       = 143;
		public const int R_INVALID_SIGNED_DATA_TYPE                   = 155;
		public const int R_NO_CONTENT                                 = 122;
		public const int R_NO_DEFAULT_DIGEST                          = 151;
		public const int R_NO_MATCHING_DIGEST_TYPE_FOUND              = 154;
		public const int R_NO_RECIPIENT_MATCHES_CERTIFICATE           = 115;
		public const int R_NO_SIGNATURES_ON_DATA                      = 123;
		public const int R_NO_SIGNERS                                 = 142;
		public const int R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE       = 104;
		public const int R_PKCS7_ADD_SIGNATURE_ERROR                  = 124;
		public const int R_PKCS7_ADD_SIGNER_ERROR                     = 153;
		public const int R_PKCS7_DATASIGN                             = 145;
		public const int R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE     = 127;
		public const int R_SIGNATURE_FAILURE                          = 105;
		public const int R_SIGNER_CERTIFICATE_NOT_FOUND               = 128;
		public const int R_SIGNING_CTRL_FAILURE                       = 147;
		public const int R_SIGNING_NOT_SUPPORTED_FOR_THIS_KEY_TYPE    = 148;
		public const int R_SMIME_TEXT_ERROR                           = 129;
		public const int R_UNABLE_TO_FIND_CERTIFICATE                 = 106;
		public const int R_UNABLE_TO_FIND_MEM_BIO                     = 107;
		public const int R_UNABLE_TO_FIND_MESSAGE_DIGEST              = 108;
		public const int R_UNKNOWN_DIGEST_TYPE                        = 109;
		public const int R_UNKNOWN_OPERATION                          = 110;
		public const int R_UNSUPPORTED_CIPHER_TYPE                    = 111;
		public const int R_UNSUPPORTED_CONTENT_TYPE                   = 112;
		public const int R_WRONG_CONTENT_TYPE                         = 113;
		public const int R_WRONG_PKCS7_TYPE                           = 114;

		/*-
		Encryption_ID           DES-CBC
		Digest_ID               MD5
		Digest_Encryption_ID    rsaEncryption
		Key_Encryption_ID       rsaEncryption
		*/
		[CRepr]
		public struct issuer_and_serial_st
		{
		    public X509.NAME* issuer;
		    public ASN1.INTEGER* serial;
		}
		public typealias ISSUER_AND_SERIAL = issuer_and_serial_st;

		[CRepr]
		public struct signer_info_st
		{
		    public ASN1.INTEGER* version;      /* version 1 */
		    public ISSUER_AND_SERIAL* issuer_and_serial;
		    public X509.ALGOR* digest_alg;
		    public X509.stack_st_X509_ATTRIBUTE* auth_attr; /* [ 0 ] */
		    public X509.ALGOR* digest_enc_alg;
		    public ASN1.OCTET_STRING* enc_digest;
		    public X509.stack_st_X509_ATTRIBUTE* unauth_attr; /* [ 1 ] */
		    /* The private key to sign with */
		    public EVP.PKEY* pkey;
		}
		public typealias SIGNER_INFO = signer_info_st;

		public struct stack_st_PKCS7_SIGNER_INFO {}

		[CRepr]
		public struct recip_info_st
		{
		    public ASN1.INTEGER* version;      /* version 0 */
		    public ISSUER_AND_SERIAL* issuer_and_serial;
		    public X509.ALGOR* key_enc_algor;
		    public ASN1.OCTET_STRING* enc_key;
		    public X509.x509_st* cert;                 /* get the pub-key from this */
		}
		public typealias RECIP_INFO = recip_info_st;

		public struct stack_st_PKCS7_RECIP_INFO {}

		[CRepr]
		public struct signed_st
		{
		    public ASN1.INTEGER* version;      /* version 1 */
		    public X509.stack_st_X509_ALGOR* md_algs; /* md used */
		    public X509.stack_st_X509* cert;       /* [ 0 ] */
		    public X509.stack_st_X509_CRL* crl;    /* [ 1 ] */
		    public stack_st_PKCS7_SIGNER_INFO* signer_info;
		    public pkcs7_st* contents;
		}
		public typealias SIGNED = signed_st;
		/*
		 * The above structure is very very similar to PKCS7_SIGN_ENVELOPE. How about
		 * merging the two
		 */

		[CRepr]
		public struct enc_content_st
		{
		    public ASN1.OBJECT* content_type;
		    public X509.ALGOR* algorithm;
		    public ASN1.OCTET_STRING* enc_data; /* [ 0 ] */
		    public EVP.CIPHER* cipher;
		}
		public typealias ENC_CONTENT = enc_content_st;

		[CRepr]
		public struct enveloped_st
		{
		    public ASN1.INTEGER* version;      /* version 0 */
		    public stack_st_PKCS7_RECIP_INFO* recipientinfo;
		    public ENC_CONTENT* enc_data;
		}
		public typealias ENVELOPE = enveloped_st;

		[CRepr]
		public struct signedandenveloped_st
		{
		    public ASN1.INTEGER* version;      /* version 1 */
		    public X509.stack_st_X509_ALGOR* md_algs; /* md used */
		    public X509.stack_st_X509* cert;       /* [ 0 ] */
		    public X509.stack_st_X509_CRL* crl;    /* [ 1 ] */
		    public stack_st_PKCS7_SIGNER_INFO* signer_info;
		    public ENC_CONTENT* enc_data;
		    public stack_st_PKCS7_RECIP_INFO* recipientinfo;
		}
		public typealias SIGN_ENVELOPE = signedandenveloped_st;

		[CRepr]
		public struct digest_st
		{
		    public ASN1.INTEGER* version;      /* version 0 */
		    public X509.ALGOR* md;             /* md used */
		    public pkcs7_st* contents;
		    public ASN1.OCTET_STRING* digest;
		}
		public typealias DIGEST = digest_st;

		[CRepr]
		public struct encrypted_st
		{
		    public ASN1.INTEGER* version;      /* version 0 */
		    public ENC_CONTENT* enc_data;
		}
		public typealias ENCRYPT = encrypted_st;

		[CRepr]
		public struct pkcs7_st
		{
		    /*
		     * The following is non NULL if it contains ASN1 encoding of this
		     * structure
		     */
		    public uint8* asn1;
		    public int length;
			public const int S_HEADER = 0;
			public const int S_BODY   = 1;
			public const int S_TAIL   = 2;
		    public int state;                  /* used during processing */
		    public int detached;
		    public ASN1.OBJECT* type;
		    /* content as defined by the type */
		    /*
		     * all encryption/message digests are applied to the 'contents', leaving
		     * out the 'type' field.
		     */
			public d_struct d;

		    [CRepr, Union]
			public struct d_struct
			{
		        public char8* ptr;
		        /* NID_pkcs7_data */
		        public ASN1.OCTET_STRING* data;
		        /* NID_pkcs7_signed */
		        public SIGNED* sign;
		        /* NID_pkcs7_enveloped */
		        public ENVELOPE* enveloped;
		        /* NID_pkcs7_signedAndEnveloped */
		        public SIGN_ENVELOPE* signed_and_enveloped;
		        /* NID_pkcs7_digest */
		        public DIGEST* digest;
		        /* NID_pkcs7_encrypted */
		        public ENCRYPT* encrypted;
		        /* Anything else */
		        public ASN1.TYPE* other;
		    }
		}
		public typealias PKCS7 = pkcs7_st;

		public struct stack_st_PKCS7 {}

		public const int OP_SET_DETACHED_SIGNATURE = 1;
		public const int OP_GET_DETACHED_SIGNATURE = 2;
		
		[Inline]
		public static X509.stack_st_X509_ATTRIBUTE* get_signed_attributes(signer_info_st* si) => si.auth_attr;
		[Inline]
		public static X509.stack_st_X509_ATTRIBUTE* get_attributes(signer_info_st* si) => si.unauth_attr;
		
		[Inline]
		public static bool type_is_signed(pkcs7_st* a) => (Objects.obj2nid(a.type) == NID.pkcs7_signed);
		[Inline]
		public static bool type_is_encrypted(pkcs7_st* a) => (Objects.obj2nid(a.type) == NID.pkcs7_encrypted);
		[Inline]
		public static bool type_is_enveloped(pkcs7_st* a) => (Objects.obj2nid(a.type) == NID.pkcs7_enveloped);
		[Inline]
		public static bool type_is_signedAndEnveloped(pkcs7_st* a) => (Objects.obj2nid(a.type) == NID.pkcs7_signedAndEnveloped);
		[Inline]
		public static bool type_is_data(pkcs7_st* a) => (Objects.obj2nid(a.type) == NID.pkcs7_data);
		[Inline]
		public static bool type_is_digest(pkcs7_st* a) => (Objects.obj2nid(a.type) == NID.pkcs7_digest);
		
		[Inline]
		public static int set_detached(pkcs7_st* p, int v) => ctrl(p, OP_SET_DETACHED_SIGNATURE, v, null);
		[Inline]
		public static int get_detached(pkcs7_st* p) => ctrl(p, OP_GET_DETACHED_SIGNATURE, 0, null);
		
		[Inline]
		public static bool is_detached(pkcs7_st* p7) => type_is_signed(p7) && (get_detached(p7) > 0);

		/* S/MIME related flags */
		public const int TEXT            = 0x1;
		public const int NOCERTS         = 0x2;
		public const int NOSIGS          = 0x4;
		public const int NOCHAIN         = 0x8;
		public const int NOINTERN        = 0x10;
		public const int NOVERIFY        = 0x20;
		public const int DETACHED        = 0x40;
		public const int BINARY          = 0x80;
		public const int NOATTR          = 0x100;
		public const int NOSMIMECAP      = 0x200;
		public const int NOOLDMIMETYPE   = 0x400;
		public const int CRLFEOL         = 0x800;
		public const int STREAM          = 0x1000;
		public const int NOCRL           = 0x2000;
		public const int PARTIAL         = 0x4000;
		public const int REUSE_DIGEST    = 0x8000;
		public const int NO_DUAL_CONTENT = 0x10000;

		// DECLARE_ASN1_FUNCTIONS(ISSUER_AND_SERIAL)
		[Import(OPENSSL_LIB_CRYPTO), LinkName("")]
		public extern static int PKCS7_ISSUER_AND_SERIAL_digest(ISSUER_AND_SERIAL* data, EVP.MD* type, uint8* md, uint* len);
#if !OPENSSL_NO_STDIO
		[Import(OPENSSL_LIB_CRYPTO), CLink]
		public extern static pkcs7_st* d2i_PKCS7_fp(Platform.BfpFile* fp, pkcs7_st** p7);
		[Import(OPENSSL_LIB_CRYPTO), CLink]
		public extern static int i2d_PKCS7_fp(Platform.BfpFile* fp, pkcs7_st* p7);
#endif
		[Import(OPENSSL_LIB_CRYPTO), LinkName("")]
		public extern static pkcs7_st* PKCS7_dup(pkcs7_st* p7);
		[Import(OPENSSL_LIB_CRYPTO), CLink]
		public extern static pkcs7_st* d2i_PKCS7_bio(BIO.bio_st* bp, pkcs7_st** p7);
		[Import(OPENSSL_LIB_CRYPTO), CLink]
		public extern static int i2d_PKCS7_bio(BIO.bio_st* bp, pkcs7_st* p7);
		[Import(OPENSSL_LIB_CRYPTO), CLink]
		public extern static int i2d_PKCS7_bio_stream(BIO.bio_st* outVal, pkcs7_st* p7, BIO.bio_st* inVal, int flags);

		/*
		DECLARE_ASN1_FUNCTIONS(PKCS7_SIGNER_INFO)
		DECLARE_ASN1_FUNCTIONS(PKCS7_RECIP_INFO)
		DECLARE_ASN1_FUNCTIONS(PKCS7_SIGNED)
		DECLARE_ASN1_FUNCTIONS(PKCS7_ENC_CONTENT)
		DECLARE_ASN1_FUNCTIONS(PKCS7_ENVELOPE)
		DECLARE_ASN1_FUNCTIONS(PKCS7_SIGN_ENVELOPE)
		DECLARE_ASN1_FUNCTIONS(PKCS7_DIGEST)
		DECLARE_ASN1_FUNCTIONS(PKCS7_ENCRYPT)
		DECLARE_ASN1_FUNCTIONS(PKCS7)

		DECLARE_ASN1_ITEM(PKCS7_ATTR_SIGN)
		DECLARE_ASN1_ITEM(PKCS7_ATTR_VERIFY)

		DECLARE_ASN1_NDEF_FUNCTION(PKCS7)
		DECLARE_ASN1_PRINT_FUNCTION(PKCS7)
		*/

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_ctrl")]
		public extern static int ctrl(pkcs7_st* p7, int cmd, int larg, char8* parg);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_set_type")]
		public extern static int set_type(pkcs7_st* p7, int type);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_set0_type_other")]
		public extern static int set0_type_other(pkcs7_st* p7, int type, ASN1.TYPE* other);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_set_content")]
		public extern static int set_content(pkcs7_st* p7, pkcs7_st* p7_data);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_SIGNER_INFO_set")]
		public extern static int SIGNER_INFO_set(SIGNER_INFO* p7i, X509.x509_st* x509, EVP.PKEY* pkey, EVP.MD* dgst);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_SIGNER_INFO_sign")]
		public extern static int SIGNER_INFO_sign(SIGNER_INFO* si);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_add_signer")]
		public extern static int add_signer(pkcs7_st* p7, SIGNER_INFO* p7i);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_add_certificate")]
		public extern static int add_certificate(pkcs7_st* p7, X509.x509_st* x509);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_add_crl")]
		public extern static int add_crl(pkcs7_st* p7, X509.CRL* x509);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_content_new")]
		public extern static int content_new(pkcs7_st* p7, int nid);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_dataVerify")]
		public extern static int dataVerify(X509.STORE* cert_store, X509.STORE_CTX* ctx, BIO.bio_st* bio, pkcs7_st* p7, SIGNER_INFO* si);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_signatureVerify")]
		public extern static int signatureVerify(BIO.bio_st* bio, pkcs7_st* p7, SIGNER_INFO* si, X509.x509_st* x509);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_dataInit")]
		public extern static BIO.bio_st* dataInit(pkcs7_st* p7, BIO.bio_st* bio);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_dataFinal")]
		public extern static int dataFinal(pkcs7_st* p7, BIO.bio_st* bio);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_dataDecode")]
		public extern static BIO.bio_st* dataDecode(pkcs7_st* p7, EVP.PKEY* pkey, BIO.bio_st* in_bio, X509.x509_st* pcert);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_add_signature")]
		public extern static SIGNER_INFO* add_signature(pkcs7_st* p7, X509.x509_st* x509, EVP.PKEY* pkey, EVP.MD* dgst);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_cert_from_signer_info")]
		public extern static X509.x509_st* cert_from_signer_info(pkcs7_st* p7, SIGNER_INFO* si);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_set_digest")]
		public extern static int set_digest(pkcs7_st* p7, EVP.MD* md);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_get_signer_info")]
		public extern static stack_st_PKCS7_SIGNER_INFO* get_signer_info(pkcs7_st* p7);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_add_recipient")]
		public extern static RECIP_INFO* add_recipient(pkcs7_st* p7, X509.x509_st* x509);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_SIGNER_INFO_get0_algs")]
		public extern static void SIGNER_INFO_get0_algs(SIGNER_INFO* si, EVP.PKEY** pk, X509.ALGOR** pdig, X509.ALGOR** psig);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_RECIP_INFO_get0_alg")]
		public extern static void RECIP_INFO_get0_alg(RECIP_INFO * ri, X509.ALGOR**penc);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_add_recipient_info")]
		public extern static int add_recipient_info(pkcs7_st* p7, RECIP_INFO* ri);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_RECIP_INFO_set")]
		public extern static int RECIP_INFO_set(RECIP_INFO* p7i, X509.x509_st* x509);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_set_cipher")]
		public extern static int set_cipher(pkcs7_st* p7, EVP.CIPHER* cipher);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_stream")]
		public extern static int stream(uint8*** boundary, pkcs7_st* p7);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_get_issuer_and_serial")]
		public extern static ISSUER_AND_SERIAL* get_issuer_and_serial(pkcs7_st* p7, int idx);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_digest_from_attributes")]
		public extern static ASN1.OCTET_STRING* digest_from_attributes(X509.stack_st_X509_ATTRIBUTE* sk);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_add_signed_attribute")]
		public extern static int add_signed_attribute(SIGNER_INFO* p7si, int nid, int type, void* data);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_add_attribute")]
		public extern static int add_attribute(SIGNER_INFO* p7si, int nid, int atrtype, void* value);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_get_attribute")]
		public extern static ASN1.TYPE* get_attribute(SIGNER_INFO* si, int nid);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_get_signed_attribute")]
		public extern static ASN1.TYPE* get_signed_attribute(SIGNER_INFO* si, int nid);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_set_signed_attributes")]
		public extern static int set_signed_attributes(SIGNER_INFO* p7si, X509.stack_st_X509_ATTRIBUTE* sk);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_set_attributes")]
		public extern static int set_attributes(SIGNER_INFO* p7si, X509.stack_st_X509_ATTRIBUTE* sk);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_sign")]
		public extern static pkcs7_st* sign(X509.x509_st* signcert, EVP.PKEY* pkey, X509.stack_st_X509* certs, BIO.bio_st* data, int flags);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_sign_add_signer")]
		public extern static SIGNER_INFO* sign_add_signer(pkcs7_st* p7, X509.x509_st* signcert, EVP.PKEY* pkey, EVP.MD* md, int flags);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_final")]
		public extern static int final(pkcs7_st* p7, BIO.bio_st* data, int flags);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_verify")]
		public extern static int verify(pkcs7_st* p7, X509.stack_st_X509* certs, X509.STORE* store, BIO.bio_st* indata, BIO.bio_st* outVal, int flags);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_get0_signers")]
		public extern static X509.stack_st_X509* get0_signers(pkcs7_st* p7, X509.stack_st_X509* certs, int flags);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_encrypt")]
		public extern static pkcs7_st* encrypt(X509.stack_st_X509* certs, BIO.bio_st* inVal, EVP.CIPHER* cipher, int flags);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_decrypt")]
		public extern static int decrypt(pkcs7_st* p7, EVP.PKEY* pkey, X509.x509_st* cert, BIO.bio_st* data, int flags);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_add_attrib_smimecap")]
		public extern static int add_attrib_smimecap(SIGNER_INFO* si, X509.stack_st_X509_ALGOR* cap);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_get_smimecap")]
		public extern static X509.stack_st_X509_ALGOR* get_smimecap(SIGNER_INFO* si);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_simple_smimecap")]
		public extern static int simple_smimecap(X509.stack_st_X509_ALGOR* sk, int nid, int arg);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_add_attrib_content_type")]
		public extern static int add_attrib_content_type(SIGNER_INFO* si, ASN1.OBJECT* coid);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_add0_attrib_signing_time")]
		public extern static int add0_attrib_signing_time(SIGNER_INFO* si, ASN1.TIME* t);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_add1_attrib_digest")]
		public extern static int add1_attrib_digest(SIGNER_INFO* si, uint8* md, int mdlen);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS7_to_TS_TST_INFO")]
		public extern static TS.TST_INFO* to_TS_TST_INFO(pkcs7_st* token);
	}
	
	[AlwaysInclude]
	sealed abstract class PKCS8
	{
		/* PKCS#8 private key info structure */
		[CRepr]
		public struct priv_key_info_st
		{
		    public ASN1.INTEGER* version;
		    public X509.ALGOR* pkeyalg;
		    public ASN1.OCTET_STRING* pkey;
		    public X509.stack_st_X509_ATTRIBUTE* attributes;
		}
		public typealias PRIV_KEY_INFO = priv_key_info_st;

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS8_get_attr")]
		public extern static ASN1.TYPE* get_attr(PRIV_KEY_INFO* p8, int attr_nid);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS8_decrypt")]
		public extern static PRIV_KEY_INFO* decrypt(X509.SIG* p8, char8* pass, int passlen);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS8_encrypt")]
		public extern static X509.SIG* encrypt(int pbe_nid, EVP.CIPHER* cipher, char8* pass, int passlen, uint8* salt, int saltlen, int iter, PRIV_KEY_INFO* p8);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS8_set0_pbe")]
		public extern static X509.SIG* set0_pbe(char8* pass, int passlen, PRIV_KEY_INFO* p8inf, X509.ALGOR* pbe);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS8_add_keyusage")]
		public extern static int add_keyusage(PRIV_KEY_INFO* p8, int usage);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS8_pkey_set0")]
		public extern static int pkey_set0(PRIV_KEY_INFO* priv, ASN1.OBJECT* aobj, int version, int ptype, void* pval, uint8* penc, int penclen);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS8_pkey_get0")]
		public extern static int pkey_get0(ASN1.OBJECT** ppkalg, uint8** pk, int* ppklen, X509.ALGOR** pa, PRIV_KEY_INFO* p8);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS8_pkey_get0_attrs")]
		public extern static X509.stack_st_X509_ATTRIBUTE* pkey_get0_attrs(PRIV_KEY_INFO* p8);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS8_pkey_add1_attr_by_NID")]
		public extern static int pkey_add1_attr_by_NID(PRIV_KEY_INFO* p8, int nid, int type, uint8* bytes, int len);
	}
	
	[AlwaysInclude]
	sealed abstract class PKCS12
	{
		[Import(OPENSSL_LIB_CRYPTO), CLink]
		public extern static int ERR_load_PKCS12_strings();
		
		/*
		 * PKCS12 function codes.
		 */
		public const int F_OPENSSL_ASC2UNI                     = 121;
		public const int F_OPENSSL_UNI2ASC                     = 124;
		public const int F_OPENSSL_UNI2UTF8                    = 127;
		public const int F_OPENSSL_UTF82UNI                    = 129;
		public const int F_PKCS12_CREATE                       = 105;
		public const int F_PKCS12_GEN_MAC                      = 107;
		public const int F_PKCS12_INIT                         = 109;
		public const int F_PKCS12_ITEM_DECRYPT_D2I             = 106;
		public const int F_PKCS12_ITEM_I2D_ENCRYPT             = 108;
		public const int F_PKCS12_ITEM_PACK_SAFEBAG            = 117;
		public const int F_PKCS12_KEY_GEN_ASC                  = 110;
		public const int F_PKCS12_KEY_GEN_UNI                  = 111;
		public const int F_PKCS12_KEY_GEN_UTF8                 = 116;
		public const int F_PKCS12_NEWPASS                      = 128;
		public const int F_PKCS12_PACK_P7DATA                  = 114;
		public const int F_PKCS12_PACK_P7ENCDATA               = 115;
		public const int F_PKCS12_PARSE                        = 118;
		public const int F_PKCS12_PBE_CRYPT                    = 119;
		public const int F_PKCS12_PBE_KEYIVGEN                 = 120;
		public const int F_PKCS12_SAFEBAG_CREATE0_P8INF        = 112;
		public const int F_PKCS12_SAFEBAG_CREATE0_PKCS8        = 113;
		public const int F_PKCS12_SAFEBAG_CREATE_PKCS8_ENCRYPT = 133;
		public const int F_PKCS12_SETUP_MAC                    = 122;
		public const int F_PKCS12_SET_MAC                      = 123;
		public const int F_PKCS12_UNPACK_AUTHSAFES             = 130;
		public const int F_PKCS12_UNPACK_P7DATA                = 131;
		public const int F_PKCS12_VERIFY_MAC                   = 126;
		public const int F_PKCS8_ENCRYPT                       = 125;
		public const int F_PKCS8_SET0_PBE                      = 132;
		
		/*
		 * PKCS12 reason codes.
		 */
		public const int R_CANT_PACK_STRUCTURE                 = 100;
		public const int R_CONTENT_TYPE_NOT_DATA               = 121;
		public const int R_DECODE_ERROR                        = 101;
		public const int R_ENCODE_ERROR                        = 102;
		public const int R_ENCRYPT_ERROR                       = 103;
		public const int R_ERROR_SETTING_ENCRYPTED_DATA_TYPE   = 120;
		public const int R_INVALID_NULL_ARGUMENT               = 104;
		public const int R_INVALID_NULL_PKCS12_POINTER         = 105;
		public const int R_IV_GEN_ERROR                        = 106;
		public const int R_KEY_GEN_ERROR                       = 107;
		public const int R_MAC_ABSENT                          = 108;
		public const int R_MAC_GENERATION_ERROR                = 109;
		public const int R_MAC_SETUP_ERROR                     = 110;
		public const int R_MAC_STRING_SET_ERROR                = 111;
		public const int R_MAC_VERIFY_FAILURE                  = 113;
		public const int R_PARSE_ERROR                         = 114;
		public const int R_PKCS12_ALGOR_CIPHERINIT_ERROR       = 115;
		public const int R_PKCS12_CIPHERFINAL_ERROR            = 116;
		public const int R_PKCS12_PBE_CRYPT_ERROR              = 117;
		public const int R_UNKNOWN_DIGEST_ALGORITHM            = 118;
		public const int R_UNSUPPORTED_PKCS12_MODE             = 119;
		
		public const int KEY_ID = 1;
		public const int IV_ID  = 2;
		public const int MAC_ID = 3;

		/* Default iteration count */
#if !PKCS12_DEFAULT_ITER
		public const int DEFAULT_ITER = PKCS5.DEFAULT_ITER;
#endif

		public const int MAC_KEY_LENGTH = 20;

		public const int SALT_LEN = 8;

		/* It's not clear if these are actually needed... */
		[Inline]
		public static int key_gen(char8* pass, int passlen, uint8* salt, int saltlen, int id, int iter, int n, uint8* outVal, EVP.MD* md_type) =>
			key_gen_utf8(pass, passlen, salt, saltlen, id, iter, n, outVal, md_type);
		[Inline]
		public static int add_friendlyname(SAFEBAG* bag, char8* name, int namelen) => add_friendlyname_utf8(bag, name, namelen);

		/* MS key usage constants */

		public const int KEY_EX  = 0x10;
		public const int KEY_SIG = 0x80;

		[CRepr]
		public struct MAC_DATA_st
		{
		    public X509.SIG* dinfo;
		    public ASN1.OCTET_STRING* salt;
		    public ASN1.INTEGER* iter;      /* defaults to 1 */
		}
		public typealias MAC_DATA = MAC_DATA_st;
		
		[CRepr]
		public struct PKCS12_st
		{
		    public ASN1.INTEGER* version;
		    public MAC_DATA* mac;
		    public PKCS7.pkcs7_st* authsafes;
		}
		public typealias PKCS12 = PKCS12_st;
		
		[CRepr]
		public struct SAFEBAG_st
		{
		    public ASN1.OBJECT* type;
		    public value_struct value;
		    public X509.stack_st_X509_ATTRIBUTE* attrib;
			
			[CRepr, Union]
			public struct value_struct
			{
		        public bag_st* bag;                    /* secret, crl and certbag */
		        public PKCS8.priv_key_info_st* keybag; /* keybag */
		        public X509.SIG* shkeybag;             /* shrouded key bag */
		        public stack_st_PKCS12_SAFEBAG* safes;
		        public ASN1.TYPE* other;
			}
		}
		public typealias SAFEBAG = SAFEBAG_st;

		public struct stack_st_PKCS12_SAFEBAG {}
		
		[CRepr]
		public struct bag_st
		{
		    public ASN1.OBJECT* type;
		    public value_struct value;
			
			[CRepr, Union]
			public struct value_struct
			{
		        public ASN1.OCTET_STRING* x509cert;
		        public ASN1.OCTET_STRING* x509crl;
		        public ASN1.OCTET_STRING* octet;
		        public ASN1.IA5STRING* sdsicert;
		        public ASN1.TYPE* other;             /* Secret or other bag */
			}
		}
		public typealias BAGS = bag_st;
		
		public const int ERROR = 0;
		public const int OK    = 1;

		/* Compatibility macros */
		[Inline]
		public static int M_PKCS12_bag_type(SAFEBAG* bag) => bag_type(bag);
		[Inline]
		public static int M_PKCS12_cert_bag_type(SAFEBAG* bag) => cert_bag_type(bag);
		[Inline]
		public static int M_PKCS12_crl_bag_type(SAFEBAG* bag) => cert_bag_type(bag);
		
		[Inline]
		public static X509.x509_st* certbag2x509(SAFEBAG* bag) => SAFEBAG_get1_cert(bag);
		[Inline]
		public static X509.CRL* certbag2scrl(SAFEBAG* bag) => SAFEBAG_get1_crl(bag);
		[Inline]
		public static int bag_type(SAFEBAG* bag) => SAFEBAG_get_nid(bag);
		[Inline]
		public static int cert_bag_type(SAFEBAG* bag) => SAFEBAG_get_bag_nid(bag);
		[Inline]
		public static SAFEBAG* x5092certbag(X509.x509_st* x509) => SAFEBAG_create_cert(x509);
		[Inline]
		public static SAFEBAG* x509crl2certbag(X509.CRL* crl) => SAFEBAG_create_crl(crl);
		[Inline]
		public static SAFEBAG* MAKE_KEYBAG(PKCS8.PRIV_KEY_INFO* p8) => SAFEBAG_create0_p8inf(p8);
		[Inline]
		public static SAFEBAG* MAKE_SHKEYBAG(int pbe_nid, char8* pass, int passlen, uint8* salt, int saltlen, int iter, PKCS8.PRIV_KEY_INFO* p8inf) =>
			SAFEBAG_create_pkcs8_encrypt(pbe_nid, pass, passlen, salt, saltlen, iter, p8inf);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_get_attr")]
		public extern static ASN1.TYPE* get_attr(SAFEBAG* bag, int attr_nid);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_mac_present")]
		public extern static int mac_present(PKCS12_st* p12);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_get0_mac")]
		public extern static void get0_mac(ASN1.OCTET_STRING** pmac, X509.ALGOR** pmacalg, ASN1.OCTET_STRING** psalt, ASN1.INTEGER** piter, PKCS12_st* p12);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_SAFEBAG_get0_attr")]
		public extern static ASN1.TYPE* SAFEBAG_get0_attr(SAFEBAG* bag, int attr_nid);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_SAFEBAG_get0_type")]
		public extern static ASN1.OBJECT* SAFEBAG_get0_type(SAFEBAG* bag);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_SAFEBAG_get_nid")]
		public extern static int SAFEBAG_get_nid(SAFEBAG* bag);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_SAFEBAG_get_bag_nid")]
		public extern static int SAFEBAG_get_bag_nid(SAFEBAG* bag);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_SAFEBAG_get1_cert")]
		public extern static X509.x509_st* SAFEBAG_get1_cert(SAFEBAG* bag);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_SAFEBAG_get1_crl")]
		public extern static X509.CRL* SAFEBAG_get1_crl(SAFEBAG* bag);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_SAFEBAG_get0_safes")]
		public extern static stack_st_PKCS12_SAFEBAG* SAFEBAG_get0_safes(SAFEBAG* bag);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_SAFEBAG_get0_p8inf")]
		public extern static PKCS8.PRIV_KEY_INFO* SAFEBAG_get0_p8inf(SAFEBAG* bag);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_SAFEBAG_get0_pkcs8")]
		public extern static X509.SIG* SAFEBAG_get0_pkcs8(SAFEBAG* bag);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_SAFEBAG_create_cert")]
		public extern static SAFEBAG* SAFEBAG_create_cert(X509.x509_st* x509);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_SAFEBAG_create_crl")]
		public extern static SAFEBAG* SAFEBAG_create_crl(X509.CRL* crl);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_SAFEBAG_create0_p8inf")]
		public extern static SAFEBAG* SAFEBAG_create0_p8inf(PKCS8.PRIV_KEY_INFO* p8);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_SAFEBAG_create0_pkcs8")]
		public extern static SAFEBAG* SAFEBAG_create0_pkcs8(X509.SIG* p8);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_SAFEBAG_create_pkcs8_encrypt")]
		public extern static SAFEBAG* SAFEBAG_create_pkcs8_encrypt(int pbe_nid, char8* pass, int passlen, uint8* salt, int saltlen, int iter, PKCS8.PRIV_KEY_INFO* p8inf);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_item_pack_safebag")]
		public extern static SAFEBAG* item_pack_safebag(void* obj, ASN1.ITEM* it, int nid1, int nid2);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_decrypt_skey")]
		public extern static PKCS8.PRIV_KEY_INFO* decrypt_skey(SAFEBAG* bag, char8* pass, int passlen);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_pack_p7data")]
		public extern static PKCS7.pkcs7_st* pack_p7data(stack_st_PKCS12_SAFEBAG *sk);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_unpack_p7data")]
		public extern static stack_st_PKCS12_SAFEBAG* unpack_p7data(PKCS7.pkcs7_st* p7);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_pack_p7encdata")]
		public extern static PKCS7.pkcs7_st* pack_p7encdata(int pbe_nid, char8* pass, int passlen, uint8* salt, int saltlen, int iter, stack_st_PKCS12_SAFEBAG* bags);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_unpack_p7encdata")]
		public extern static stack_st_PKCS12_SAFEBAG* unpack_p7encdata(PKCS7.pkcs7_st* p7, char8* pass, int passlen);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_pack_authsafes")]
		public extern static int pack_authsafes(PKCS12_st* p12, PKCS7.stack_st_PKCS7* safes);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_unpack_authsafes")]
		public extern static PKCS7.stack_st_PKCS7* unpack_authsafes(PKCS12_st* p12);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_add_localkeyid")]
		public extern static int add_localkeyid(SAFEBAG* bag, uint8* name, int namelen);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_add_friendlyname_asc")]
		public extern static int add_friendlyname_asc(SAFEBAG* bag, char8* name, int namelen);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_add_friendlyname_utf8")]
		public extern static int add_friendlyname_utf8(SAFEBAG* bag, char8* name, int namelen);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_add_CSPName_asc")]
		public extern static int add_CSPName_asc(SAFEBAG* bag, char8* name, int namelen);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_add_friendlyname_uni")]
		public extern static int add_friendlyname_uni(SAFEBAG* bag, uint8* name, int namelen);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_get_attr_gen")]
		public extern static ASN1.TYPE* get_attr_gen(X509.stack_st_X509_ATTRIBUTE* attrs, int attr_nid);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_get_friendlyname")]
		public extern static char8* get_friendlyname(SAFEBAG* bag);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_SAFEBAG_get0_attrs")]
		public extern static X509.stack_st_X509_ATTRIBUTE* SAFEBAG_get0_attrs(SAFEBAG* bag);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_pbe_crypt")]
		public extern static uint8* pbe_crypt(X509.ALGOR* algor, char8* pass, int passlen,  uint8* inVal, int inlen, uint8** data, int* datalen, int en_de);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_item_decrypt_d2i")]
		public extern static void* item_decrypt_d2i(X509.ALGOR* algor, ASN1.ITEM* it, char8* pass, int passlen, ASN1.OCTET_STRING* oct, int zbuf);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_item_i2d_encrypt")]
		public extern static ASN1.OCTET_STRING* item_i2d_encrypt(X509.ALGOR* algor, ASN1.ITEM* it, char8* pass, int passlen, void* obj, int zbuf);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_init")]
		public extern static PKCS12_st* init(int mode);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_key_gen_asc")]
		public extern static int key_gen_asc(char8* pass, int passlen, uint8* salt, int saltlen, int id, int iter, int n, uint8* outVal, EVP.MD* md_type);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_key_gen_uni")]
		public extern static int key_gen_uni(uint8* pass, int passlen, uint8* salt, int saltlen, int id, int iter, int n, uint8* outVal, EVP.MD* md_type);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_key_gen_utf8")]
		public extern static int key_gen_utf8(char8* pass, int passlen, uint8* salt, int saltlen, int id, int iter, int n, uint8* outVal, EVP.MD* md_type);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_PBE_keyivgen")]
		public extern static int PBE_keyivgen(EVP.CIPHER_CTX* ctx, char8* pass, int passlen, ASN1.TYPE* param, EVP.CIPHER* cipher, EVP.MD* md_type, int en_de);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_gen_mac")]
		public extern static int gen_mac(PKCS12_st* p12, char8* pass, int passlen, uint8* mac, uint* maclen);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_verify_mac")]
		public extern static int verify_mac(PKCS12_st* p12, char8* pass, int passlen);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_set_mac")]
		public extern static int set_mac(PKCS12_st* p12, char8* pass, int passlen, uint8* salt, int saltlen, int iter, EVP.MD* md_type);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_setup_mac")]
		public extern static int setup_mac(PKCS12_st* p12, int iter, uint8* salt, int saltlen, EVP.MD* md_type);

		/*
		DECLARE_ASN1_FUNCTIONS(PKCS12)
		DECLARE_ASN1_FUNCTIONS(PKCS12_MAC_DATA)
		DECLARE_ASN1_FUNCTIONS(PKCS12_SAFEBAG)
		DECLARE_ASN1_FUNCTIONS(PKCS12_BAGS)

		DECLARE_ASN1_ITEM(PKCS12_SAFEBAGS)
		DECLARE_ASN1_ITEM(PKCS12_AUTHSAFES)
		*/

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_PBE_add")]
		public extern static void PBE_add();
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_parse")]
		public extern static int parse(PKCS12_st* p12, char8* pass, EVP.PKEY** pkey, X509.x509_st** cert, X509.stack_st_X509** ca);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_create")]
		public extern static PKCS12_st* create(char8* pass, char8* name, EVP.PKEY* pkey, X509.x509_st* cert, X509.stack_st_X509* ca, int nid_key, int nid_cert, int iter, int mac_iter, int keytype);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_add_cert")]
		public extern static SAFEBAG* add_cert(stack_st_PKCS12_SAFEBAG** pbags, X509.x509_st* cert);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_add_key")]
		public extern static SAFEBAG* add_key(stack_st_PKCS12_SAFEBAG** pbags, EVP.PKEY* key, int key_usage, int iter, int key_nid, char8* pass);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_add_safe")]
		public extern static int add_safe(PKCS7.stack_st_PKCS7** psafes, stack_st_PKCS12_SAFEBAG* bags, int safe_nid, int iter, char8* pass);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_add_safes")]
		public extern static PKCS12_st* add_safes(PKCS7.stack_st_PKCS7* safes, int p7_nid);

		[Import(OPENSSL_LIB_CRYPTO), CLink]
		public extern static int i2d_PKCS12_bio(BIO.bio_st* bp, PKCS12_st* p12 );
#if !OPENSSL_NO_STDIO
		[Import(OPENSSL_LIB_CRYPTO), CLink]
		public extern static int i2d_PKCS12_fp(Platform.BfpFile* fp, PKCS12_st* p12);
#endif
		[Import(OPENSSL_LIB_CRYPTO), CLink]
		public extern static PKCS12_st* d2i_PKCS12_bio(BIO.bio_st* bp, PKCS12_st** p12);
#if !OPENSSL_NO_STDIO
		[Import(OPENSSL_LIB_CRYPTO), CLink]
		public extern static PKCS12_st* d2i_PKCS12_fp(Platform.BfpFile* fp, PKCS12_st** p12);
#endif
		[Import(OPENSSL_LIB_CRYPTO), LinkName("PKCS12_newpass")]
		public extern static int newpass(PKCS12_st* p12, char8* oldpass, char8* newpass);
	}
}
