/*
* Generated by util/mkerr.pl DO NOT EDIT
* Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.
*
* Licensed under the OpenSSL license (the "License").  You may not use
* this file except in compliance with the License.  You can obtain a copy
* in the file LICENSE in the source distribution or at
* https://www.openssl.org/source/license.html
*/
using System;

namespace Beef_Net.OpenSSL
{
	[AlwaysInclude]
	sealed abstract class MD2
	{
#if !OPENSSL_NO_MD2
		public typealias INT = uint8;
		
		public const int DIGEST_LENGTH = 16;
		public const int BLOCK         = 16;

		[CRepr]
		public struct state_st
		{
		    public uint num;
		    public uint8[BLOCK] data;
		    public INT[BLOCK] cksm;
		    public INT[BLOCK] state;
		}
		public typealias CTX = state_st;
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MD2_options")
		]
		public extern static char8* options();
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MD2_Init")
		]
		public extern static int Init(CTX* c);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MD2_Update")
		]
		public extern static int Update(CTX* c, uint8* data, uint len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MD2_Final")
		]
		public extern static int Final(uint8* md, CTX* c);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MD2")
		]
		public extern static uint8* MD2_(uint8* d, uint n, uint8* md);
#endif
	}
	
	[AlwaysInclude]
	sealed abstract class MD4
	{
#if !OPENSSL_NO_MD4
		/*-
		 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		 * ! MD4_LONG has to be at least 32 bits wide.                     !
		 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		 */
		public typealias LONG = uint;
		
		public const int CBLOCK        = 64;
		public const int LBLOCK        = CBLOCK / 4;
		public const int DIGEST_LENGTH = 16;

		[CRepr]
		public struct state_st
		{
		    public LONG A;
			public LONG B;
			public LONG C;
			public LONG D;
		    public LONG Nl;
			public LONG Nh;
		    public LONG[LBLOCK] data;
		    public uint num;
		}
		public typealias CTX = state_st;
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MD4_Init")
		]
		public extern static int Init(CTX* c);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MD4_Update")
		]
		public extern static int Update(CTX* c, void* data, uint len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MD4_Final")
		]
		public extern static int Final(uint8* md, CTX* c);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MD4")
		]
		public extern static uint8* MD4_(uint8* d, uint n, uint8* md);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MD4_Transform")
		]
		public extern static void Transform(CTX* c, uint8* b);
#endif
	}
	
	[AlwaysInclude]
	sealed abstract class MD5
	{
#if !OPENSSL_NO_MD5
		/*
		 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		 * ! MD5_LONG has to be at least 32 bits wide.                     !
		 * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		 */
		public typealias LONG = uint;
		
		public const int CBLOCK        = 64;
		public const int LBLOCK        = CBLOCK / 4;
		public const int DIGEST_LENGTH = 16;

		[CRepr]
		public struct state_st
		{
		    public LONG A;
			public LONG B;
			public LONG C;
			public LONG D;
		    public LONG Nl;
			public LONG Nh;
		    public LONG[LBLOCK] data;
		    public uint num;
		}
		public typealias CTX = state_st;
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MD5_Init")
		]
		public extern static int Init(CTX* c);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MD5_Update")
		]
		public extern static int Update(CTX* c, void* data, uint len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MD5_Final")
		]
		public extern static int Final(uint8* md, CTX* c);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MD5")
		]
		public extern static uint8* MD5_(uint8* d, uint n, uint8* md);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MD5_Transform")
		]
		public extern static void Transform(CTX* c, uint8* b);
#endif
	}
	
	[AlwaysInclude]
	sealed abstract class MDC2
	{
#if !OPENSSL_NO_MDC2
		public const int BLOCK         = 8;
		public const int DIGEST_LENGTH = 16;

		[CRepr]
		public struct ctx_st
		{
		    public uint num;
		    public uint8[BLOCK] data;
		    public DES.cblock h;
		    public DES.cblock hh;
		    public int pad_type;      /* either 1 or 2, default 1 */
		}
		public typealias CTX = ctx_st;
		
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MDC2_Init")
		]
		public extern static int Init(CTX*c );
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MDC2_Update")
		]
		public extern static int Update(CTX* c, uint8* data, uint len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MDC2_Final")
		]
		public extern static int Final(uint8* md, CTX* c);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("MDC2")
		]
		public extern static uint8* MDC2_(uint8* d, uint n, uint8* md);
#endif
	}
}
