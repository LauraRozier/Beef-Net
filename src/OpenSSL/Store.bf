/*
* Generated by util/mkerr.pl DO NOT EDIT
* Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.
*
* Licensed under the OpenSSL license (the "License").  You may not use
* this file except in compliance with the License.  You can obtain a copy
* in the file LICENSE in the source distribution or at
* https://www.openssl.org/source/license.html
*/
using System;

namespace Beef_Net.OpenSSL
{
	sealed abstract class OSSL_Store
	{
		/*-
		 *  The main OSSL_STORE functions.
		 *  ------------------------------
		 *
		 *  These allow applications to open a channel to a resource with supported data (keys, certs, crls, ...), read the data a piece at a time and decide what to do with it, and finally close.
		 */
		[CRepr]
		public struct ctx_st
		{
		    public LOADER* loader;
		    public LOADER_CTX* loader_ctx;
		    public UI.METHOD* ui_method;
		    public void* ui_data;
		    public post_process_info_fn post_process;
		    public void* post_process_data;
		    public int expected_type;
		    /* 0 before the first STORE_load(), 1 otherwise */
		    public int loading;
		}
		public typealias CTX = ctx_st;

		[CRepr]
		public struct info_st
		{
		    public int type;
		    public __struct _;

			[CRepr, Union]
			public struct __struct
			{
		        public void* data;               /* used internally as generic pointer */
		        public embedded_struct embedded; /* when type == INFO_EMBEDDED */
		        public name_struct name;         /* when type == INFO_NAME */
		        public EVP.PKEY* params_;        /* when type == INFO_PARAMS */
		        public EVP.PKEY* pkey;           /* when type == INFO_PKEY */
		        public X509.x509_st* x509;       /* when type == INFO_CERT */
		        public X509.CRL* crl;            /* when type == INFO_CRL */

				[CRepr]
				public struct embedded_struct
				{
		            public Buffer.MEM* blob;
		            public char8* pem_name;
				}

				[CRepr]
				public struct name_struct
				{
		            public char8* name;
		            public char8* desc;
				}
			}
		}
		public typealias INFO = info_st;

		[CRepr]
		public struct search_st
		{
		    public int search_type;
		    /* Used by SEARCH_BY_NAME and SEARCH_BY_ISSUER_SERIAL */
		    public X509.NAME* name;
		    /* Used by SEARCH_BY_ISSUER_SERIAL */
		    public ASN1.INTEGER* serial;
		    /* Used by SEARCH_BY_KEY_FINGERPRINT */
		    public EVP.MD* digest;
		    /* Used by SEARCH_BY_KEY_FINGERPRINT and SEARCH_BY_ALIAS */
		    public uint8* string;
		    public uint stringlength;
		}
		public typealias SEARCH = search_st;

		/* Typedef for the INFO post processing callback.  This can be used to massage the given INFO, or to drop it entirely (by returning NULL). */
		public function INFO* post_process_info_fn(INFO* inf, void* args);

		/*
		 * Open a channel given a URI.
		 * The given UI method will be used any time the loader needs extra input, for example when a password or pin is needed, and will be passed the same user data every time it's needed in this context.
		 *
		 * Returns a context reference which represents the channel to communicate through.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_open")
		]
		public extern static CTX* open(char8* uri, UI.METHOD* ui_method, void* ui_data, post_process_info_fn post_process, void* post_process_data);

		/*
		 * Control / fine tune the OSSL_STORE channel.
		 * |cmd| determines what is to be done, and depends on the underlying loader (use get0_scheme to determine which loader is used), except for common commands (see below).
		 * Each command takes different arguments.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_ctrl")
		]
		public extern static int ctrl(CTX* ctx, int cmd, ... /* args */);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_vctrl")
		]
		public extern static int vctrl(CTX* ctx, int cmd, void* args);

		/*
		 * Common ctrl commands that different loaders may choose to support.
		 */
		/* int on = 0 or 1; ctrl(ctx, C_USE_SECMEM, &on); */
		public const int C_USE_SECMEM   = 1;
		/* Where custom commands start */
		public const int C_CUSTOM_START = 100;

		/*
		 * Read one data item (a key, a cert, a CRL) that is supported by the OSSL_STORE functionality, given a context.
		 * Returns a INFO pointer, from which OpenSSL typed data can be extracted with INFO_get0_PKEY(), INFO_get0_CERT(), ...
		 * NULL is returned on error, which may include that the data found at the URI can't be figured out for certain or is ambiguous.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_load")
		]
		public extern static INFO* load(CTX* ctx);

		/* Check if end of data (end of file) is reached Returns 1 on end, 0 otherwise. */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_eof")
		]
		public extern static int eof(CTX* ctx);

		/* Check if an error occurred Returns 1 if it did, 0 otherwise. */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_error")
		]
		public extern static int error(CTX* ctx);

		/* Close the channel Returns 1 on success, 0 on error. */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_close")
		]
		public extern static int close(CTX* ctx);

		/*-
		 *  Extracting OpenSSL types from and creating new INFOs
		 *  ---------------------------------------------------------------
		 */
		/* Types of data that can be ossl_stored in a INFO.  INFO_NAME is typically found when getting a listing of available "files" / "tokens" / what have you. */
		public const int INFO_NAME   = 1; /* char8*  */
		public const int INFO_PARAMS = 2; /* EVP_PKEY * */
		public const int INFO_PKEY   = 3; /* EVP_PKEY * */
		public const int INFO_CERT   = 4; /* X509 * */
		public const int INFO_CRL    = 5; /* X509_CRL * */

		/*
		 * Functions to generate INFOs, one function for each type we support having in them, as well as a generic constructor.
		 *
		 * In all cases, ownership of the object is transferred to the INFO and will therefore be freed when the INFO is freed.
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_new_NAME")
		]
		public extern static INFO* INFO_new_NAME(char8* name);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_set0_NAME_description")
		]
		public extern static int INFO_set0_NAME_description(INFO* info, char8* desc);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_new_PARAMS")
		]
		public extern static INFO* INFO_new_PARAMS(EVP.PKEY* params_);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_new_PKEY")
		]
		public extern static INFO* INFO_new_PKEY(EVP.PKEY* pkey);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_new_CERT")
		]
		public extern static INFO* INFO_new_CERT(X509.x509_st* x509);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_new_CRL")
		]
		public extern static INFO* INFO_new_CRL(X509.CRL* crl);

		/* Functions to try to extract data from a INFO. */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_get_type")
		]
		public extern static int INFO_get_type(INFO* info);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_get0_NAME")
		]
		public extern static char8* INFO_get0_NAME(INFO* info);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_get1_NAME")
		]
		public extern static char8* INFO_get1_NAME(INFO* info);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_get0_NAME_description")
		]
		public extern static char8* INFO_get0_NAME_description(INFO* info);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_get1_NAME_description")
		]
		public extern static char8* INFO_get1_NAME_description(INFO* info);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_get0_PARAMS")
		]
		public extern static EVP.PKEY* INFO_get0_PARAMS(INFO* info);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_get1_PARAMS")
		]
		public extern static EVP.PKEY* INFO_get1_PARAMS(INFO* info);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_get0_PKEY")
		]
		public extern static EVP.PKEY* INFO_get0_PKEY(INFO* info);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_get1_PKEY")
		]
		public extern static EVP.PKEY* INFO_get1_PKEY(INFO* info);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_get0_CERT")
		]
		public extern static X509.x509_st* INFO_get0_CERT(INFO* info);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_get1_CERT")
		]
		public extern static X509.x509_st* INFO_get1_CERT(INFO* info);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_get0_CRL")
		]
		public extern static X509.CRL* INFO_get0_CRL(INFO* info);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_get1_CRL")
		]
		public extern static X509.CRL* INFO_get1_CRL(INFO* info);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_type_string")
		]
		public extern static char8* INFO_type_string(int type);

		/* Free the INFO */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_INFO_free")
		]
		public extern static void INFO_free(INFO* info);

		/*-
		 *  Functions to construct a search URI from a base URI and search criteria
		 *  -----------------------------------------------------------------------
		 */
		/* OSSL_STORE search types */
		public const int SEARCH_BY_NAME            = 1; /* subject in certs, issuer in CRLs */
		public const int SEARCH_BY_ISSUER_SERIAL   = 2;
		public const int SEARCH_BY_KEY_FINGERPRINT = 3;
		public const int SEARCH_BY_ALIAS           = 4;

		/* To check what search types the scheme handler supports */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_supports_search")
		]
		public extern static int supports_search(CTX* ctx, int search_type);

		/* Search term constructors */
		/* The input is considered to be owned by the caller, and must therefore remain present throughout the lifetime of the returned SEARCH */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_SEARCH_by_name")
		]
		public extern static SEARCH* SEARCH_by_name(X509.NAME* name);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_SEARCH_by_issuer_serial")
		]
		public extern static SEARCH* SEARCH_by_issuer_serial(X509.NAME* name, ASN1.INTEGER* serial);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_SEARCH_by_key_fingerprint")
		]
		public extern static SEARCH* SEARCH_by_key_fingerprint(EVP.MD* digest, uint8* bytes, uint len);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_SEARCH_by_alias")
		]
		public extern static SEARCH* SEARCH_by_alias(char8* alias);

		/* Search term destructor */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_SEARCH_free")
		]
		public extern static void SEARCH_free(SEARCH* search);

		/* Search term accessors */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_SEARCH_get_type")
		]
		public extern static int SEARCH_get_type(SEARCH* criterion);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_SEARCH_get0_name")
		]
		public extern static X509.NAME* SEARCH_get0_name(SEARCH* criterion);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_SEARCH_get0_serial")
		]
		public extern static ASN1.INTEGER* SEARCH_get0_serial(SEARCH* criterion);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_SEARCH_get0_bytes")
		]
		public extern static uint8* SEARCH_get0_bytes(SEARCH* criterion, uint* length);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_SEARCH_get0_string")
		]
		public extern static char8* SEARCH_get0_string(SEARCH* criterion);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_SEARCH_get0_digest")
		]
		public extern static EVP.MD* SEARCH_get0_digest(SEARCH* criterion);

		/* Add search criterion and expected return type (which can be unspecified) to the loading channel.  This MUST happen before the first load(). */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_expect")
		]
		public extern static int expect(CTX* ctx, int expected_type);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_find")
		]
		public extern static int find(CTX* ctx, SEARCH* search);

		/*-
		 *  Function to register a loader for the given URI scheme.
		 *  -------------------------------------------------------
		 *
		 *  The loader receives all the main components of an URI except for the scheme.
		 */
		[CRepr]
		public struct loader_st
		{
		    public char8* scheme;
		    public Engine.ENGINE* engine;
		    public open_fn open;
		    public ctrl_fn ctrl;
		    public expect_fn expect;
		    public find_fn find;
		    public load_fn load;
		    public eof_fn eof;
		    public error_fn error;
		    public close_fn close;
		}
		public typealias LOADER = loader_st;
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_LOADER_new")
		]
		public extern static LOADER* LOADER_new(Engine.ENGINE* e, char8* scheme);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_LOADER_get0_engine")
		]
		public extern static Engine.ENGINE* LOADER_get0_engine(LOADER* loader);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_LOADER_get0_scheme")
		]
		public extern static char8* LOADER_get0_scheme(LOADER* loader);
		
		/*-
		 * The try_decode function is called to check if the blob of data can be used by this handler, and if it can, decodes it into a supported OpenSSL type and returns a INFO with the decoded data.
		 * Input:
		 *    pem_name:     If this blob comes from a PEM file, this holds the PEM name.  If it comes from another type of file, this is NULL.
		 *    pem_header:   If this blob comes from a PEM file, this holds the PEM headers.  If it comes from another type of file, this is NULL.
		 *    blob:         The blob of data to match with what this handler can use.
		 *    len:          The length of the blob.
		 *    handler_ctx:  For a handler marked repeatable, this pointer can be used to create a context for the handler.
		 *                  IT IS THE HANDLER'S RESPONSIBILITY TO CREATE AND DESTROY THIS CONTEXT APPROPRIATELY, i.e. create on first call and destroy when about to return NULL.
		 *    matchcount:   A pointer to an int to count matches for this data.
		 *                  Usually becomes 0 (no match) or 1 (match!), but may be higher in the (unlikely) event that the data matches more than one possibility.  The int will always be zero when the function is called.
		 *    ui_method:    Application UI method for getting a password, pin or any other interactive data.
		 *    ui_data:      Application data to be passed to ui_method when it's called.
		 * Output:
		 *    a INFO
		 */
		public function INFO* file_try_decode_fn(char8* pem_name, char8* pem_header, uint8* blob, uint len, void** handler_ctx, int* matchcount, UI.METHOD* ui_method, void* ui_data);
		/* The eof function should return 1 if there's no more data to be found with the handler_ctx, otherwise 0.  This is only used when the handler is marked repeatable. */
		public function int file_eof_fn(void* handler_ctx);
		/* The destroy_ctx function is used to destroy the handler_ctx that was initiated by a repeatable try_decode function.  This is only used when the handler is marked repeatable. */
		public function void file_destroy_ctx_fn(void** handler_ctx);

		[CRepr]
		public struct file_handler_st
		{
		    public char8* name;
		    public file_try_decode_fn try_decode;
		    public file_eof_fn eof;
		    public file_destroy_ctx_fn destroy_ctx;
		    /* flags */
		    public int repeatable;
		}
		public typealias FILE_HANDLER = file_handler_st;

		/* struct loader_ctx_st is defined differently by each loader */
		[CRepr]
		public struct loader_ctx_st
		{
			public type_enum type;
		    public int errcnt;
			public const int FILE_FLAG_SECMEM = 1 << 0;
		    public uint flags;
		    public __struct _;

		    /* Expected object type.  May be unspecified */
		    public int expected_type;

			[CRepr]
		    public enum type_enum
			{
		        is_raw = 0,
		        is_pem,
		        is_dir
		    }

			[CRepr, Union]
			public struct __struct
			{
				public file_struct file;
				public dir_struct dir;

				[CRepr]
		        public struct file_struct /* Used with is_raw and is_pem */
				{
		            public BIO.bio_st* file;
		            /* The following are used when the handler is marked as repeatable */
		            public FILE_HANDLER* last_handler;
		            public void* last_handler_ctx;
		        }

				[CRepr]
		        public struct dir_struct /* Used with is_dir */
				{
		            public OpenSSL.DIR_CTX* ctx;
		            public int end_reached;
		            public char8* uri;
		            /* When a search expression is given, these are filled in. |search_name| contains the file basename to look for. The string is exactly 8 characters long. */
		            public char8[9] search_name;
		            /* The directory reading utility we have combines opening with reading the first name.  To make sure we can detect the end at the right time, we read early and cache the name. */
		            public char8* last_entry;
		            public int last_errno;
		        }
			}
		}
		public typealias LOADER_CTX = loader_ctx_st;
		public function LOADER_CTX* open_fn(LOADER* loader, char8* uri, UI.METHOD* ui_method, void* ui_data);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_LOADER_set_open")
		]
		public extern static int LOADER_set_open(LOADER* loader, open_fn open_function);
		public function int ctrl_fn(LOADER_CTX* ctx, int cmd, void* args);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_LOADER_set_ctrl")
		]
		public extern static int LOADER_set_ctrl(LOADER* loader, ctrl_fn ctrl_function);
		public function int expect_fn(LOADER_CTX* ctx, int expected);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_LOADER_set_expect")
		]
		public extern static int LOADER_set_expect(LOADER* loader, expect_fn expect_function);
		public function int find_fn(LOADER_CTX* ctx, SEARCH* criteria);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_LOADER_set_find")
		]
		public extern static int LOADER_set_find(LOADER* loader, find_fn find_function);
		public function INFO* load_fn(LOADER_CTX* ctx, UI.METHOD* ui_method, void* ui_data);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_LOADER_set_load")
		]
		public extern static int LOADER_set_load(LOADER* loader, load_fn load_function);
		public function int eof_fn(LOADER_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_LOADER_set_eof")
		]
		public extern static int LOADER_set_eof(LOADER* loader, eof_fn eof_function);
		public function int error_fn(LOADER_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_LOADER_set_error")
		]
		public extern static int LOADER_set_error(LOADER* loader, error_fn error_function);
		public function int close_fn(LOADER_CTX* ctx);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_LOADER_set_close")
		]
		public extern static int LOADER_set_close(LOADER* loader, close_fn close_function);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_LOADER_free")
		]
		public extern static void LOADER_free(LOADER* loader);

		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_register_loader")
		]
		public extern static int register_loader(LOADER* loader);
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_unregister_loader")
		]
		public extern static LOADER* unregister_loader(char8* scheme);

		/*-
		 *  Functions to list STORE loaders
		 *  -------------------------------
		 */
		[
#if !OPENSSL_LINK_STATIC
			Import(OPENSSL_LIB_CRYPTO),
#endif
			LinkName("OSSL_STORE_do_all_loaders")
		]
		public extern static int do_all_loaders(function void(LOADER* loader, void* do_arg) do_function, void* do_arg);
	}
}
