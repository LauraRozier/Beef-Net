/*
* Generated by util/mkerr.pl DO NOT EDIT
* Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.
*
* Licensed under the OpenSSL license (the "License").  You may not use
* this file except in compliance with the License.  You can obtain a copy
* in the file LICENSE in the source distribution or at
* https://www.openssl.org/source/license.html
*/
using System;

namespace Beef_Net.OpenSSL
{
	[AlwaysInclude]
	sealed abstract class Engine
	{
		/*
		 * This is a structure for storing implementations of various crypto
		 * algorithms and functions.
		 */
		[CRepr]
		public struct engine_st {
		    public char8* id;
		    public char8* name;
		    public RSA.METHOD* rsa_meth;
		    public DSA.METHOD* dsa_meth;
		    public DH.METHOD* dh_meth;
		    public EC.KEY_METHOD* ec_meth;
		    public Rand.METHOD* rand_meth;
		    /* Cipher handling is via this callback */
		    public Engine.CIPHERS_PTR ciphers;
		    /* Digest handling is via this callback */
		    public Engine.DIGESTS_PTR digests;
		    /* Public key handling via this callback */
		    public Engine.PKEY_METHS_PTR pkey_meths;
		    /* ASN1 public key handling via this callback */
		    public Engine.PKEY_ASN1_METHS_PTR pkey_asn1_meths;
		    public Engine.GEN_INT_FUNC_PTR destroy;
		    public Engine.GEN_INT_FUNC_PTR init;
		    public Engine.GEN_INT_FUNC_PTR finish;
		    public Engine.CTRL_FUNC_PTR ctrl;
		    public Engine.LOAD_KEY_PTR load_privkey;
		    public Engine.LOAD_KEY_PTR load_pubkey;
		    public SSL.CLIENT_CERT_PTR load_ssl_client_cert;
		    public Engine.CMD_DEFN* cmd_defns;
		    public int flags;
		    /* reference count on the structure itself */
		    public Crypto.REF_COUNT struct_ref;
		    /*
		     * reference count on usability of the engine type. NB: This controls the
		     * loading and initialisation of any functionality required by this
		     * engine, whereas the previous count is simply to cope with
		     * (de)allocation of this structure. Hence, running_ref <= struct_ref at
		     * all times.
		     */
		    public int funct_ref;
		    /* A place to store per-ENGINE data */
		    public Crypto.EX_DATA ex_data;
		    /* Used to maintain the linked-list of engines. */
			public engine_st* prev;
		    public engine_st* next;
		}
		public typealias ENGINE = engine_st;

#if !OPENSSL_NO_ENGINE
		[Import(OPENSSL_LIB_CRYPTO), CLink]
		public extern static int ERR_load_ENGINE_strings();

		/*
		 * ENGINE function codes.
		 */
		public const int F_DIGEST_UPDATE                   = 198;
		public const int F_DYNAMIC_CTRL                    = 180;
		public const int F_DYNAMIC_GET_DATA_CTX            = 181;
		public const int F_DYNAMIC_LOAD                    = 182;
		public const int F_DYNAMIC_SET_DATA_CTX            = 183;
		public const int F_ENGINE_ADD                      = 105;
		public const int F_ENGINE_BY_ID                    = 106;
		public const int F_ENGINE_CMD_IS_EXECUTABLE        = 170;
		public const int F_ENGINE_CTRL                     = 142;
		public const int F_ENGINE_CTRL_CMD                 = 178;
		public const int F_ENGINE_CTRL_CMD_STRING          = 171;
		public const int F_ENGINE_FINISH                   = 107;
		public const int F_ENGINE_GET_CIPHER               = 185;
		public const int F_ENGINE_GET_DIGEST               = 186;
		public const int F_ENGINE_GET_FIRST                = 195;
		public const int F_ENGINE_GET_LAST                 = 196;
		public const int F_ENGINE_GET_NEXT                 = 115;
		public const int F_ENGINE_GET_PKEY_ASN1_METH       = 193;
		public const int F_ENGINE_GET_PKEY_METH            = 192;
		public const int F_ENGINE_GET_PREV                 = 116;
		public const int F_ENGINE_INIT                     = 119;
		public const int F_ENGINE_LIST_ADD                 = 120;
		public const int F_ENGINE_LIST_REMOVE              = 121;
		public const int F_ENGINE_LOAD_PRIVATE_KEY         = 150;
		public const int F_ENGINE_LOAD_PUBLIC_KEY          = 151;
		public const int F_ENGINE_LOAD_SSL_CLIENT_CERT     = 194;
		public const int F_ENGINE_NEW                      = 122;
		public const int F_ENGINE_PKEY_ASN1_FIND_STR       = 197;
		public const int F_ENGINE_REMOVE                   = 123;
		public const int F_ENGINE_SET_DEFAULT_STRING       = 189;
		public const int F_ENGINE_SET_ID                   = 129;
		public const int F_ENGINE_SET_NAME                 = 130;
		public const int F_ENGINE_TABLE_REGISTER           = 184;
		public const int F_ENGINE_UNLOCKED_FINISH          = 191;
		public const int F_ENGINE_UP_REF                   = 190;
		public const int F_INT_CLEANUP_ITEM                = 199;
		public const int F_INT_CTRL_HELPER                 = 172;
		public const int F_INT_ENGINE_CONFIGURE            = 188;
		public const int F_INT_ENGINE_MODULE_INIT          = 187;
		public const int F_OSSL_HMAC_INIT                  = 200;
		
		/*
		 * ENGINE reason codes.
		 */
		public const int R_ALREADY_LOADED                  = 100;
		public const int R_ARGUMENT_IS_NOT_A_NUMBER        = 133;
		public const int R_CMD_NOT_EXECUTABLE              = 134;
		public const int R_COMMAND_TAKES_INPUT             = 135;
		public const int R_COMMAND_TAKES_NO_INPUT          = 136;
		public const int R_CONFLICTING_ENGINE_ID           = 103;
		public const int R_CTRL_COMMAND_NOT_IMPLEMENTED    = 119;
		public const int R_DSO_FAILURE                     = 104;
		public const int R_DSO_NOT_FOUND                   = 132;
		public const int R_ENGINES_SECTION_ERROR           = 148;
		public const int R_ENGINE_CONFIGURATION_ERROR      = 102;
		public const int R_ENGINE_IS_NOT_IN_LIST           = 105;
		public const int R_ENGINE_SECTION_ERROR            = 149;
		public const int R_FAILED_LOADING_PRIVATE_KEY      = 128;
		public const int R_FAILED_LOADING_PUBLIC_KEY       = 129;
		public const int R_FINISH_FAILED                   = 106;
		public const int R_ID_OR_NAME_MISSING              = 108;
		public const int R_INIT_FAILED                     = 109;
		public const int R_INTERNAL_LIST_ERROR             = 110;
		public const int R_INVALID_ARGUMENT                = 143;
		public const int R_INVALID_CMD_NAME                = 137;
		public const int R_INVALID_CMD_NUMBER              = 138;
		public const int R_INVALID_INIT_VALUE              = 151;
		public const int R_INVALID_STRING                  = 150;
		public const int R_NOT_INITIALISED                 = 117;
		public const int R_NOT_LOADED                      = 112;
		public const int R_NO_CONTROL_FUNCTION             = 120;
		public const int R_NO_INDEX                        = 144;
		public const int R_NO_LOAD_FUNCTION                = 125;
		public const int R_NO_REFERENCE                    = 130;
		public const int R_NO_SUCH_ENGINE                  = 116;
		public const int R_UNIMPLEMENTED_CIPHER            = 146;
		public const int R_UNIMPLEMENTED_DIGEST            = 147;
		public const int R_UNIMPLEMENTED_PUBLIC_KEY_METHOD = 101;
		public const int R_VERSION_INCOMPATIBILITY         = 145;

		/* These flags are used to control combinations of algorithm (methods) by bitwise "OR"ing. */
		public const uint METHOD_RSA             = 0x0001U;
		public const uint METHOD_DSA             = 0x0002U;
		public const uint METHOD_DH              = 0x0004U;
		public const uint METHOD_RAND            = 0x0008U;
		public const uint METHOD_CIPHERS         = 0x0040U;
		public const uint METHOD_DIGESTS         = 0x0080U;
		public const uint METHOD_PKEY_METHS      = 0x0200U;
		public const uint METHOD_PKEY_ASN1_METHS = 0x0400U;
		public const uint METHOD_EC              = 0x0800U;
		/* Obvious all-or-nothing cases. */
		public const uint METHOD_ALL             = 0xFFFFU;
		public const uint METHOD_NONE            = 0x0000U;
		
		/*
		 * This(ese) flag(s) controls behaviour of the ENGINE_TABLE mechanism used internally to control registration of ENGINE implementations, and can be set by set_table_flags().
		 * The "NOINIT" flag prevents attempts to initialise registered ENGINEs if they are not already initialised.
		 */
		public const uint TABLE_FLAG_NOINIT    = 0x0001U;
		
		/* ENGINE flags that can be set by set_flags(). */
		/* Not used */
		/* public const int FLAGS_MALLOCED        = 0x0001; */
		
		/*
		 * This flag is for ENGINEs that wish to handle the various 'CMD'-related control commands on their own. Without this flag, ctrl() handles these control commands on behalf of the ENGINE using
		 * their "cmd_defns" data.
		 */
		public const int FLAGS_MANUAL_CMD_CTRL = 0x0002;
		
		/*
		 * This flag is for ENGINEs who return new duplicate structures when found via "by_id()". When an ENGINE must store state (eg. if ctrl() commands are called in sequence as part of some stateful
		 * process like key-generation setup and execution), it can set this flag - then each attempt to obtain the ENGINE will result in it being copied into a new structure.
		 * Normally, ENGINEs don't declare this flag so by_id() just increments the existing ENGINE's structural reference count.
		 */
		public const int FLAGS_BY_ID_COPY      = 0x0004;
		
		/* This flag if for an ENGINE that does not want its methods registered as part of register_all_complete() for example if the methods are not usable as default methods. */
		public const int FLAGS_NO_REGISTER_ALL = 0x0008;
		
		/*
		 * ENGINEs can support their own command types, and these flags are used in CTRL_GET_CMD_FLAGS to indicate to the caller what kind of input each command expects.
		 * Currently only numeric and string input is supported. If a control command supports none of the _NUMERIC, _STRING, or _NO_INPUT options, then it is regarded as an "internal" control command
		 * - and not for use in config setting situations. As such, they're not available to the ctrl_cmd_string() function, only raw ctrl() access. Changes to this list of 'command types' should be reflected
		 * carefully in cmd_is_executable() and ctrl_cmd_string().
		 */
		
		/* accepts a 'long' input value (3rd parameter to ctrl) */
		public const uint CMD_FLAG_NUMERIC     = 0x0001U;
		/* accepts string input (cast from 'void*' to 'char8* ', 4th parameter to ctrl) */
		public const uint CMD_FLAG_STRING      = 0x0002U;
		/* Indicates that the control command takes *no* input. Ie. the control command is unparameterised. */
		public const uint CMD_FLAG_NO_INPUT    = 0x0004U;
		/* Indicates that the control command is internal. This control command won't be shown in any output, and is only usable through the ctrl_cmd() function. */
		public const uint CMD_FLAG_INTERNAL    = 0x0008U;
		
		/*
		 * NB: These 3 control commands are deprecated and should not be used.
		 * ENGINEs relying on these commands should compile conditional support for compatibility (eg. if these symbols are defined) but should also migrate the same functionality to their own ENGINE-specific
		 * control functions that can be "discovered" by calling applications. The fact these control commands wouldn't be "executable" (ie. usable by text-based config) doesn't change the fact that application
		 * code can find and use them without requiring per-ENGINE hacking.
		 */
		
		/*
		 * These flags are used to tell the ctrl function what should be done. All command numbers are shared between all engines, even if some don't make sense to some engines.
		 * In such a case, they do nothing but return the error R_CTRL_COMMAND_NOT_IMPLEMENTED.
		 */
		public const int CTRL_SET_LOGSTREAM         = 1;
		public const int CTRL_SET_PASSWORD_CALLBACK = 2;
		public const int CTRL_HUP                   = 3; /* Close and reinitialise any handles/connections etc. */
		public const int CTRL_SET_USER_INTERFACE    = 4; /* Alternative to callback */
		public const int CTRL_SET_CALLBACK_DATA     = 5; /* User-specific data, used when calling the password callback and the user interface */
		public const int CTRL_LOAD_CONFIGURATION    = 6; /* Load a configuration, given a string that represents a file name or so */
		public const int CTRL_LOAD_SECTION          = 7; /* Load data from a given section in the already loaded configuration */
		
		/*
		 * These control commands allow an application to deal with an arbitrary engine in a dynamic way. Warn: Negative return values indicate errors FOR THESE COMMANDS because zero is used to indicate 'end-of-list'.
		 * Other commands, including ENGINE-specific command types, return zero for an error. An ENGINE can choose to implement these ctrl functions, and can internally manage things however it chooses
		 * - it does so by setting the FLAGS_MANUAL_CMD_CTRL flag (using set_flags()). Otherwise the ctrl() code handles this on the ENGINE's behalf using the cmd_defns data (set using set_cmd_defns()).
		 * This means an ENGINE's ctrl() handler need only implement its own commands - the above "meta" commands will be taken care of.
		 */
		
		/*
		 * Returns non-zero if the supplied ENGINE has a ctrl() handler. If "not", then all the remaining control commands will return failure, so it is worth checking this first if the caller is trying to "discover" the
		 * engine's capabilities and doesn't want errors generated unnecessarily.
		 */
		public const int CTRL_HAS_CTRL_FUNCTION     = 10;
		/* Returns a positive command number for the first command supported by the engine. Returns zero if no ctrl commands are supported. */
		public const int CTRL_GET_FIRST_CMD_TYPE    = 11;
		/* The 'long' argument specifies a command implemented by the engine, and the return value is the next command supported, or zero if there are no more. */
		public const int CTRL_GET_NEXT_CMD_TYPE     = 12;
		/* The 'void*' argument is a command name (cast from 'char8* '), and the return value is the command that corresponds to it. */
		public const int CTRL_GET_CMD_FROM_NAME     = 13;
		/*
		 * The next two allow a command to be converted into its corresponding string form. In each case, the 'long' argument supplies the command. In the NAME_LEN case, the return value is the length of the
		 * command name (not counting a trailing EOL). In the NAME case, the 'void*' argument must be a string buffer large enough, and it will be populated with the name of the command (WITH a trailing EOL).
		 */
		public const int CTRL_GET_NAME_LEN_FROM_CMD = 14;
		public const int CTRL_GET_NAME_FROM_CMD     = 15;
		/* The next two are similar but give a "short description" of a command. */
		public const int CTRL_GET_DESC_LEN_FROM_CMD = 16;
		public const int CTRL_GET_DESC_FROM_CMD     = 17;
		/* With this command, the return value is the OR'd combination of CMD_FLAG_*** values that indicate what kind of input a given engine-specific ctrl command expects. */
		public const int CTRL_GET_CMD_FLAGS         = 18;
		
		/* ENGINE implementations should start the numbering of their own control commands from this value. (ie. CMD_BASE, CMD_BASE + 1, etc). */
		public const int CMD_BASE                   = 200;
		
		/*
		 * NB: These 2 nCipher "chil" control commands are deprecated, and their functionality is now available through ENGINE-specific control commands (exposed through the above-mentioned 'CMD'-handling).
		 * Code using these 2 commands should be migrated to the more general command handling before these are removed.
		 */
		
		/* Flags specific to the nCipher "chil" engine */
		public const int CTRL_CHIL_SET_FORKCHECK    = 100;
        /* Depending on the value of the (long)i argument, this sets or unsets the SimpleForkCheck flag in the CHIL API to enable or disable checking and workarounds for applications that fork(). */
		public const int CTRL_CHIL_NO_LOCKING       = 101;
        /* This prevents the initialisation function from providing mutex callbacks to the nCipher library. */
		
		/*
		 * If an ENGINE supports its own specific control commands and wishes the framework to handle the above 'CMD_***'-manipulation commands on its behalf, it should supply a null-terminated array of CMD_DEFN
		 * entries to set_cmd_defns(). It should also implement a ctrl() handler that supports the stated commands (ie. the "cmd_num" entries as described by the array). NB: The array must be ordered in increasing order
		 * of cmd_num. "null-terminated" means that the last CMD_DEFN element has cmd_num set to zero and/or cmd_name set to NULL.
		 */
		[CRepr]
		public struct CMD_DEFN_st {
		    public uint cmd_num;    /* The command number */
		    public char8* cmd_name; /* The command name itself */
		    public char8* cmd_desc; /* A short description of the command */
		    public uint cmd_flags;  /* The input the command expects */
		}
		public typealias CMD_DEFN = CMD_DEFN_st;
		
		/* Generic function pointer */
		public function int GEN_FUNC_PTR();
		/* Generic function pointer taking no arguments */
		public function int GEN_INT_FUNC_PTR(engine_st* e);
		/* Specific control function pointer */
		public function int CTRL_FUNC_PTR(engine_st* e, int a, int b, void* p, function void() f);
		/* Generic load_key function pointer */
		public function EVP.PKEY* LOAD_KEY_PTR(engine_st* e, char8* k, UI.METHOD* ui_method, void* callback_data);
		/*-
		 * These callback types are for an ENGINE's handler for cipher and digest logic.
		 * These handlers have these prototypes;
		 *   int foo(engine_st* e, EVP.CIPHER** cipher, int** nids, int nid);
		 *   int foo(engine_st* e, EVP.MD** digest, int** nids, int nid);
		 * Looking at how to implement these handlers in the case of cipher support, if the framework wants the EVP.CIPHER for 'nid', it will call;
		 *   foo(e, &p_evp_cipher, null, nid);    (return zero for failure)
		 * If the framework wants a list of supported 'nid's, it will call;
		 *   foo(e, null, &p_nids, 0); (returns number of 'nids' or -1 for error)
		 */
		/* Returns to a pointer to the array of supported cipher 'nid's. If the second parameter is non-NULL it is set to the size of the returned array. */
		public function int CIPHERS_PTR(engine_st* e, EVP.CIPHER** c, int** p, int l);
		public function int DIGESTS_PTR(engine_st* e, EVP.MD** md, int** p, int l);
		public function int PKEY_METHS_PTR(engine_st* e, EVP.PKEY_METHOD** m, int** p, int l);
		public function int PKEY_ASN1_METHS_PTR(engine_st* e, EVP.PKEY_ASN1_METHOD** m, int** p, int l);
		/*
		 * STRUCTURE functions ... all of these functions deal with pointers to ENGINE structures where the pointers have a "structural reference". This means that their reference is to allowed access to the structure but it
		 * does not imply that the structure is functional. To simply increment or decrement the structural reference count, use by_id and free. NB: This is not required when iterating using get_next
		 * as it will automatically decrement the structural reference count of the "current" ENGINE and increment the structural reference count of the ENGINE it returns (unless it is NULL).
		 */
		
		/* Get the first/last "ENGINE" type available. */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_first")]
		public extern static engine_st* get_first();
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_last")]
		public extern static engine_st* get_last();
		/* Iterate to the next/previous "ENGINE" type (NULL = end of the list). */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_next")]
		public extern static engine_st* get_next(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_prev")]
		public extern static engine_st* get_prev(engine_st* e);
		/* Add another "ENGINE" type into the array. */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_add")]
		public extern static int add(engine_st* e);
		/* Remove an existing "ENGINE" type from the array. */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_remove")]
		public extern static int remove(engine_st* e);
		/* Retrieve an engine from the list by its unique "id" value. */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_by_id")]
		public extern static engine_st* by_id(char8* id);

		[Inline]
		public static int load_openssl() => OpenSSL.init_crypto(OpenSSL.INIT_ENGINE_OPENSSL, null);
		[Inline]
		public static int load_dynamic() => OpenSSL.init_crypto(OpenSSL.INIT_ENGINE_DYNAMIC, null);
	#if !OPENSSL_NO_STATIC_ENGINE
		[Inline]
		public static int load_padlock() => OpenSSL.init_crypto(OpenSSL.INIT_ENGINE_PADLOCK, null);
		[Inline]
		public static int load_capi() => OpenSSL.init_crypto(OpenSSL.INIT_ENGINE_CAPI, null);
		[Inline]
		public static int load_afalg() => OpenSSL.init_crypto(OpenSSL.INIT_ENGINE_AFALG, null);
	#endif
		[Inline]
		public static int load_cryptodev() => OpenSSL.init_crypto(OpenSSL.INIT_ENGINE_CRYPTODEV, null);
		[Inline]
		public static int load_rdrand() => OpenSSL.init_crypto(OpenSSL.INIT_ENGINE_RDRAND, null);

		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_load_builtin_engines")]
		public extern static void load_builtin_engines();
		
		/* Get and set global flags (TABLE_FLAG_***) for the implementation "registry" handling. */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_table_flags")]
		public extern static uint get_table_flags();
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_table_flags")]
		public extern static void set_table_flags(uint flags);
		
		/*- Manage registration of ENGINEs per "table". For each type, there are 3
		 * functions;
		 *   register_***(e) - registers the implementation from 'e' (if it has one)
		 *   unregister_***(e) - unregister the implementation from 'e'
		 *   register_all_***() - call register_***() for each 'e' in the list
		 * Cleanup is automatically registered from each table when required.
		 */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_RSA")]
		public extern static int register_RSA(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_unregister_RSA")]
		public extern static void unregister_RSA(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_all_RSA")]
		public extern static void register_all_RSA();
		
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_DSA")]
		public extern static int register_DSA(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_unregister_DSA")]
		public extern static void unregister_DSA(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_all_DSA")]
		public extern static void register_all_DSA();
		
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_EC")]
		public extern static int register_EC(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_unregister_EC")]
		public extern static void unregister_EC(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_all_EC")]
		public extern static void register_all_EC();
		
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_DH")]
		public extern static int register_DH(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_unregister_DH")]
		public extern static void unregister_DH(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_all_DH")]
		public extern static void register_all_DH();
		
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_RAND")]
		public extern static int register_RAND(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_unregister_RAND")]
		public extern static void unregister_RAND(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_all_RAND")]
		public extern static void register_all_RAND();
		
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_ciphers")]
		public extern static int register_ciphers(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_unregister_ciphers")]
		public extern static void unregister_ciphers(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_all_ciphers")]
		public extern static void register_all_ciphers();
		
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_digests")]
		public extern static int register_digests(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_unregister_digests")]
		public extern static void unregister_digests(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_all_digests")]
		public extern static void register_all_digests();
		
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_pkey_meths")]
		public extern static int register_pkey_meths(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_unregister_pkey_meths")]
		public extern static void unregister_pkey_meths(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_all_pkey_meths")]
		public extern static void register_all_pkey_meths();
		
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_pkey_asn1_meths")]
		public extern static int register_pkey_asn1_meths(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_unregister_pkey_asn1_meths")]
		public extern static void unregister_pkey_asn1_meths(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_all_pkey_asn1_meths")]
		public extern static void register_all_pkey_asn1_meths();
		
		/*
		 * These functions register all support from the above categories. Note, use of these functions can result in static linkage of code your application may not need.
		 * If you only need a subset of functionality, consider using more selective initialisation.
		 */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_complete")]
		public extern static int register_complete(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_register_all_complete")]
		public extern static int register_all_complete();
		
		/*
		 * Send parameterised control commands to the engine. The possibilities to send down an integer, a pointer to data or a function pointer are provided. Any of the parameters may or may not be NULL,
		 * depending on the command number. In actuality, this function only requires a structural (rather than functional) reference to an engine, but many control commands may require the engine be functional.
		 * The caller should be aware of trying commands that require an operational ENGINE, and only use functional references in such situations.
		 */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_ctrl")]
		public extern static int ctrl(engine_st* e, int cmd, int i, void* p, function void() f);
		
		/*
		 * This function tests if an ENGINE-specific command is usable as a "setting". Eg. in an application's config file that gets processed through ctrl_cmd_string(). If this returns zero, it is not available to
		 * ctrl_cmd_string(), only ctrl().
		 */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_cmd_is_executable")]
		public extern static int cmd_is_executable(engine_st* e, int cmd);
		
		/*
		 * This function works like ctrl() with the exception of taking a command name instead of a command number, and can handle optional commands. See the comment on ctrl_cmd_string() for an explanation
		 * on how to use the cmd_name and cmd_optional.
		 */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_ctrl_cmd")]
		public extern static int ctrl_cmd(engine_st* e, char8* cmd_name, int i, void* p, function void() f, int cmd_optional);
		
		/*
		 * This function passes a command-name and argument to an ENGINE. The cmd_name is converted to a command number and the control command is called using 'arg' as an argument (unless the ENGINE doesn't support such
		 * a command, in which case no control command is called). The command is  checked for input flags, and if necessary the argument will be converted to a numeric value. If cmd_optional is non-zero, then if the ENGINE
		 * doesn't support the given cmd_name the return value will be success anyway. This function is intended for applications to use so that users (or config files) can supply engine-specific config data to the ENGINE at
		 * run-time to control behaviour of specific engines. As such, it shouldn't be used for calling ctrl() functions that return data, deal with binary data, or that are otherwise supposed to be used directly through
		 * ctrl() in application code. Any "return" data from an ctrl() operation in this function will be lost - the return value is interpreted as failure if the return value is zero, success otherwise, and this
		 * function returns a boolean value as a result. In other words, vendors of 'ENGINE'-enabled devices should write ENGINE implementations with parameterisations that work in this scheme, so that compliant ENGINE-based
		 * applications can work consistently with the same configuration for the same ENGINE-enabled devices, across applications.
		 */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_ctrl_cmd_string")]
		public extern static int ctrl_cmd_string(engine_st* e, char8* cmd_name, char8* arg, int cmd_optional);
		
		/*
		 * These functions are useful for manufacturing new ENGINE structures. They don't address reference counting at all - one uses them to populate an ENGINE structure with personalised implementations of things prior to
		 * using it directly or adding it to the builtin ENGINE list in OpenSSL. These are also here so that the ENGINE structure doesn't have to be exposed and break binary compatibility!
		 */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_new")]
		public extern static engine_st* new_();
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_free")]
		public extern static int free(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_up_ref")]
		public extern static int up_ref(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_id")]
		public extern static int set_id(engine_st* e, char8* id);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_name")]
		public extern static int set_name(engine_st* e, char8* name);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_RSA")]
		public extern static int set_RSA(engine_st* e, RSA.METHOD* rsa_meth);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_DSA")]
		public extern static int set_DSA(engine_st* e, DSA.METHOD* dsa_meth);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_EC")]
		public extern static int set_EC(engine_st* e, EC.KEY_METHOD* ecdsa_meth);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_DH")]
		public extern static int set_DH(engine_st* e, DH.METHOD* dh_meth);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_RAND")]
		public extern static int set_RAND(engine_st* e, Rand.METHOD* rand_meth);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_destroy_function")]
		public extern static int set_destroy_function(engine_st* e, GEN_INT_FUNC_PTR destroy_f);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_init_function")]
		public extern static int set_init_function(engine_st* e, GEN_INT_FUNC_PTR init_f);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_finish_function")]
		public extern static int set_finish_function(engine_st* e, GEN_INT_FUNC_PTR finish_f);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_ctrl_function")]
		public extern static int set_ctrl_function(engine_st* e, CTRL_FUNC_PTR ctrl_f);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_load_privkey_function")]
		public extern static int set_load_privkey_function(engine_st* e, LOAD_KEY_PTR loadpriv_f);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_load_pubkey_function")]
		public extern static int set_load_pubkey_function(engine_st* e, LOAD_KEY_PTR loadpub_f);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_load_ssl_client_cert_function")]
		public extern static int set_load_ssl_client_cert_function(engine_st* e, SSL.CLIENT_CERT_PTR loadssl_f);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_ciphers")]
		public extern static int set_ciphers(engine_st* e, CIPHERS_PTR f);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_digests")]
		public extern static int set_digests(engine_st* e, DIGESTS_PTR f);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_pkey_meths")]
		public extern static int set_pkey_meths(engine_st* e, PKEY_METHS_PTR f);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_pkey_asn1_meths")]
		public extern static int set_pkey_asn1_meths(engine_st* e, PKEY_ASN1_METHS_PTR f);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_flags")]
		public extern static int set_flags(engine_st* e, int flags);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_cmd_defns")]
		public extern static int set_cmd_defns(engine_st* e, CMD_DEFN* defns);
		/* These functions allow control over any per-structure ENGINE data. */
		[Inline]
		public static int get_ex_new_index(int l, void* p, Crypto.EX_new newf, Crypto.EX_dup dupf, Crypto.EX_free freef) => Crypto.get_ex_new_index(Crypto.EX_INDEX_ENGINE, l, p, newf, dupf, freef);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_ex_data")]
		public extern static int set_ex_data(engine_st* e, int idx, void* arg);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_ex_data")]
		public extern static void* get_ex_data(engine_st* e, int idx);
		
		/* This function previously cleaned up anything that needs it. Auto-deinit will now take care of it so it is no longer required to call this function. */
		[Inline, Obsolete("No longer available, no-op", true)]
		public static void cleanup() { while(false) continue; }
		
		/*
		 * These return values from within the ENGINE structure. These can be useful with functional references as well as structural references - it depends which you obtained. Using the result for functional purposes if you only
		 * obtained a structural reference may be problematic!
		 */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_id")]
		public extern static char8* get_id(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_name")]
		public extern static char8* get_name(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_RSA")]
		public extern static RSA.METHOD* get_RSA(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_DSA")]
		public extern static DSA.METHOD* get_DSA(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_EC")]
		public extern static EC.KEY_METHOD* get_EC(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_DH")]
		public extern static DH.METHOD* get_DH(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_RAND")]
		public extern static Rand.METHOD* get_RAND(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_destroy_function")]
		public extern static GEN_INT_FUNC_PTR get_destroy_function(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_init_function")]
		public extern static GEN_INT_FUNC_PTR get_init_function(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_finish_function")]
		public extern static GEN_INT_FUNC_PTR get_finish_function(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_ctrl_function")]
		public extern static CTRL_FUNC_PTR get_ctrl_function(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_load_privkey_function")]
		public extern static LOAD_KEY_PTR get_load_privkey_function(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_load_pubkey_function")]
		public extern static LOAD_KEY_PTR get_load_pubkey_function(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_ssl_client_cert_function")]
		public extern static SSL.CLIENT_CERT_PTR get_ssl_client_cert_function(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_ciphers")]
		public extern static CIPHERS_PTR get_ciphers(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_digests")]
		public extern static DIGESTS_PTR get_digests(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_pkey_meths")]
		public extern static PKEY_METHS_PTR get_pkey_meths(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_pkey_asn1_meths")]
		public extern static PKEY_ASN1_METHS_PTR get_pkey_asn1_meths(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_cipher")]
		public extern static EVP.CIPHER* get_cipher(engine_st* e, int nid);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_digest")]
		public extern static EVP.MD* get_digest(engine_st* e, int nid);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_pkey_meth")]
		public extern static EVP.PKEY_METHOD* get_pkey_meth(engine_st* e, int nid);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_pkey_asn1_meth")]
		public extern static EVP.PKEY_ASN1_METHOD* get_pkey_asn1_meth(engine_st* e, int nid);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_pkey_asn1_meth_str")]
		public extern static EVP.PKEY_ASN1_METHOD* get_pkey_asn1_meth_str(engine_st* e, char8* str, int len);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_pkey_asn1_find_str")]
		public extern static EVP.PKEY_ASN1_METHOD* pkey_asn1_find_str(engine_st** pe, char8* str, int len);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_cmd_defns")]
		public extern static CMD_DEFN* get_cmd_defns(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_flags")]
		public extern static int get_flags(engine_st* e);
		
		/*
		 * FUNCTIONAL functions. These functions deal with ENGINE structures that have (or will) be initialised for use. Broadly speaking, the structural functions are useful for iterating the list of available engine types,
		 * creating new engine types, and other "list" operations. These functions actually deal with ENGINEs that are to be used. As such these functions can fail (if applicable) when particular engines are unavailable
		 * - eg. if a hardware accelerator is not attached or not functioning correctly. Each ENGINE has 2 reference counts; structural and functional. Every time a functional reference is obtained or released,
		 * a corresponding structural reference is automatically obtained or released too.
		 */
		
		/* Initialise a engine type for use (or up its reference count if it's already in use). This will fail if the engine is not currently operational and cannot initialise. */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_init")]
		public extern static int init(engine_st* e);
		/* Free a functional reference to a engine type. This does not require a  corresponding call to free as it also releases a structural reference. */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_finish")]
		public extern static int finish(engine_st* e);
		
		/* The following functions handle keys that are stored in some secondary location, handled by the engine.  The storage may be on a card or whatever. */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_load_private_key")]
		public extern static EVP.PKEY* load_private_key(engine_st* e, char8* key_id, UI.METHOD* ui_method, void* callback_data);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_load_public_key")]
		public extern static EVP.PKEY* load_public_key(engine_st* e, char8* key_id, UI.METHOD* ui_method, void* callback_data);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_load_ssl_client_cert")]
		public extern static int load_ssl_client_cert(engine_st* e, SSL.ssl_st* s, X509.stack_st_X509_NAME* ca_dn, X509.x509_st** pcert, EVP.PKEY** ppkey, X509.stack_st_X509** pother, UI.METHOD* ui_method, void* callback_data);
		
		/* This returns a pointer for the current ENGINE structure that is (by default) performing any RSA operations. The value returned is an incremented reference, so it should be free'd (finish) before it is discarded. */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_default_RSA")]
		public extern static engine_st* get_default_RSA();
		/* Same for the other "methods" */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_default_DSA")]
		public extern static engine_st* get_default_DSA();
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_default_EC")]
		public extern static engine_st* get_default_EC();
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_default_DH")]
		public extern static engine_st* get_default_DH();
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_default_RAND")]
		public extern static engine_st* get_default_RAND();
		/* These functions can be used to get a functional reference to perform ciphering or digesting corresponding to "nid". */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_cipher_engine")]
		public extern static engine_st* get_cipher_engine(int nid);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_digest_engine")]
		public extern static engine_st* get_digest_engine(int nid);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_pkey_meth_engine")]
		public extern static engine_st* get_pkey_meth_engine(int nid);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_pkey_asn1_meth_engine")]
		public extern static engine_st* get_pkey_asn1_meth_engine(int nid);
		
		/*
		 * This sets a new default ENGINE structure for performing RSA operations. If the result is non-zero (success) then the ENGINE structure will have had its reference count up'd so the caller should still free their own
		 * reference 'e'.
		 */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_default_RSA")]
		public extern static int set_default_RSA(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_default_string")]
		public extern static int set_default_string(engine_st* e, char8* def_list);
		/* Same for the other "methods" */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_default_DSA")]
		public extern static int set_default_DSA(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_default_EC")]
		public extern static int set_default_EC(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_default_DH")]
		public extern static int set_default_DH(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_default_RAND")]
		public extern static int set_default_RAND(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_default_ciphers")]
		public extern static int set_default_ciphers(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_default_digests")]
		public extern static int set_default_digests(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_default_pkey_meths")]
		public extern static int set_default_pkey_meths(engine_st* e);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_default_pkey_asn1_meths")]
		public extern static int set_default_pkey_asn1_meths(engine_st* e);
		
		/*
		 * The combination "set" - the flags are bitwise "OR"d from the METHOD_*** defines above. As with the "register_complete()" function, this function can result in unnecessary static linkage. If your
		 * application requires only specific functionality, consider using more selective functions.
		 */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_set_default")]
		public extern static int set_default(engine_st* e, uint flags);
		
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_add_conf_module")]
		public extern static void add_conf_module();
		
		/* Deprecated functions ... */
		/*
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_clear_defaults")]
		public extern static int clear_defaults();
		*/
		
		/**************************/
		/* DYNAMIC ENGINE SUPPORT */
		/**************************/
		
		/*
		 * When compiling an ENGINE entirely as an external shared library, loadable by the "dynamic" ENGINE, these types are needed. The 'dynamic_fns' structure type provides the calling application's (or library's) error
		 * functionality and memory management function pointers to the loaded library. These should be used/set in the loaded library code so that the loading application's 'state' will be used/changed in all operations.
		 * The 'static_state' pointer allows the loaded library to know if it shares the same static data as the calling application (or library), and thus whether these callbacks need to be set or not.
		 */
		public function void* dyn_MEM_malloc_fn(int l, char8* p, int i);
		public function void* dyn_MEM_realloc_fn(void* pd, int l, char8* po, int i);
		public function void dyn_MEM_free_fn(void* p, char8* p, int i);
		[CRepr]
		public struct st_dynamic_MEM_fns
		{
		    public dyn_MEM_malloc_fn malloc_fn;
		    public dyn_MEM_realloc_fn realloc_fn;
		    public dyn_MEM_free_fn free_fn;
		}
		public typealias dynamic_MEM_fns = st_dynamic_MEM_fns;
		/* FIXME: Perhaps the memory and locking code (crypto.h) should declare and use these types so we (and any other dependent code) can simplify a bit?? */
		/* The top-level structure */
		[CRepr]
		public struct st_dynamic_fns
		{
		    public void* static_state;
		    public dynamic_MEM_fns mem_fns;
		}
		public typealias dynamic_fns = st_dynamic_fns;
		
		/*
		 * The version checking function should be of this prototype. NB: The ossl_version value passed in is the OSSL.DYNAMIC_VERSION of the loading code. If this function returns zero, it indicates a (potential) version
		 * incompatibility and the loaded library doesn't believe it can proceed. Otherwise, the returned value is the (latest) version supported by the loading library. The loader may still decide that the loaded code's
		 * version is unsatisfactory and could veto the load. The function is expected to be implemented with the symbol name "v_check", and a default implementation can be fully instantiated with
		 * IMPLEMENT_DYNAMIC_CHECK_FN().
		 */
		public function uint dynamic_v_check_fn(uint ossl_version);
		/*
		# define IMPLEMENT_DYNAMIC_CHECK_FN() =>
		OPENSSL_EXPORT unsigned long v_check(uint v);
		OPENSSL_EXPORT uint v_check(uint v)
		{
			if (v >= OSSL.DYNAMIC_OLDEST)
				return OSSL.DYNAMIC_VERSION;
		    return 0;
		}
		*/
		
		/*
		 * This function is passed the ENGINE structure to initialise with its own function and command settings. It should not adjust the structural or functional reference counts. If this function returns zero, (a) the load
		 * will be aborted, (b) the previous ENGINE state will be memcpy'd back onto the structure, and (c) the shared library will be unloaded. So implementations should do their own internal cleanup in failure
		 * circumstances otherwise they could leak. The 'id' parameter, if non-NULL, represents the ENGINE id that the loader is looking for. If this is NULL, the shared library can choose to return failure or to initialise a
		 * 'default' ENGINE. If non-NULL, the shared library must initialise only an ENGINE matching the passed 'id'. The function is expected to be implemented with the symbol name "bind_engine". A standard implementation
		 * can be instantiated with IMPLEMENT_DYNAMIC_BIND_FN(fn) where the parameter 'fn' is a callback function that populates the ENGINE structure and returns an int value (zero for failure). 'fn' should have prototype;
		 * [static] int fn(engine_st* e, char8* id);
		 */
		public function int dynamic_bind_engine(engine_st* e, char8* id, dynamic_fns* fns);
		/*
		# define IMPLEMENT_DYNAMIC_BIND_FN(fn) =>
		OPENSSL_EXPORT int bind_engine(engine_st* e, char8* id, dynamic_fns* fns);
		OPENSSL_EXPORT int bind_engine(engine_st* e, char8* id, dynamic_fns* fns)
		{
			if (get_static_state() != fns.static_state)
		        Crypto.set_mem_functions(fns.mem_fns.malloc_fn, fns.mem_fns.realloc_fn, fns.mem_fns.free_fn);

		    if (!fn(e, id))
				return 0;

		    return 1;
		}
		*/
		
		/*
		 * If the loading application (or library) and the loaded ENGINE library share the same static data (eg. they're both dynamically linked to the same libcrypto.so) we need a way to avoid trying to set system callbacks -
		 * this would fail, and for the same reason that it's unnecessary to try. If the loaded ENGINE has (or gets from through the loader) its own copy of the libcrypto static data, we will need to set the callbacks.
		 * The easiest way to detect this is to have a function that returns a pointer to some static data and let the loading application and loaded ENGINE compare their respective values.
		 */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("ENGINE_get_static_state")]
		public extern static void* get_static_state();
#endif
	}
}
