/*
* Generated by util/mkerr.pl DO NOT EDIT
* Copyright 1995-2019 The OpenSSL Project Authors. All Rights Reserved.
*
* Licensed under the OpenSSL license (the "License").  You may not use
* this file except in compliance with the License.  You can obtain a copy
* in the file LICENSE in the source distribution or at
* https://www.openssl.org/source/license.html
*/
using System;

namespace Beef_Net.OpenSSL
{
	[AlwaysInclude]
	sealed abstract class UI
	{
#if OPENSSL_NO_UI_CONSOLE
	#define OPENSSL_NO_UI
#endif

		[Import(OPENSSL_LIB_CRYPTO), CLink]
		public extern static int ERR_load_UI_strings();
		
		/*
		 * UI function codes.
		 */
		public const int F_CLOSE_CONSOLE                     = 115;
		public const int F_ECHO_CONSOLE                      = 116;
		public const int F_GENERAL_ALLOCATE_BOOLEAN          = 108;
		public const int F_GENERAL_ALLOCATE_PROMPT           = 109;
		public const int F_NOECHO_CONSOLE                    = 117;
		public const int F_OPEN_CONSOLE                      = 114;
		public const int F_UI_CONSTRUCT_PROMPT               = 121;
		public const int F_UI_CREATE_METHOD                  = 112;
		public const int F_UI_CTRL                           = 111;
		public const int F_UI_DUP_ERROR_STRING               = 101;
		public const int F_UI_DUP_INFO_STRING                = 102;
		public const int F_UI_DUP_INPUT_BOOLEAN              = 110;
		public const int F_UI_DUP_INPUT_STRING               = 103;
		public const int F_UI_DUP_USER_DATA                  = 118;
		public const int F_UI_DUP_VERIFY_STRING              = 106;
		public const int F_UI_GET0_RESULT                    = 107;
		public const int F_UI_GET_RESULT_LENGTH              = 119;
		public const int F_UI_NEW_METHOD                     = 104;
		public const int F_UI_PROCESS                        = 113;
		public const int F_UI_SET_RESULT                     = 105;
		public const int F_UI_SET_RESULT_EX                  = 120;
		
		/*
		 * UI reason codes.
		 */
		public const int R_COMMON_OK_AND_CANCEL_CHARACTERS   = 104;
		public const int R_INDEX_TOO_LARGE                   = 102;
		public const int R_INDEX_TOO_SMALL                   = 103;
		public const int R_NO_RESULT_BUFFER                  = 105;
		public const int R_PROCESSING_ERROR                  = 107;
		public const int R_RESULT_TOO_LARGE                  = 100;
		public const int R_RESULT_TOO_SMALL                  = 101;
		public const int R_SYSASSIGN_ERROR                   = 109;
		public const int R_SYSDASSGN_ERROR                   = 110;
		public const int R_SYSQIOW_ERROR                     = 111;
		public const int R_UNKNOWN_CONTROL_COMMAND           = 106;
		public const int R_UNKNOWN_TTYGET_ERRNO_VALUE        = 108;
		public const int R_USER_DATA_DUPLICATION_UNSUPPORTED = 112;

		/*
		 * All the following functions return -1 or NULL on error and in some cases (process()) -2 if interrupted or in some other way cancelled. When everything is fine, they return 0, a positive value or a non-NULL pointer,
		 * all depending on their purpose.
		 */
		
		/* Creators and destructor.   */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_new")]
		public extern static ui_st* new_();
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_new_method")]
		public extern static ui_st* new_method(METHOD* method);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_free")]
		public extern static void free(ui_st* ui);
		
		/*-
		   The following functions are used to add strings to be printed and prompt strings to prompt for data.  The names are {add,dup}_<function>_string and {add,dup}_input_boolean.
		
		   {add,dup}_<function>_string have the following meanings:
		        add     add a text or prompt string.  The pointers given to these functions are used verbatim, no copying is done.
		        dup     make a copy of the text or prompt string, then add the copy to the collection of strings in the user interface.
		        <function>
		                The function is a name for the functionality that the given string shall be used for.  It can be one of:
		                        input   use the string as data prompt.
		                        verify  use the string as verification prompt.  This is used to verify a previous input.
		                        info    use the string for informational output.
		                        error   use the string for error output.
		   Honestly, there's currently no difference between info and error for the moment.
		
		   {add,dup}_input_boolean have the same semantics for "add" and "dup", and are typically used when one wants to prompt for a yes/no response.
		
		   All of the functions in this group take a UI and a prompt string.
		   The string input and verify addition functions also take a flag argument, a buffer for the result to end up with, a minimum input size and a maximum input size
		   (the result buffer MUST be large enough to be able to contain the maximum number of characters).  Additionally, the verify addition functions takes another buffer to compare the result against.
		   The boolean input functions take an action description string (which should be safe to ignore if the expected user action is obvious, for example with a dialog box with an OK button and a Cancel button),
		   a string of acceptable characters to mean OK and to mean Cancel.  The two last strings are checked to make sure they don't have common characters.  Additionally, the same
		   flag argument as for the string input is taken, as well as a result buffer. The result buffer is required to be at least one byte long.
		   Depending on the answer, the first character from the OK or the Cancel character strings will be stored in the first byte of the result buffer.  No NUL will be added, so the result is *not* a string.
		
		   On success, the all return an index of the added information.  That index is useful when retrieving results with get0_result().
		*/
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_add_input_string")]
		public extern static int add_input_string(ui_st* ui, char8* prompt, int flags, char8* result_buf, int minsize, int maxsize);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_dup_input_string")]
		public extern static int dup_input_string(ui_st* ui, char8* prompt, int flags, char8* result_buf, int minsize, int maxsize);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_add_verify_string")]
		public extern static int add_verify_string(ui_st* ui, char8* prompt, int flags, char8* result_buf, int minsize, int maxsize, char8* test_buf);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_dup_verify_string")]
		public extern static int dup_verify_string(ui_st* ui, char8* prompt, int flags, char8* result_buf, int minsize, int maxsize, char8* test_buf);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_add_input_boolean")]
		public extern static int add_input_boolean(ui_st* ui, char8* prompt, char8* action_desc, char8* ok_chars, char8* cancel_chars, int flags, char8* result_buf);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_dup_input_boolean")]
		public extern static int dup_input_boolean(ui_st* ui, char8* prompt, char8* action_desc, char8* ok_chars, char8* cancel_chars, int flags, char8* result_buf);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_add_info_string")]
		public extern static int add_info_string(ui_st* ui, char8* text);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_dup_info_string")]
		public extern static int dup_info_string(ui_st* ui, char8* text);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_add_error_string")]
		public extern static int add_error_string(ui_st* ui, char8* text);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_dup_error_string")]
		public extern static int dup_error_string(ui_st* ui, char8* text);
		
		/* These are the possible flags.  They can be or'ed together. */
		/* Use to have echoing of input */
		public const int INPUT_FLAG_ECHO        = 0x01;
		/*
		 * Use a default password.  Where that password is found is completely up to the application, it might for example be in the user data set with add_user_data().  It is not recommended to have more than one input in
		 * each UI being marked with this flag, or the application might get confused.
		 */
		public const int INPUT_FLAG_DEFAULT_PWD = 0x02;
		
		/*-
		 * The user of these routines may want to define flags of their own.  The core UI won't look at those, but will pass them on to the method routines.
		 * They must use higher bits so they don't get confused with the UI bits above. INPUT_FLAG_USER_BASE tells which is the lowest bit to use.  A good example of use is this:
		 *
		 *    public const int MY_UI_FLAG1 = 0x01 << INPUT_FLAG_USER_BASE;
		 *
		*/
		public const int INPUT_FLAG_USER_BASE   = 16;
		
		/*-
		 * The following function helps construct a prompt.  object_desc is a textual short description of the object, for example "pass phrase", and object_name is the name of the object (might be a card name or a file name.
		 * The returned string shall always be allocated on the heap with OpenSSL.malloc(), and need to be free'd with OpenSSL.free().
		 *
		 * If the ui_method doesn't contain a pointer to a user-defined prompt constructor, a default string is built, looking like this:
		 *
		 *       "Enter {object_desc} for {object_name}:"
		 *
		 * So, if object_desc has the value "pass phrase" and object_name has the value "foo.key", the resulting string is:
		 *
		 *       "Enter pass phrase for foo.key:"
		*/
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_construct_prompt")]
		public extern static char8* construct_prompt(ui_st* ui_method, char8* object_desc, char8* object_name);
		
		/*
		 * The following function is used to store a pointer to user-specific data.
		 * Any previous such pointer will be returned and replaced.
		 *
		 * For callback purposes, this function makes a lot more sense than using ex_data, since the latter requires that different parts of OpenSSL or applications share the same ex_data index.
		 *
		 * Note that the OpenSSL() method completely ignores the user data. Other methods may not, however.
		 */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_add_user_data")]
		public extern static void* add_user_data(ui_st* ui, void* user_data);
		/* Alternatively, this function is used to duplicate the user data. This uses the duplicator method function.  The destroy function will be used to free the user data in this case. */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_dup_user_data")]
		public extern static int dup_user_data(ui_st* ui, void* user_data);
		/* We need a user data retrieving function as well.  */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_get0_user_data")]
		public extern static void* get0_user_data(ui_st* ui);
		
		/* Return the result associated with a prompt given with the index i. */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_get0_result")]
		public extern static char8* get0_result(ui_st* ui, int i);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_get_result_length")]
		public extern static int get_result_length(ui_st* ui, int i);
		
		/* When all strings have been added, process the whole thing. */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_process")]
		public extern static int process(ui_st* ui);
		
		/* Give a user interface parameterised control commands.  This can be used to send down an integer, a data pointer or a function pointer, as well as be used to get information from a UI. */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_ctrl")]
		public extern static int ctrl(ui_st* ui, int cmd, int i, void* p, function void() f);
		
		/* The commands */
		/* Use CONTROL_PRINT_ERRORS with the value 1 to have process print the OpenSSL error stack before printing any info or added error messages and before any prompting. */
		public const int CTRL_PRINT_ERRORS = 1;
		/* Check if a process() is possible to do again with the same instance of a user interface.  This makes ctrl() return 1 if it is redoable, and 0 if not. */
		public const int CTRL_IS_REDOABLE  = 2;
		
		/* Some methods may use extra data */
		[Inline]
		public static int set_app_data(ui_st* s, void* arg) => set_ex_data(s, 0, arg);
		[Inline]
		public static void* get_app_data(ui_st* s) => get_ex_data(s, 0);
		
		[Inline]
		public static int get_ex_new_index(int l, void* p, Crypto.EX_new newf, Crypto.EX_dup dupf, Crypto.EX_free freef) => Crypto.get_ex_new_index(Crypto.EX_INDEX_UI, l, p, newf, dupf, freef);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_set_ex_data")]
		public extern static int set_ex_data(ui_st* r, int idx, void* arg);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_get_ex_data")]
		public extern static void* get_ex_data(ui_st* r, int idx);
		
		/* Use specific methods instead of the built-in one */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_set_default_method")]
		public extern static void set_default_method(METHOD* meth);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_get_default_method")]
		public extern static METHOD* get_default_method();
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_get_method")]
		public extern static METHOD* get_method(ui_st* ui);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_set_method")]
		public extern static METHOD* set_method(ui_st* ui, METHOD* meth);
		
#if !OPENSSL_NO_UI_CONSOLE
		/* The method with all the built-in thingies */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_OpenSSL")]
		public extern static METHOD* OpenSSL();
#endif
		
		/* NULL method.  Literally does nothing, but may serve as a placeholder to avoid internal default. */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_null")]
		public extern static METHOD* null_();
		
		/* ---------- For method writers ---------- */
		/*-
		   A method contains a number of functions that implement the low level of the User Interface.  The functions are:
		
		        an opener       This function starts a session, maybe by opening a channel to a tty, or by opening a window.
		        a writer        This function is called to write a given string, maybe to the tty, maybe as a field label in a window.
		        a flusher       This function is called to flush everything that has been output so far.  It can be used to actually display a dialog box after it has been built.
		        a reader        This function is called to read a given prompt, maybe from the tty, maybe from a field in a window.  Note that it's called with all string
		                        structures, not only the prompt ones, so it must check such things itself.
		        a closer        This function closes the session, maybe by closing the channel to the tty, or closing the window.
		
		   All these functions are expected to return:
		
		        0       on error.
		        1       on success.
		        -1      on out-of-band events, for example if some prompting has been canceled (by pressing Ctrl-C, for example).  This is only checked when returned by the flusher or the reader.
		
		   The way this is used, the opener is first called, then the writer for all strings, then the flusher, then the reader for all strings and finally the closer.
		   Note that if you want to prompt from a terminal or other command line interface, the best is to have the reader also write the prompts instead of having the writer do it.
		   If you want to prompt from a dialog box, the writer can be used to build up the contents of the box, and the flusher to actually display the box and run the event loop until all data has been given,
		   after which the reader only grabs the given data and puts them back into the UI strings.
		
		   All method functions take a UI as argument.  Additionally, the writer and the reader take a STRING.
		*/
		[CRepr]
		public struct method_st
		{
		    public char8* name;
		    /* All the functions return 1 or non-NULL for success and 0 or NULL for failure */
		    /* Open whatever channel for this, be it the console, an X window or whatever. This function should use the ex_data structure to save intermediate data. */
		    public function int(ui_st* ui) ui_open_session;
		    public function int(ui_st* ui, STRING* uis) ui_write_string;
		    /* Flush the output.  If a GUI dialog box is used, this function can be used to actually display it. */
		    public function int(ui_st* ui) ui_flush;
		    public function int(ui_st* ui, STRING* uis) ui_read_string;
		    public function int(ui_st* ui) ui_close_session;
		    /* Duplicate the ui_data that often comes alongside a ui_method.  This allows some backends to save away UI information for later use. */
		    public function void*(ui_st* ui, void* ui_data) ui_duplicate_data;
		    public function void(ui_st* ui, void* ui_data) ui_destroy_data;
		    /*
		     * Construct a prompt in a user-defined manner.  object_desc is a textual short description of the object, for example "pass phrase", and object_name is the name of the object (might be a card name or a file
		     * name. The returned string shall always be allocated on the heap with OpenSSL.malloc(), and need to be free'd with OpenSSL.free().
		     */
		    public function char8*(ui_st* ui, char8* object_desc, char8* object_name) ui_construct_prompt;
		    /* METHOD specific application data. */
		    public Crypto.EX_DATA ex_data;
		}
		public typealias METHOD = method_st;
		
		/* The STRING type is the data structure that contains all the needed info about a string or a prompt, including test data for a verification prompt. */
		[CRepr]
		public struct string_st
		{
		    public string_types type;                    /* Input */
		    public char8* out_string;                    /* Input */
		    public int input_flags;                      /* Flags from the user */
		    /* The following parameters are completely irrelevant for UIT_INFO, and can therefore be set to 0 or NULL */
		    public char8* result_buf;                    /* Input and Output: If not NULL, user-defined with size in result_maxsize.
		                                                  * Otherwise, it may be allocated by the UI routine, meaning result_minsize is going to be overwritten. */
		    public uint result_len;
			public __struct _;
		
			public const int OUT_STRING_FREEABLE = 0x01;
		    public int flags;                            /* flags for internal use */

			[CRepr, Union]
			public struct __struct
			{
				public string_data_struct string_data;
				public boolean_data_struct boolean_data;

			    [CRepr]
				public struct string_data_struct
				{
			        public int result_minsize; /* Input: minimum required size of the result. */
			        public int result_maxsize; /* Input: maximum permitted size of the result */
			        public char8* test_buf;    /* Input: test string to verify against */
			    }
			    [CRepr]
				public struct boolean_data_struct
				{
			        public char8* action_desc;  /* Input */
			        public char8* ok_chars;     /* Input */
			        public char8* cancel_chars; /* Input */
			    }
			}
		}
		public typealias STRING = string_st;
		public struct stack_st_UI_STRING {}

		[CRepr]
		public struct ui_st
		{
		    public METHOD* meth;
		    public stack_st_UI_STRING* strings;          /* We might want to prompt for more than one thing at a time, and with different echoing status.  */
		    public void* user_data;
		    public Crypto.EX_DATA ex_data;
			public const int FLAG_REDOABLE     = 0x0001;
			public const int FLAG_DUPL_DATA    = 0x0002; /* user_data was duplicated */
			public const int FLAG_PRINT_ERRORS = 0x0100;
		    public int flags;

		    public Crypto.RWLOCK* lock;
		}
		public typealias UI = ui_st;
		
		/* The different types of strings that are currently supported. This is only needed by method authors. */
		[CRepr]
		public enum string_types
		{
		    UIT_NONE = 0,
		    UIT_PROMPT,   /* Prompt for a string */
		    UIT_VERIFY,   /* Prompt for a string and verify */
		    UIT_BOOLEAN,  /* Prompt for a yes/no response */
		    UIT_INFO,     /* Send info to the user */
		    UIT_ERROR     /* Send an error message to the user */
		}
		
		/* Create and manipulate methods */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_create_method")]
		public extern static METHOD* create_method(char8* name);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_destroy_method")]
		public extern static void destroy_method(METHOD* ui_method);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_set_opener")]
		public extern static int method_set_opener(METHOD* method, function int(ui_st* ui) opener);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_set_writer")]
		public extern static int method_set_writer(METHOD* method, function int(ui_st* ui, STRING* uis) writer);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_set_flusher")]
		public extern static int method_set_flusher(METHOD* method, function int(ui_st* ui) flusher);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_set_reader")]
		public extern static int method_set_reader(METHOD* method, function int(ui_st* ui, STRING* uis) reader);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_set_closer")]
		public extern static int method_set_closer(METHOD* method, function int(ui_st* ui) closer);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_set_data_duplicator")]
		public extern static int method_set_data_duplicator(METHOD* method, function void*(ui_st* ui, void* ui_data) duplicator, function void(ui_st* ui, void* ui_data) destructor);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_set_prompt_constructor")]
		public extern static int method_set_prompt_constructor(METHOD* method, function char8*(ui_st* ui, char8* object_desc, char8* object_name) prompt_constructor);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_set_ex_data")]
		public extern static int method_set_ex_data(METHOD* method, int idx, void* data);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_get_opener")]
		public extern static function int(ui_st*) method_get_opener(METHOD* method);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_get_writer")]
		public extern static function int(ui_st*, STRING*) method_get_writer(METHOD* method);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_get_flusher")]
		public extern static function int(ui_st*) method_get_flusher(METHOD* method);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_get_reader")]
		public extern static function int(ui_st*, STRING*) method_get_reader(METHOD* method);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_get_closer")]
		public extern static function int(ui_st*) method_get_closer(METHOD* method);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_get_prompt_constructor")]
		public extern static function char8*(ui_st*, char8*, char8*) method_get_prompt_constructor(METHOD* method);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_get_data_duplicator")]
		public extern static function void*(ui_st*, void* ) method_get_data_duplicator(METHOD* method);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_get_data_destructor")]
		public extern static function void(ui_st*, void*) method_get_data_destructor(METHOD* method);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_method_get_ex_data")]
		public extern static void* method_get_ex_data(METHOD* method, int idx);
		
		/* The following functions are helpers for method writers to access relevant data from a STRING. */
		
		/* Return type of the STRING */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_get_string_type")]
		public extern static string_types get_string_type(STRING* uis);
		/* Return input flags of the STRING */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_get_input_flags")]
		public extern static int get_input_flags(STRING* uis);
		/* Return the actual string to output (the prompt, info or error) */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_get0_output_string")]
		public extern static char8* get0_output_string(STRING* uis);
		/* Return the optional action string to output (the boolean prompt instruction) */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_get0_action_string")]
		public extern static char8* get0_action_string(STRING* uis);
		/* Return the result of a prompt */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_get0_result_string")]
		public extern static char8* get0_result_string(STRING* uis);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_get_result_string_length")]
		public extern static int get_result_string_length(STRING* uis);
		/* Return the string to test the result against.  Only useful with verifies. */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_get0_test_string")]
		public extern static char8* get0_test_string(STRING* uis);
		/* Return the required minimum size of the result */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_get_result_minsize")]
		public extern static int get_result_minsize(STRING* uis);
		/* Return the required maximum size of the result */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_get_result_maxsize")]
		public extern static int get_result_maxsize(STRING* uis);
		/* Set the result of a STRING. */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_set_result")]
		public extern static int set_result(ui_st* ui, STRING* uis, char8* result);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_set_result_ex")]
		public extern static int set_result_ex(ui_st* ui, STRING* uis, char8* result, int len);
		
		/* A couple of popular utility functions */
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_UTIL_read_pw_string")]
		public extern static int UTIL_read_pw_string(char8* buf, int length, char8* prompt, int verify);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_UTIL_read_pw")]
		public extern static int UTIL_read_pw(char8* buf, char8* buff, int size, char8* prompt, int verify);
		[Import(OPENSSL_LIB_CRYPTO), LinkName("UI_UTIL_wrap_read_pem_callback")]
		public extern static METHOD* UTIL_wrap_read_pem_callback(PEM.password_cb* cb, int rwflag);
	}
}
